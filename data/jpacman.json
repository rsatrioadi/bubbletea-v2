{"elements": {"nodes": [{"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).1", "labels": ["Variable"], "properties": {"simpleName": "ghosts", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "A list to store all ghosts in the level."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setAlive(boolean).0", "labels": ["Variable"], "properties": {"simpleName": "isAlive", "qualifiedName": "nl.tudelft.jpacman.level.Player.setAlive(boolean).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The new alive status of the player."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getSquare()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The square for this node.\r\n */\r\nprivate nl.tudelft.jpacman.board.Square getSquare() {\r\n    return this.square;\r\n}", "docComment": "\r\n@return The square for this node.\r\n", "metaSrc": "source code", "description": "Returns the square associated with the node.", "returns": "The square object representing the location of the node on the game board.", "reason": "This method provides a straightforward access to the square data stored in the node, which is essential for navigation and collision detection in the Pacman game.", "howToUse": "To use this method, simply call it on an instance of `Navigation$Node`.", "howItWorks": "The method returns the value of the private field `square`, which holds the reference to the square object associated with the node. This is a simple getter method that does not perform any additional operations or calculations.", "preConditions": [], "postConditions": [], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getGhostFactory()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return A new factory using the sprites from {@link #getSpriteStore()}.\r\n */\r\nprotected nl.tudelft.jpacman.npc.ghost.GhostFactory getGhostFactory() {\r\n    return new nl.tudelft.jpacman.npc.ghost.GhostFactory(this.getSpriteStore());\r\n}", "docComment": "\r\n@return A new factory using the sprites from {@link #getSpriteStore()}.\r\n", "metaSrc": "source code", "description": "Returns a GhostFactory instance initialized with the current SpriteStore.", "returns": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "reason": "The method provides a factory for creating ghost entities in the game, using the current sprite store to define their appearance and behavior.", "howToUse": "Call this method from within the Launcher class to obtain a GhostFactory instance.", "howItWorks": "The method creates a new GhostFactory object by passing the current SpriteStore instance to its constructor. This factory is then used to create ghost entities in the game.", "assertions": {"preConditions": ["The Launcher class has access to the SpriteStore instance.", "The SpriteStore instance contains valid sprite data for ghosts."], "postConditions": ["A GhostFactory object is returned, initialized with the current SpriteStore."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "boolean", "labels": ["Primitive"], "properties": {"simpleName": "boolean", "qualifiedName": "boolean", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "/**\r\n * Moves the specified player one square in the given direction.\r\n *\r\n * @param player\r\n * \t\tThe player to move.\r\n * @param direction\r\n * \t\tThe direction to move in.\r\n */\r\npublic void move(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.board.Direction direction) {\r\n    if (this.isInProgress()) {\r\n        // execute player move.\r\n        this.getLevel().move(player, direction);\r\n        this.pointCalculator.pacmanMoved(player, direction);\r\n    }\r\n}", "docComment": "Moves the specified player one square in the given direction.\r\n\r\n@param player\r\n\t\tThe player to move.\r\n@param direction\r\n\t\tThe direction to move in.\r\n", "metaSrc": "source code", "description": "Moves a player in the game board based on the given direction and updates the level state.", "returns": "", "reason": "This method is part of the Service Layer as it orchestrates the game flow by moving a player and updating the level state.", "howToUse": "Call this method with a Player object and a Direction object to move the player in the game board.", "howItWorks": "The method checks if the game is in progress, then moves the player using the getLevel().move() method and updates the points for the player using pointCalculator.pacmanMoved().", "assertions": {"preConditions": ["The game must be in progress.", "The player object must not be null."], "postConditions": ["The player's position on the board should be updated based on the given direction.", "The points for the player should be updated accordingly."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.Action.doAction()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "doAction()", "qualifiedName": "nl.tudelft.jpacman.ui.Action.doAction()", "kind": "method", "sourceText": "/**\r\n * Executes the action.\r\n */\r\nvoid doAction();", "docComment": "Executes the action.\r\n", "metaSrc": "source code", "description": "Performs an action in the Pacman game.", "returns": "", "reason": "The method is part of the user interface layer as it defines how actions are performed in the game, which is a UI-related operation.", "howToUse": "Call this method to perform an action in the game, such as moving Pacman or eating pellets.", "howItWorks": "This method is typically implemented by subclasses that handle specific actions like moving Pacman, eating pellets, or interacting with enemies. It may involve updating game state and triggering UI updates.", "preConditions": ["The game is running", "Pacman's current position is known"], "postConditions": ["Pacman's position has changed", "Game state updated accordingly"], "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game).0", "labels": ["Variable"], "properties": {"simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidedOn", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that the player collided with."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "draw(java.awt.Graphics,int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "kind": "method", "sourceText": "/**\r\n * Draws the sprite on the provided graphics context.\r\n *\r\n * @param graphics\r\n * \t\tThe graphics context to draw.\r\n * @param x\r\n * \t\tThe destination x coordinate to start drawing.\r\n * @param y\r\n * \t\tThe destination y coordinate to start drawing.\r\n * @param width\r\n * \t\tThe width of the destination draw area.\r\n * @param height\r\n * \t\tThe height of the destination draw area.\r\n */\r\nvoid draw(java.awt.Graphics graphics, int x, int y, int width, int height);", "docComment": "Draws the sprite on the provided graphics context.\r\n\r\n@param graphics\r\n\t\tThe graphics context to draw.\r\n@param x\r\n\t\tThe destination x coordinate to start drawing.\r\n@param y\r\n\t\tThe destination y coordinate to start drawing.\r\n@param width\r\n\t\tThe width of the destination draw area.\r\n@param height\r\n\t\tThe height of the destination draw area.\r\n", "metaSrc": "source code", "description": "Draws the sprite on the given graphics context at specified coordinates and dimensions.", "returns": "void", "reason": "This method is part of the interface for drawing sprites, which is a fundamental operation in game development.", "howToUse": "To use this method, you need to provide a Graphics object and specify the position and size where you want to draw the sprite.", "howItWorks": "The method uses the provided Graphics object to draw the sprite at the specified coordinates with the given width and height.", "preConditions": ["A valid Graphics object must be provided.", "The x, y, width, and height values must be within the bounds of the screen or game area."], "postConditions": ["The sprite is drawn on the screen at the specified position with the given dimensions.", "No side effects are expected beyond drawing the sprite."], "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "labels": ["Variable"], "properties": {"simpleName": "handler", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "setAlive(boolean)", "qualifiedName": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "kind": "method", "sourceText": "/**\r\n * Sets whether this player is alive or not.\r\n *\r\n * If the player comes back alive, the {@link killer} will be reset.\r\n *\r\n * @param isAlive\r\n * \t\t<code>true</code> iff this player is alive.\r\n */\r\npublic void setAlive(boolean isAlive) {\r\n    if (isAlive) {\r\n        this.deathSprite.setAnimating(false);\r\n        this.killer = null;\r\n    }\r\n    if (!isAlive) {\r\n        this.deathSprite.restart();\r\n    }\r\n    this.alive = isAlive;\r\n}", "docComment": "Sets whether this player is alive or not.\r\n\r\nIf the player comes back alive, the {@link killer} will be reset.\r\n\r\n@param isAlive\r\n\t\t<code>true</code> iff this player is alive.\r\n", "metaSrc": "source code", "description": "Sets the player's alive status and updates their death sprite accordingly.", "returns": "", "reason": "This method manages the player's state and visual representation in the game, ensuring that the player's sprite reflects their current health.", "howToUse": "Call this method with a boolean value to set the player's alive status. If the player is killed, pass false; if they are revived, pass true.", "howItWorks": "The method checks the new alive status and updates the death sprite accordingly. If the player is alive, it stops animating their death sprite and sets the killer to null. If the player is dead, it restarts their death sprite animation.", "assertions": {"preConditions": ["The input boolean value must be either true or false."], "postConditions": ["The player's alive status should reflect the new value passed to the method.", "The death sprite should be in the correct state based on the player's alive status."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGameFactory()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getGameFactory()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getGameFactory()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return A new factory using the players from {@link #getPlayerFactory()}.\r\n */\r\nprotected nl.tudelft.jpacman.game.GameFactory getGameFactory() {\r\n    return new nl.tudelft.jpacman.game.GameFactory(this.getPlayerFactory());\r\n}", "docComment": "\r\n@return A new factory using the players from {@link #getPlayerFactory()}.\r\n", "metaSrc": "source code", "description": "Returns a new GameFactory instance using the current PlayerFactory.", "returns": "nl.tudelft.jpacman.game.GameFactory", "reason": "The method provides a way to create a game factory that uses the player factory, which is essential for setting up the game environment.", "howToUse": "Call this method from within another class or method that requires a GameFactory instance.", "howItWorks": "The method creates a new GameFactory by passing the current PlayerFactory as an argument to its constructor. This allows the GameFactory to use the sprites and other resources defined in the PlayerFactory.", "preConditions": [], "postConditions": ["A new GameFactory instance is returned that uses the current PlayerFactory."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "format(nl.tudelft.jpacman.level.Player)", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "kind": "method", "sourceText": "/**\r\n * Format the score of a given player.\r\n *\r\n * @param player\r\n * \t\tThe player and its score\r\n * @return Formatted score.\r\n */\r\njava.lang.String format(nl.tudelft.jpacman.level.Player player);", "docComment": "Format the score of a given player.\r\n\r\n@param player\r\n\t\tThe player and its score\r\n@return Formatted score.\r\n", "metaSrc": "source code", "description": "Formats the score for a given player in the Pacman game.", "returns": "A string representing the formatted score of the player.", "reason": "The method is part of the user interface layer, responsible for displaying the game's score to the player.", "howToUse": "Call this method with a Player object to get a formatted string that represents their current score in the game.", "howItWorks": "The method retrieves the player's score from the Player object and formats it into a readable string. This is typically done by concatenating the score value with a descriptive label or format.", "preConditions": ["A valid Player object must be provided as an argument to the method."], "postConditions": ["The returned string will contain the player's score formatted for display in the user interface."], "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startSquareIndex", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The start current selected starting square.\r\n */\r\nprivate int startSquareIndex;", "visibility": "private", "simpleName": "startSquareIndex", "qualifiedName": "nl.tudelft.jpacman.level.Level.startSquareIndex", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getInheritance(java.lang.Class)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "kind": "method", "sourceText": "/**\r\n * Returns a list of all classes and interfaces the class inherits.\r\n *\r\n * @param clazz\r\n * \t\tThe class to create a list of super classes and interfaces\r\n * \t\tfor.\r\n * @return A list of all classes and interfaces the class inherits.\r\n */\r\n@java.lang.SuppressWarnings(\"unchecked\")\r\nprivate java.util.List<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>> getInheritance(java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> clazz) {\r\n    java.util.List<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>> found = new java.util.ArrayList<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>>();\r\n    found.add(clazz);\r\n    int index = 0;\r\n    while (found.size() > index) {\r\n        java.lang.Class<? extends java.lang.Object> current = found.get(index);\r\n        java.lang.Class<? extends java.lang.Object> superClass = current.getSuperclass();\r\n        if ((superClass != null) && nl.tudelft.jpacman.board.Unit.class.isAssignableFrom(superClass)) {\r\n            found.add(((java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>) (superClass)));\r\n        }\r\n        for (java.lang.Class<? extends java.lang.Object> classInterface : current.getInterfaces()) {\r\n            if (nl.tudelft.jpacman.board.Unit.class.isAssignableFrom(classInterface)) {\r\n                found.add(((java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>) (classInterface)));\r\n            }\r\n        }\r\n        index++;\r\n    } \r\n    return found;\r\n}", "docComment": "Returns a list of all classes and interfaces the class inherits.\r\n\r\n@param clazz\r\n\t\tThe class to create a list of super classes and interfaces\r\n\t\tfor.\r\n@return A list of all classes and interfaces the class inherits.\r\n", "metaSrc": "source code", "description": "The method retrieves all classes that are subclasses or implement interfaces of the given class, including itself.", "returns": "A list of classes that are subclasses or implement interfaces of the given class.", "reason": "This method is used to determine which units can interact with each other based on their inheritance and interface relationships.", "howToUse": "Call this method with a class representing a unit, such as `Pacman` or `Ghost`. It will return a list of all classes that are subclasses or implement interfaces of the given class.", "howItWorks": "The method starts by adding the given class to a list. It then iterates over the superclass and interfaces of each class in the list, checking if they are subclasses or implement interfaces of `Unit`. If so, it adds them to the list. This process continues until no new classes are found.", "assertions": {"preConditions": ["The input class is not null."], "postConditions": ["The returned list contains all classes that are subclasses or implement interfaces of the given class."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.sprites", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The sprite map, one sprite for each direction.\r\n */\r\nprivate final java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> sprites;", "visibility": "private", "simpleName": "sprites", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.sprites", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.getHeight()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getHeight()", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.getHeight()", "kind": "method", "sourceText": "/**\r\n * Returns the height of this sprite.\r\n *\r\n * @return The height of this sprite in pixels.\r\n */\r\nint getHeight();", "docComment": "Returns the height of this sprite.\r\n\r\n@return The height of this sprite in pixels.\r\n", "metaSrc": "source code", "description": "Returns the height of the sprite in pixels.", "returns": "The height of the sprite as an integer.", "reason": "This method provides a way to access the visual dimensions of a sprite, which is essential for rendering and positioning it correctly within the game environment.", "howToUse": "Call `getHeight()` on any instance of a class that implements the `Sprite` interface to retrieve its height in pixels.", "howItWorks": "The method returns an integer value representing the height of the sprite. This is typically calculated based on the dimensions set during the creation or initialization of the sprite object.", "preConditions": [], "postConditions": ["The returned value represents the height of the sprite in pixels."], "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).2", "labels": ["Variable"], "properties": {"simpleName": "visited", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "A set of visited squares to avoid revisiting them."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).1", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "Y-coordinate to check"}}}, {"data": {"id": "char", "labels": ["Primitive"], "properties": {"simpleName": "char", "qualifiedName": "char", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.pointCalculator", "labels": ["Variable"], "properties": {"sourceText": "private nl.tudelft.jpacman.points.PointCalculator pointCalculator;", "visibility": "private", "simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.pointCalculator", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.NORTH", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * North, or up.\r\n */\r\nNORTH(0, -1)", "visibility": "public", "simpleName": "NORTH", "qualifiedName": "nl.tudelft.jpacman.board.Direction.NORTH", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The destination y coordinate to start drawing."}}}, {"data": {"id": "long", "labels": ["Primitive"], "properties": {"simpleName": "long", "qualifiedName": "long", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor", "labels": ["Structure"], "properties": {"docComment": "A list of supported ghost colors.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "GhostColor", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostColor", "kind": "enum", "metaSrc": "source code", "description": "The enum `GhostColor` in the Pacman implementation is responsible for representing different colors associated with ghosts in the game. It provides a way to identify and manage various ghost types based on their color.", "layer": "Domain Layer", "roleStereotype": "Information Holder", "keywords": ["enum", "Pacman", "ghosts", "colors"]}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSquareAt(nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "/**\r\n * Returns the square adjacent to this square.\r\n *\r\n * @param direction\r\n * \t\tThe direction of the adjacent square.\r\n * @return The adjacent square in the given direction.\r\n */\r\npublic nl.tudelft.jpacman.board.Square getSquareAt(nl.tudelft.jpacman.board.Direction direction) {\r\n    return this.neighbours.get(direction);\r\n}", "docComment": "Returns the square adjacent to this square.\r\n\r\n@param direction\r\n\t\tThe direction of the adjacent square.\r\n@return The adjacent square in the given direction.\r\n", "metaSrc": "source code", "description": "Returns the square in the specified direction from the current square.", "returns": "The Square object at the given direction from the current square.", "reason": "This method provides a straightforward way to access neighboring squares on the game board, which is essential for movement and collision detection in the Pacman game.", "howToUse": "Call this method with a Direction enum value (e.g., Direction.UP) to get the Square object at that direction from the current square.", "howItWorks": "The method uses the 'neighbours' map, which is assumed to be initialized and contains all neighboring squares. It retrieves the Square object associated with the specified direction using the get() method of the Map interface.", "preConditions": ["The 'neighbours' map must be properly initialized and contain valid entries for all directions."], "postConditions": ["The returned Square object is either null or represents a valid square on the game board."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.PINKY", "labels": ["Variable"], "properties": {"sourceText": "private static final int PINKY = 2;", "visibility": "private", "simpleName": "PINKY", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.PINKY", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0", "labels": ["Variable"], "properties": {"simpleName": "spriteMap", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The sprites for every direction."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The x-coordinate of the top-left corner of the region to split."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new animating sprite that will change frames every interval. By\r\n * default the sprite is not animating.\r\n *\r\n * @param frames\r\n * \t\tThe frames of this animation.\r\n * @param delay\r\n * \t\tThe delay between frames.\r\n * @param loop\r\n * \t\tWhether or not this sprite should be looping.\r\n */\r\npublic AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[] frames, int delay, boolean loop) {\r\n    this(frames, delay, loop, false);\r\n}", "docComment": "Creates a new animating sprite that will change frames every interval. By\r\ndefault the sprite is not animating.\r\n\r\n@param frames\r\n\t\tThe frames of this animation.\r\n@param delay\r\n\t\tThe delay between frames.\r\n@param loop\r\n\t\tWhether or not this sprite should be looping.\r\n", "metaSrc": "source code", "description": "Initializes an animated sprite with specified frames, delay, looping behavior, and animation state.", "returns": "The newly created AnimatedSprite instance.", "reason": "This method provides a convenient way to create an animated sprite with the specified frames, delay, and looping behavior. It initializes the animation state as false by default.", "howToUse": "To use this method, you need to provide an array of Sprite objects representing the frames of the animation, an integer for the delay between frames, and a boolean indicating whether the animation should loop.", "howItWorks": "The method calls another constructor with additional parameters (false) to initialize the AnimatedSprite instance. This ensures that the animation starts from the beginning when it is created.", "preConditions": ["frames must be an array of Sprite objects", "delay must be a positive integer", "loop must be either true or false"], "postConditions": ["a new AnimatedSprite instance is returned with the specified frames, delay, and looping behavior", "the animation state is set to false by default"], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).4", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code", "description": "The height of the destination draw area."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).0", "labels": ["Variable"], "properties": {"simpleName": "directions", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A list of directions specifying the path to follow."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getPacmanSprites()", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return A map of animated Pac-Man sprites for all directions.\r\n */\r\npublic java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> getPacmanSprites() {\r\n    return this.directionSprite(\"/sprite/pacman.png\", nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_ANIMATION_FRAMES);\r\n}", "docComment": "\r\n@return A map of animated Pac-Man sprites for all directions.\r\n", "metaSrc": "source code", "description": "Returns a map from directions to animated sprites for Pacman based on a base image and splits it into frames.", "returns": "A map from directions to animated sprites.", "reason": "This method provides a convenient way to create and manage animated Pacman sprites for different directions, which is essential for the game's visual representation.", "howToUse": "Call `getPacmanSprites()` to retrieve a map of animated Pacman sprites. This can be used in the game logic to display Pacman in various directions based on its movement.", "howItWorks": "The method uses the `directionSprite` helper method to create animated sprites for each direction by splitting the base image into frames and mapping them to their respective directions.", "preConditions": ["A valid resource name is provided."], "postConditions": ["An instance of `Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite>` is returned containing animated sprites for each direction."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).1", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The direction in which the unit should move."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getSprites()", "qualifiedName": "nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "kind": "method", "sourceText": "/**\r\n * The sprites created by the factory.\r\n *\r\n * @return The sprites for the player created.\r\n */\r\nprotected nl.tudelft.jpacman.sprite.PacManSprites getSprites() {\r\n    return this.sprites;\r\n}", "docComment": "The sprites created by the factory.\r\n\r\n@return The sprites for the player created.\r\n", "metaSrc": "source code", "description": "Returns the PacMan sprites used in the game.", "returns": "The PacManSprites instance containing all necessary sprite resources for the game.", "reason": "This method provides access to the PacMan sprites, which are essential for rendering the game characters and animations.", "howToUse": "To use this method, simply call it from a class that has access to an instance of PlayerFactory. This will return the PacManSprites object containing all required sprite resources.", "howItWorks": "The method directly returns the `sprites` field of the PlayerFactory instance. This field is initialized during the construction of the PlayerFactory and holds references to all necessary sprite objects used in the game.", "preConditions": [], "postConditions": ["The returned object is not null.", "The returned object contains all required PacMan sprites for rendering the game."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "addStartButton(nl.tudelft.jpacman.game.Game)", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "kind": "method", "sourceText": "/**\r\n * Adds a button with the caption {@value #START_CAPTION} that starts the\r\n * game.\r\n *\r\n * @param game\r\n * \t\tThe game to start.\r\n */\r\nprivate void addStartButton(final nl.tudelft.jpacman.game.Game game) {\r\n    assert game != null;\r\n    this.buttons.put(nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION, game::start);\r\n}", "docComment": "Adds a button with the caption {@value #START_CAPTION} that starts the\r\ngame.\r\n\r\n@param game\r\n\t\tThe game to start.\r\n", "metaSrc": "source code", "description": "Adds a start button to the game UI that, when clicked, starts the game.", "returns": "", "reason": "This method is part of the UI layer as it manages the user interface and adds a button that interacts with the game logic.", "howToUse": "Call this method with an instance of nl.tudelft.jpacman.game.Game to add a start button to the game's UI.", "howItWorks": "The method uses the buttons map to store the start button caption and its corresponding action (starting the game). It then adds this button to the UI using the provided game instance.", "assertions": {"preConditions": ["game is not null"], "postConditions": []}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createPinky()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "kind": "method", "sourceText": "/**\r\n * Creates a new Pinky / Speedy, the pink Ghost.\r\n *\r\n * @see Pinky\r\n * @return A new Pinky.\r\n */\r\npublic nl.tudelft.jpacman.npc.Ghost createPinky() {\r\n    return new nl.tudelft.jpacman.npc.ghost.Pinky(this.sprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor.PINK));\r\n}", "docComment": "Creates a new Pinky / Speedy, the pink Ghost.\r\n\r\n@see Pinky\r\n@return A new Pinky.\r\n", "metaSrc": "source code", "description": "Creates an instance of Pinky ghost using its sprite based on the specified color.", "returns": "An instance of Pinky ghost.", "reason": "The method is part of the domain layer as it creates a specific entity (Pinky) based on configuration data.", "howToUse": "Call this method with the appropriate color to get an instance of Pinky.", "howItWorks": "The method retrieves the sprite for Pinky from the sprites map using the specified color and returns a new instance of Pinky.", "preConditions": ["The sprites map is initialized and contains animated ghost sprites for all directions."], "postConditions": ["A new instance of Pinky is created with the appropriate sprite based on the specified color."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore", "labels": ["Structure"], "properties": {"docComment": "Utility to load {@link Sprite}s.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "SpriteStore", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore", "kind": "class", "metaSrc": "source code", "description": "Manages sprite resources by storing and retrieving them efficiently, providing methods to create animated sprites and load sprites from resources.", "layer": "Domain Layer", "roleStereotype": "Service Provider", "keywords": ["sprite management", "animation creation", "resource loading"], "dependencyProfile": "hidden"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "invariant(nl.tudelft.jpacman.board.Square)", "qualifiedName": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "kind": "method", "sourceText": "/**\r\n * Verifies that all occupants on this square have indeed listed this square\r\n * as the square they are currently occupying.\r\n *\r\n * @return <code>true</code> iff all occupants of this square have this\r\nsquare listed as the square they are currently occupying.\r\n */\r\nprotected final boolean invariant(nl.tudelft.jpacman.board.Square this) {\r\n    for (nl.tudelft.jpacman.board.Unit occupant : this.occupants) {\r\n        if (occupant.hasSquare() && (occupant.getSquare() != this)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}", "docComment": "Verifies that all occupants on this square have indeed listed this square\r\nas the square they are currently occupying.\r\n\r\n@return <code>true</code> iff all occupants of this square have this\r\nsquare listed as the square they are currently occupying.\r\n", "metaSrc": "source code", "description": "Checks if all units on the square are correctly assigned to their squares.", "returns": "Boolean indicating whether the invariant holds true for the given square.", "reason": "Ensures that each unit is only occupying one square and no two units occupy the same square, maintaining game integrity.", "howToUse": "Call this method on a Square object to verify its state.", "howItWorks": "Iterates over all occupants of the square and checks if they are correctly assigned to their squares. Returns true if all checks pass; otherwise, returns false.", "assertions": {"preConditions": ["The square is not null."], "postConditions": ["Returns true if the invariant holds for the given square."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.INTERVAL_VARIATION", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The variation in intervals, this makes the ghosts look more dynamic and\r\n * less predictable.\r\n */\r\nprivate static final int INTERVAL_VARIATION = 50;", "visibility": "private", "simpleName": "INTERVAL_VARIATION", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Pinky.INTERVAL_VARIATION", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.looping", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Whether is animation should be looping or not.\r\n */\r\nprivate final boolean looping;", "visibility": "private", "simpleName": "looping", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.looping", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet", "labels": ["Structure"], "properties": {"docComment": "A pellet, one of the little dots Pac-Man has to collect.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Pellet", "qualifiedName": "nl.tudelft.jpacman.level.Pellet", "kind": "class", "metaSrc": "source code", "description": "The Pellet class is responsible for representing pellets in the Pacman game, which are collectible items that provide points to the player. It manages the visual representation and point value of these pellets.", "layer": "Domain Layer", "roleStereotype": "Information Holder", "keywords": ["Pellet", "Pacman", "Collectible Item", "Points", "Sprite"], "dependencyProfile": "transit"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.sprites", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The animations for every direction.\r\n */\r\nprivate final java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> sprites;", "visibility": "private", "simpleName": "sprites", "qualifiedName": "nl.tudelft.jpacman.level.Player.sprites", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.util.Map)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new \"Pinky\", a.k.a. \"Speedy\".\r\n *\r\n * @param spriteMap\r\n * \t\tThe sprites for this ghost.\r\n */\r\npublic Pinky(java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> spriteMap) {\r\n    super(spriteMap, nl.tudelft.jpacman.npc.ghost.Pinky.MOVE_INTERVAL, nl.tudelft.jpacman.npc.ghost.Pinky.INTERVAL_VARIATION);\r\n}", "docComment": "Creates a new \"Pinky\", a.k.a. \"Speedy\".\r\n\r\n@param spriteMap\r\n\t\tThe sprites for this ghost.\r\n", "metaSrc": "source code", "description": "Initializes a new Pinky ghost with specified sprite map, move interval, and interval variation.", "returns": "A newly created Pinky ghost instance.", "reason": "This method initializes a new Ghost instance with specific parameters required to create and configure the Pinky character in the Pacman game.", "howToUse": "To use this method, you need to provide a map of sprites for each direction (up, down, left, right) that will be used to represent the Pinky ghost. The move interval and interval variation are also required to define how fast the ghost moves and how much its movement can vary.", "howItWorks": "The method calls the superclass constructor with the provided sprite map, move interval, and interval variation as arguments. This initializes the Pinky ghost with the specified properties.", "assertions": {"preConditions": ["A valid Map of sprites for each direction is provided."], "postConditions": ["A new Pinky ghost instance is created with the specified properties."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createGround()", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "kind": "method", "sourceText": "/**\r\n * Creates a new square that can be occupied by any unit.\r\n *\r\n * @return A new square that can be occupied by any unit.\r\n */\r\npublic nl.tudelft.jpacman.board.Square createGround() {\r\n    return new nl.tudelft.jpacman.board.BoardFactory.Ground(this.sprites.getGroundSprite());\r\n}", "docComment": "Creates a new square that can be occupied by any unit.\r\n\r\n@return A new square that can be occupied by any unit.\r\n", "metaSrc": "source code", "description": "Creates a new Ground square using the loaded floor sprite.", "returns": "A new Square representing the ground.", "reason": "The method is part of the BoardFactory class, which is responsible for creating game board components like squares and walls. The Ground square represents the playable area in the game.", "howToUse": "Call this method to create a new Ground square on the game board.", "howItWorks": "The method retrieves the ground sprite using the getGroundSprite() method, which loads an image from a resource file. It then creates and returns a new Square object initialized with the loaded sprite.", "assertions": {"preConditions": [], "postConditions": ["A new Ground square is created and returned."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$LevelObserver.levelLost()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "levelLost()", "qualifiedName": "nl.tudelft.jpacman.level.Level$LevelObserver.levelLost()", "kind": "method", "sourceText": "/**\r\n * The level has been lost. Typically the level should be stopped when\r\n * this event is received.\r\n */\r\nvoid levelLost();", "docComment": "The level has been lost. Typically the level should be stopped when\r\nthis event is received.\r\n", "metaSrc": "source code", "description": "Notifies observers that the level has been lost.", "returns": "", "reason": "The method is part of the LevelObserver interface, which is used to observe changes in the game's level state. When a level is lost, it triggers an event that notifies all registered observers.", "howToUse": "Implement this method in any class that implements the LevelObserver interface and register it with the Level object using the addLevelObserver() method.", "howItWorks": "The method simply calls the notifyObservers() method of the Observer interface, which triggers all registered observers to perform their respective actions when a level is lost.", "preConditions": ["A Level object exists.", "At least one observer has been added to the Level object."], "postConditions": ["All registered observers are notified that the level has been lost."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator).0", "labels": ["Variable"], "properties": {"simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).4", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code", "description": "The width of the area to render the square."}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "labels": ["Constructor"], "properties": {"visibility": "protected", "simpleName": "<init>(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "kind": "constructor", "sourceText": "/**\r\n * Create a new single player game for the provided level and player.\r\n *\r\n * @param player\r\n * \t\tThe player.\r\n * @param level\r\n * \t\tThe level.\r\n * @param pointCalculator\r\n * \t\tThe way to calculate points upon collisions.\r\n */\r\nprotected SinglePlayerGame(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.level.Level level, nl.tudelft.jpacman.points.PointCalculator pointCalculator) {\r\n    super(pointCalculator);\r\n    assert player != null;\r\n    assert level != null;\r\n    this.player = player;\r\n    this.level = level;\r\n    this.level.registerPlayer(player);\r\n}", "docComment": "Create a new single player game for the provided level and player.\r\n\r\n@param player\r\n\t\tThe player.\r\n@param level\r\n\t\tThe level.\r\n@param pointCalculator\r\n\t\tThe way to calculate points upon collisions.\r\n", "metaSrc": "source code", "description": "Initializes a single-player game instance with a player, level, and point calculator.", "returns": "A new instance of SinglePlayerGame.", "reason": "This method initializes a single-player game by setting up the player, level, and point calculator, ensuring they are correctly associated with each other.", "howToUse": "Create an instance of SinglePlayerGame by providing a Player, Level, and PointCalculator. This setup is essential for starting a new game in the Pacman implementation.", "howItWorks": "The method initializes the superclass with the point calculator, checks that the player and level are not null, assigns them to instance variables, and registers the player on the level.", "assertions": {"preConditions": ["player is not null", "level is not null"], "postConditions": ["SinglePlayerGame instance is created with the provided parameters", "player is registered on the level"]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).1", "labels": ["Variable"], "properties": {"simpleName": "delay", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The delay between frames."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getMostSpecificClass(java.util.Map,java.lang.Class)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "kind": "method", "sourceText": "/**\r\n * Figures out the most specific class that is listed in the map. I.e. if A\r\n * extends B and B is listed while requesting A, then B will be returned.\r\n *\r\n * @param map\r\n * \t\tThe map with the key collection to find a matching class in.\r\n * @param key\r\n * \t\tThe class to search the most suitable key for.\r\n * @return The most specific class from the key collection.\r\n */\r\nprivate java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> getMostSpecificClass(java.util.Map<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, ? extends java.lang.Object> map, java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> key) {\r\n    java.util.List<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>> collideeInheritance = this.getInheritance(key);\r\n    for (java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> pointer : collideeInheritance) {\r\n        if (map.containsKey(pointer)) {\r\n            return pointer;\r\n        }\r\n    }\r\n    return null;\r\n}", "docComment": "Figures out the most specific class that is listed in the map. I.e. if A\r\nextends B and B is listed while requesting A, then B will be returned.\r\n\r\n@param map\r\n\t\tThe map with the key collection to find a matching class in.\r\n@param key\r\n\t\tThe class to search the most suitable key for.\r\n@return The most specific class from the key collection.\r\n", "metaSrc": "source code", "description": "The method retrieves the most specific class from a map that contains classes as keys and objects as values, based on inheritance.", "returns": "The most specific class from the map that contains the given key, or null if no such class exists.", "reason": "This method is part of the Domain Layer as it deals with domain logic related to classes and their inheritance.", "howToUse": "Call this method with a map containing classes as keys and objects as values, along with the class you want to find in the map.", "howItWorks": "The method retrieves all subclasses or interfaces of the given key using the `getInheritance` method. It then iterates through these classes and checks if they exist in the map. The first class found is returned as the most specific class.", "assertions": {"preConditions": ["The map must contain at least one entry with a class as the key."], "postConditions": ["If the given key exists in the map, it will be returned. If not, null will be returned."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createPellet()", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "kind": "method", "sourceText": "/**\r\n * Creates a new pellet.\r\n *\r\n * @return The new pellet.\r\n */\r\npublic nl.tudelft.jpacman.level.Pellet createPellet() {\r\n    return new nl.tudelft.jpacman.level.Pellet(nl.tudelft.jpacman.level.LevelFactory.PELLET_VALUE, this.sprites.getPelletSprite());\r\n}", "docComment": "Creates a new pellet.\r\n\r\n@return The new pellet.\r\n", "metaSrc": "source code", "description": "Creates a new Pellet instance with a specific value and sprite.", "returns": "A new Pellet object representing a pellet in the game.", "reason": "The method is part of the Domain Layer as it deals with creating domain objects (Pellets) that represent entities in the game world.", "howToUse": "Call this method to create a new Pellet instance for use in the game level.", "howItWorks": "The method initializes a new Pellet object by setting its value and sprite. The sprite is loaded from a resource file using the `getPelletSprite()` method, which caches it if necessary.", "assertions": {"preConditions": [], "postConditions": ["A new Pellet instance is created with the specified value and sprite."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The y-coordinate where the sprite should be drawn."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "withinBorders(int,int)", "qualifiedName": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "kind": "method", "sourceText": "/**\r\n * Determines whether the given <code>x,y</code> position is on this board.\r\n *\r\n * @param x\r\n * \t\tThe <code>x</code> position (row) to test.\r\n * @param y\r\n * \t\tThe <code>y</code> position (column) to test.\r\n * @return <code>true</code> iff the position is on this board.\r\n */\r\npublic boolean withinBorders(int x, int y) {\r\n    return (((x >= 0) && (x < this.getWidth())) && (y >= 0)) && (y < this.getHeight());\r\n}", "docComment": "Determines whether the given <code>x,y</code> position is on this board.\r\n\r\n@param x\r\n\t\tThe <code>x</code> position (row) to test.\r\n@param y\r\n\t\tThe <code>y</code> position (column) to test.\r\n@return <code>true</code> iff the position is on this board.\r\n", "metaSrc": "source code", "description": "Checks if given coordinates are within the bounds of the board.", "returns": "A boolean indicating whether the coordinates are within the board's boundaries.", "reason": "This method is essential for ensuring that game entities do not move outside the playable area of the board, maintaining the integrity and rules of the Pacman game.", "howToUse": "Call this method with the x and y coordinates of a potential position to check if it is within the board's dimensions.", "howItWorks": "The method checks if both the x-coordinate is greater than or equal to zero, less than the width of the board, and the y-coordinate is greater than or equal to zero, less than the height of the board. If all conditions are met, it returns true; otherwise, false.", "preConditions": ["x must be an integer representing a valid column index on the board.", "y must be an integer representing a valid row index on the board."], "postConditions": ["The method should return true if the coordinates are within the board's boundaries, and false otherwise."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "nextAiMove()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "kind": "method", "sourceText": "/**\r\n * {@inheritDoc }\r\n *\r\n * <p>\r\n * When the ghosts are not patrolling in their home corners (Blinky:\r\n * top-right, Pinky: top-left, Inky: bottom-right, Clyde: bottom-left),\r\n * Blinky will attempt to shorten the distance between Pac-Man and himself.\r\n * If he has to choose between shortening the horizontal or vertical\r\n * distance, he will choose to shorten whichever is greatest. For example,\r\n * if Pac-Man is four grid spaces to the left, and seven grid spaces above\r\n * Blinky, he'll try to move up towards Pac-Man before he moves to the left.\r\n * </p>\r\n */\r\n@java.lang.Override\r\npublic java.util.Optional<nl.tudelft.jpacman.board.Direction> nextAiMove() {\r\n    assert this.hasSquare();\r\n    // TODO Blinky should patrol his corner every once in a while\r\n    // TODO Implement his actual behaviour instead of simply chasing.\r\n    nl.tudelft.jpacman.board.Unit nearest = nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(nl.tudelft.jpacman.level.Player.class, this.getSquare());\r\n    if (nearest == null) {\r\n        return java.util.Optional.empty();\r\n    }\r\n    assert nearest.hasSquare();\r\n    nl.tudelft.jpacman.board.Square target = nearest.getSquare();\r\n    java.util.List<nl.tudelft.jpacman.board.Direction> path = nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(this.getSquare(), target, this);\r\n    if ((path != null) && (!path.isEmpty())) {\r\n        return java.util.Optional.ofNullable(path.get(0));\r\n    }\r\n    return java.util.Optional.empty();\r\n}", "docComment": "{@inheritDoc }\r\n\r\n<p>\r\nWhen the ghosts are not patrolling in their home corners (Blinky:\r\ntop-right, Pinky: top-left, Inky: bottom-right, Clyde: bottom-left),\r\nBlinky will attempt to shorten the distance between Pac-Man and himself.\r\nIf he has to choose between shortening the horizontal or vertical\r\ndistance, he will choose to shorten whichever is greatest. For example,\r\nif Pac-Man is four grid spaces to the left, and seven grid spaces above\r\nBlinky, he'll try to move up towards Pac-Man before he moves to the left.\r\n</p>\r\n", "metaSrc": "source code", "description": "Determines the next move for Blinky, the ghost in Pac-Man, based on finding the nearest player and calculating the shortest path to them.", "returns": "Optional<Direction>", "reason": "The method implements the AI logic for Blinky's movement in the game of Pac-Man.", "howToUse": "Call nextAiMove() to get the next direction for Blinky to move towards the nearest player.", "howItWorks": "1. Check if Blinky has a square assigned to it.\n2. Find the nearest player on the board from Blinky's current position.\n3. Calculate the shortest path from Blinky's current position to the player's position.\n4. Return the first direction in the calculated path or an empty Optional if no path is found.", "assertions": {"preConditions": ["Blinky has a square assigned to it"], "postConditions": ["Returns an Optional containing the next direction for Blinky, or an empty Optional if no path can be found"]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "kind": "method", "sourceText": "/**\r\n * Adds a two-way collision interaction to this collection, i.e. the\r\n * collision handler will be used for both C1 versus C2 and C2 versus C1.\r\n *\r\n * @param <C1>\r\n * \t\tThe collider type.\r\n * @param <C2>\r\n * \t\tThe collidee (unit that was moved into) type.\r\n * @param collider\r\n * \t\tThe collider type.\r\n * @param collidee\r\n * \t\tThe collidee type.\r\n * @param handler\r\n * \t\tThe handler that handles the collision.\r\n */\r\npublic <C1 extends nl.tudelft.jpacman.board.Unit, C2 extends nl.tudelft.jpacman.board.Unit> void onCollision(java.lang.Class<C1> collider, java.lang.Class<C2> collidee, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<C1, C2> handler) {\r\n    this.onCollision(collider, collidee, true, handler);\r\n}", "docComment": "Adds a two-way collision interaction to this collection, i.e. the\r\ncollision handler will be used for both C1 versus C2 and C2 versus C1.\r\n\r\n@param <C1>\r\n\t\tThe collider type.\r\n@param <C2>\r\n\t\tThe collidee (unit that was moved into) type.\r\n@param collider\r\n\t\tThe collider type.\r\n@param collidee\r\n\t\tThe collidee type.\r\n@param handler\r\n\t\tThe handler that handles the collision.\r\n", "metaSrc": "source code", "description": "Adds collision handlers for unit pairs and their inverses, allowing for bidirectional collision detection.", "returns": "void", "reason": "This method provides a convenient way to add bidirectional collision handlers for unit pairs in the game.", "howToUse": "Call this method with the collider and collidee classes, along with a collision handler instance. The handler will be used to handle collisions between instances of these classes.", "howItWorks": "The method calls another `onCollision` method with the same parameters but sets the `symetric` parameter to true, enabling bidirectional collision detection.", "assertions": {"preConditions": ["collider and collidee are valid class references", "handler is a non-null instance of CollisionHandler"], "postConditions": ["collision handlers for the specified unit pairs are added to the map"]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board", "labels": ["Structure"], "properties": {"docComment": "A top-down view of a matrix of {@link Square}s.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Board", "qualifiedName": "nl.tudelft.jpacman.board.Board", "kind": "class", "metaSrc": "source code", "description": "The Board class is responsible for managing the game board, including its dimensions, squares, and ensuring that all squares are non-null. It provides methods to retrieve square information and check if coordinates are within bounds.", "layer": "Domain Layer", "roleStereotype": "Structurer", "keywords": ["board", "game", "squares", "coordinates", "invariants"], "dependencyProfile": "inbound"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).4", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher", "labels": ["Structure"], "properties": {"docComment": "Creates and launches the JPacMan UI.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Launcher", "qualifiedName": "nl.tudelft.jpacman.Launcher", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for managing game-related operations, including parsing maps, creating levels, and handling player movements.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["game management", "level creation", "player movement"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.game", "labels": ["Variable"], "properties": {"sourceText": "private nl.tudelft.jpacman.game.Game game;", "visibility": "private", "simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.Launcher.game", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "occupant", "qualifiedName": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit to be added to the square."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(java.util.Map)", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)", "kind": "constructor", "sourceText": "/**\r\n * Create a new key listener based on a set of keyCode-action pairs.\r\n *\r\n * @param keyMappings\r\n * \t\tThe mappings of keyCode to action.\r\n */\r\nPacKeyListener(java.util.Map<java.lang.Integer, nl.tudelft.jpacman.ui.Action> keyMappings) {\r\n    super();\r\n    assert keyMappings != null;\r\n    this.mappings = keyMappings;\r\n}", "docComment": "Create a new key listener based on a set of keyCode-action pairs.\r\n\r\n@param keyMappings\r\n\t\tThe mappings of keyCode to action.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getParent()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getParent()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getParent()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The parent node, or <code>null</code> if this node is a root\r\nnode.\r\n */\r\nprivate nl.tudelft.jpacman.npc.ghost.Navigation.Node getParent() {\r\n    return this.parent;\r\n}", "docComment": "\r\n@return The parent node, or <code>null</code> if this node is a root\r\nnode.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "split(int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite split(int x, int y, int width, int height) {\r\n    if (this.withinImage(x, y) && this.withinImage((x + width) - 1, (y + height) - 1)) {\r\n        java.awt.image.BufferedImage newImage = this.newImage(width, height);\r\n        newImage.createGraphics().drawImage(this.image, 0, 0, width, height, x, y, x + width, y + height, null);\r\n        return new nl.tudelft.jpacman.sprite.ImageSprite(newImage);\r\n    }\r\n    return new nl.tudelft.jpacman.sprite.EmptySprite();\r\n}", "docComment": "", "metaSrc": "source code", "description": "Splits an ImageSprite into a new ImageSprite based on specified coordinates and dimensions.", "returns": "A new ImageSprite containing the specified sub-image.", "reason": "This method provides a way to extract a portion of an existing image, which is useful for creating smaller sprites or animations within a larger sprite sheet.", "howToUse": "Call this method on an instance of ImageSprite with the desired coordinates and dimensions. The returned object will be a new ImageSprite containing only the specified sub-image.", "howItWorks": "The method first checks if the given coordinates are within the bounds of the original image using the `withinImage` method. If they are, it creates a new BufferedImage with the specified width and height. It then uses the Graphics2D object to draw the original image onto this new BufferedImage, specifying the source rectangle (the sub-image) and the destination rectangle (where to place the sub-image). Finally, it returns a new ImageSprite containing the newly created BufferedImage.", "preConditions": ["The provided coordinates must be within the bounds of the original image."], "postConditions": ["A new ImageSprite is returned containing the specified sub-image."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).0", "labels": ["Variable"], "properties": {"simpleName": "clazz", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The type to search for."}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "labels": ["Variable"], "properties": {"simpleName": "level", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The level of the game."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "labels": ["Variable"], "properties": {"simpleName": "handler", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The collision handler to be added for the specified pair of units."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The destination x coordinate to start drawing."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).1", "labels": ["Variable"], "properties": {"simpleName": "graphics", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The graphics context to draw on."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "labels": ["Variable"], "properties": {"simpleName": "collidee", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The class representing the unit that is being collided with by the collider."}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.getSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSprite()", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Wall.getSprite()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite getSprite() {\r\n    return this.background;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "kind": "method", "sourceText": "/**\r\n * Creates a game for a single level with one player.\r\n *\r\n * @param level\r\n * \t\tThe level to create a game for.\r\n * @param pointCalculator\r\n * \t\tThe way to calculate points upon collisions.\r\n * @return A new single player game.\r\n */\r\npublic nl.tudelft.jpacman.game.Game createSinglePlayerGame(nl.tudelft.jpacman.level.Level level, nl.tudelft.jpacman.points.PointCalculator pointCalculator) {\r\n    return new nl.tudelft.jpacman.game.SinglePlayerGame(this.playerFactory.createPacMan(), level, pointCalculator);\r\n}", "docComment": "Creates a game for a single level with one player.\r\n\r\n@param level\r\n\t\tThe level to create a game for.\r\n@param pointCalculator\r\n\t\tThe way to calculate points upon collisions.\r\n@return A new single player game.\r\n", "metaSrc": "source code", "description": "Creates a new single-player game instance using the provided level and point calculator.", "returns": "A new SinglePlayerGame instance.", "reason": "This method is part of the Service Layer as it orchestrates the creation of a game by combining multiple components (PacMan, level, and point calculator) into a single game entity.", "howToUse": "To use this method, you need to provide an instance of Level and PointCalculator. The method will return a new SinglePlayerGame object that can be used to start the game.", "howItWorks": "The method creates a new SinglePlayerGame by calling the createPacMan() method from the playerFactory to get a PacMan instance, then initializes the game with the provided level and point calculator.", "assertions": {"preConditions": ["A valid Level object must be provided."], "postConditions": ["The returned SinglePlayerGame object should have a PacMan player, the specified level, and the given point calculator."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).3", "labels": ["Variable"], "properties": {"simpleName": "node", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The current navigation node."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.spriteMap", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * We only need to load images once, so we keep track\r\n * of them in a hash map.\r\n */\r\nprivate final java.util.Map<java.lang.String, nl.tudelft.jpacman.sprite.Sprite> spriteMap;", "visibility": "private", "simpleName": "spriteMap", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.spriteMap", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.lastUpdate", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The {@link System#currentTimeMillis()} stamp of the last update.\r\n */\r\nprivate long lastUpdate;", "visibility": "private", "simpleName": "lastUpdate", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.lastUpdate", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite).0", "labels": ["Variable"], "properties": {"simpleName": "sprite", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The background sprite for the wall."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The y-coordinate of the top-left corner of the region to split."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "isAnyPlayerAlive()", "qualifiedName": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "kind": "method", "sourceText": "/**\r\n * Returns <code>true</code> iff at least one of the players in this level\r\n * is alive.\r\n *\r\n * @return <code>true</code> if at least one of the registered players is\r\nalive.\r\n */\r\npublic boolean isAnyPlayerAlive() {\r\n    for (nl.tudelft.jpacman.level.Player player : this.players) {\r\n        if (player.isAlive()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}", "docComment": "Returns <code>true</code> iff at least one of the players in this level\r\nis alive.\r\n\r\n@return <code>true</code> if at least one of the registered players is\r\nalive.\r\n", "metaSrc": "source code", "description": "Checks if any player in the level is alive.", "returns": "Boolean indicating whether at least one player is alive.", "reason": "The method iterates through all players and checks their health status to determine if there are any living players.", "howToUse": "Call `isAnyPlayerAlive()` on a `Level` object to check for the presence of any active players.", "howItWorks": "The method uses an enhanced for loop to iterate over each player in the level's list. It checks if each player is alive using the `isAlive()` method and returns true as soon as it finds a living player. If no living players are found, it returns false.", "preConditions": ["A valid `Level` object exists with at least one player."], "postConditions": ["The method returns a boolean value indicating whether any player is alive in the level."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "labels": ["Variable"], "properties": {"simpleName": "collider", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The class representing the unit that can collide with other units."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.start()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "start()", "qualifiedName": "nl.tudelft.jpacman.level.Level.start()", "kind": "method", "sourceText": "/**\r\n * Starts or resumes this level, allowing movement and (re)starting the\r\n * NPCs.\r\n */\r\npublic void start() {\r\n    synchronized(this.startStopLock) {\r\n        if (this.isInProgress()) {\r\n            return;\r\n        }\r\n        this.startNPCs();\r\n        this.inProgress = true;\r\n        this.updateObservers();\r\n    }\r\n}", "docComment": "Starts or resumes this level, allowing movement and (re)starting the\r\nNPCs.\r\n", "metaSrc": "source code", "description": "Starts the level by initializing NPCs, marking it as in progress, and updating observers.", "returns": "", "reason": "The method manages the initialization of a game level, ensuring that only one instance starts at a time to avoid conflicts.", "howToUse": "Call `start()` on an instance of `Level` to begin the game.", "howItWorks": "Synchronizes access to the startStopLock to prevent concurrent starts. Checks if the level is already in progress, then starts NPCs and marks the level as active. Finally, updates observers based on the level's state.", "assertions": {"preConditions": ["The method should not be called while the level is already in progress.", "Observers should be updated to reflect the start of the game."], "postConditions": ["The level should be marked as in progress.", "Observers should be notified about the start of the game."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String).0", "labels": ["Variable"], "properties": {"simpleName": "resource", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The path to the resource file."}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collisions", "labels": ["Variable"], "properties": {"sourceText": "private final nl.tudelft.jpacman.level.CollisionMap collisions = this.defaultCollisions();", "visibility": "private", "simpleName": "collisions", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collisions", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).2", "labels": ["Variable"], "properties": {"simpleName": "delay", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The delay between each frame in milliseconds."}}}, {"data": {"id": "int", "labels": ["Primitive"], "properties": {"simpleName": "int", "qualifiedName": "int", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "kind": "method", "sourceText": "private nl.tudelft.jpacman.board.Square followPath(java.util.List<nl.tudelft.jpacman.board.Direction> directions, nl.tudelft.jpacman.board.Square start) {\r\n    nl.tudelft.jpacman.board.Square destination = start;\r\n    for (nl.tudelft.jpacman.board.Direction d : directions) {\r\n        destination = destination.getSquareAt(d);\r\n    }\r\n    return destination;\r\n}", "docComment": "", "metaSrc": "source code", "description": "Follows a sequence of directions to find the destination square on the game board.", "returns": "The destination square after following all specified directions.", "reason": "This method is part of the domain layer as it deals with game logic and board operations, specifically moving a character (Inky) along a predefined path on the game board.", "howToUse": "Call this method with a list of directions and the starting square to get the final destination square.", "howItWorks": "The method iterates over each direction in the list, updating the current square to the next one by calling `getSquareAt(d)`, which returns the adjacent square in the specified direction.", "assertions": {"preConditions": ["directions is not null and contains at least one direction", "start is not null"], "postConditions": ["destination is not null and represents a valid square on the game board"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.getSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSprite()", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Ground.getSprite()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite getSprite() {\r\n    return this.background;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost", "labels": ["Container"], "properties": {"simpleName": "ghost", "qualifiedName": "nl.tudelft.jpacman.npc.ghost", "kind": "package", "metaSrc": "source code", "description": "Manages navigation and pathfinding for ghosts in the Pac-Man game, providing utility to navigate on squares.", "layer": "Service Layer", "title": "Navigation", "keywords": ["navigation", "pathfinding", "ghosts", "pac-man"]}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).4", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code", "description": "The height of the sprite to draw."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "kind": "method", "sourceText": "/**\r\n * Adds a key listener to the UI.\r\n *\r\n * @param keyCode\r\n * \t\tThe key code of the key as used by {@link java.awt.event.KeyEvent}.\r\n * @param action\r\n * \t\tThe action to perform when the key is pressed.\r\n * @return The builder.\r\n */\r\npublic nl.tudelft.jpacman.ui.PacManUiBuilder addKey(java.lang.Integer keyCode, nl.tudelft.jpacman.ui.Action action) {\r\n    assert keyCode != null;\r\n    assert action != null;\r\n    this.keyMappings.put(keyCode, action);\r\n    return this;\r\n}", "docComment": "Adds a key listener to the UI.\r\n\r\n@param keyCode\r\n\t\tThe key code of the key as used by {@link java.awt.event.KeyEvent}.\r\n@param action\r\n\t\tThe action to perform when the key is pressed.\r\n@return The builder.\r\n", "metaSrc": "source code", "description": "Adds a key mapping to the PacMan UI builder, associating a keycode with an action.", "returns": "This method returns the current instance of PacManUiBuilder.", "reason": "This method provides a way to configure key bindings for the PacMan UI, allowing users to interact with the game using keyboard shortcuts.", "howToUse": "To use this method, create an instance of PacManUiBuilder and call addKey() with the desired keycode and action. This will associate the keycode with the specified action in the builder.", "howItWorks": "The method first checks if the provided keyCode and action are not null. It then adds a mapping from the keyCode to the action in the keyMappings map of the PacManUiBuilder instance. Finally, it returns the current instance of PacManUiBuilder.", "assertions": {"preConditions": ["The keyCode must be non-null."], "postConditions": ["The keyMappings map will contain a mapping from the provided keyCode to the provided action."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream).0", "labels": ["Variable"], "properties": {"simpleName": "source", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "ghost", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The ghost involved in the collision."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.image", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The sprite of this unit.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.Sprite image;", "visibility": "private", "simpleName": "image", "qualifiedName": "nl.tudelft.jpacman.level.Pellet.image", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "/**\r\n * Links this square to a neighbour in the given direction. Note that this\r\n * is a one-way connection.\r\n *\r\n * @param neighbour\r\n * \t\tThe neighbour to link.\r\n * @param direction\r\n * \t\tThe direction the new neighbour is in, as seen from this cell.\r\n */\r\npublic void link(nl.tudelft.jpacman.board.Square neighbour, nl.tudelft.jpacman.board.Direction direction) {\r\n    this.neighbours.put(direction, neighbour);\r\n    assert this.invariant();\r\n}", "docComment": "Links this square to a neighbour in the given direction. Note that this\r\nis a one-way connection.\r\n\r\n@param neighbour\r\n\t\tThe neighbour to link.\r\n@param direction\r\n\t\tThe direction the new neighbour is in, as seen from this cell.\r\n", "metaSrc": "source code", "description": "Adds a neighbour to the current square and ensures the invariant is maintained.", "returns": "", "reason": "This method manages the connections between squares, ensuring that each square knows its neighbors and maintaining the integrity of the board.", "howToUse": "Call this method with a neighbor square and the direction it is connected to. This will update the current square's list of neighbors and ensure the invariant is checked.", "howItWorks": "The method adds the given neighbor to the map of neighbors for the current square, using the provided direction as the key. It then checks if the invariant holds true after this operation.", "assertions": {"preConditions": ["neighbour is not null", "direction is a valid Direction enum value"], "postConditions": ["currentSquare.neighbours contains neighbour at direction", "invariant of Square class is maintained"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.background", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The background for this square.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.Sprite background;", "visibility": "private", "simpleName": "background", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Wall.background", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.awt.Image)", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new sprite from an image.\r\n *\r\n * @param img\r\n * \t\tThe image to create a sprite from.\r\n */\r\npublic ImageSprite(java.awt.Image img) {\r\n    super();\r\n    this.image = img;\r\n}", "docComment": "Creates a new sprite from an image.\r\n\r\n@param img\r\n\t\tThe image to create a sprite from.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.neighbours", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The collection of squares adjacent to this square.\r\n */\r\nprivate final java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.board.Square> neighbours;", "visibility": "private", "simpleName": "neighbours", "qualifiedName": "nl.tudelft.jpacman.board.Square.neighbours", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.main(java.lang.String[]).0", "labels": ["Variable"], "properties": {"simpleName": "args", "qualifiedName": "nl.tudelft.jpacman.Launcher.main(java.lang.String[]).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.invariant()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "invariant()", "qualifiedName": "nl.tudelft.jpacman.board.Board.invariant()", "kind": "method", "sourceText": "/**\r\n * Whatever happens, the squares on the board can't be null.\r\n *\r\n * @return false if any square on the board is null.\r\n */\r\nprotected final boolean invariant() {\r\n    for (nl.tudelft.jpacman.board.Square[] row : this.board) {\r\n        for (nl.tudelft.jpacman.board.Square square : row) {\r\n            if (square == null) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}", "docComment": "Whatever happens, the squares on the board can't be null.\r\n\r\n@return false if any square on the board is null.\r\n", "metaSrc": "source code", "description": "Checks if all squares in the board are non-null.", "returns": "True if all squares are non-null, false otherwise.", "reason": "Ensures the integrity of the board data structure by verifying that no square is null.", "howToUse": "Call this method to verify the state of the board before performing operations that depend on its contents.", "howItWorks": "Iterates over each row and each square in the board, checking if any square is null. Returns false as soon as a null square is found.", "assertions": {"preConditions": ["The board object exists and has been initialized."], "postConditions": ["Returns true if all squares are non-null; otherwise returns false."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "private void ghostColliding(nl.tudelft.jpacman.npc.Ghost ghost, nl.tudelft.jpacman.board.Unit collidedOn) {\r\n    if (collidedOn instanceof nl.tudelft.jpacman.level.Player) {\r\n        this.playerVersusGhost(((nl.tudelft.jpacman.level.Player) (collidedOn)), ghost);\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Updates player points based on collision with a ghost and sets the player as dead.", "returns": "", "reason": "This method handles the collision between a ghost and a player, updating the game state accordingly.", "howToUse": "Call this method when a ghost collides with a player. It will update the player's points and set them as dead.", "howItWorks": "The method checks if the collided unit is a player. If so, it calls the `playerVersusGhost` method to handle the collision logic.", "assertions": {"preConditions": ["A ghost object must be provided."], "postConditions": ["If the collidedOn unit is a player, the player's points are updated and they are set as dead."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.direction", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The direction for this node, which is <code>null</code> for the root\r\n * node.\r\n */\r\nprivate final nl.tudelft.jpacman.board.Direction direction;", "visibility": "private", "simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.direction", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).2", "labels": ["Variable"], "properties": {"simpleName": "keyMappings", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "A map of key codes to corresponding actions."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(nl.tudelft.jpacman.board.Square[][])", "qualifiedName": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "kind": "constructor", "sourceText": "/**\r\n * Creates a new board.\r\n *\r\n * @param grid\r\n * \t\tThe grid of squares with grid[x][y] being the square at column\r\n * \t\tx, row y.\r\n */\r\n@java.lang.SuppressWarnings(\"PMD.ArrayIsStoredDirectly\")\r\nBoard(nl.tudelft.jpacman.board.Square[][] grid) {\r\n    super();\r\n    assert grid != null;\r\n    this.board = grid;\r\n    assert this.invariant() : \"Initial grid cannot contain null squares\";\r\n}", "docComment": "Creates a new board.\r\n\r\n@param grid\r\n\t\tThe grid of squares with grid[x][y] being the square at column\r\n\t\tx, row y.\r\n", "metaSrc": "source code", "description": "Initializes the board with a given grid and checks for null squares.", "returns": "The newly created Board instance.", "reason": "This method initializes the board with a given grid and ensures that all squares are non-null, which is crucial for the proper functioning of the Pacman game.", "howToUse": "Create an instance of Board by passing a 2D array of Square objects to the constructor.", "howItWorks": "The constructor checks if the grid is not null and then assigns it to the board field. It also asserts that all squares in the grid are non-null, throwing an assertion error if any square is null.", "assertions": {"preConditions": ["grid != null"], "postConditions": ["this.board == grid", "all squares in this.board are non-null"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).0", "labels": ["Variable"], "properties": {"simpleName": "traveller", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that is navigating."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The width of the sub-image to be split."}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.INKY", "labels": ["Variable"], "properties": {"sourceText": "private static final int INKY = 1;", "visibility": "private", "simpleName": "INKY", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.INKY", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "unit", "qualifiedName": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "nextAiMove()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "kind": "method", "sourceText": "/**\r\n * {@inheritDoc }\r\n *\r\n * <p>\r\n * Inky has the most complicated AI of all. Inky considers two things: Blinky's\r\n * location, and the location two grid spaces ahead of Pac-Man. Inky\r\n * draws a line from Blinky to the spot that is two squares in front of\r\n * Pac-Man and extends that line twice as far. Therefore, if Inky is\r\n * alongside Blinky when they are behind Pac-Man, Inky will usually\r\n * follow Blinky the whole time. But if Inky is in front of Pac-Man when\r\n * Blinky is far behind him, Inky tends to want to move away from Pac-Man\r\n * (in reality, to a point very far ahead of Pac-Man). Inky is affected\r\n * by a similar targeting bug that affects Speedy. When Pac-Man is moving or\r\n * facing up, the spot Inky uses to draw the line is two squares above\r\n * and left of Pac-Man.\r\n * </p>\r\n *\r\n * <p>\r\n * <b>Implementation:</b>\r\n * To actually implement this in jpacman we have the following approximation:\r\n * first determine the square of Blinky (A) and the square 2\r\n * squares away from Pac-Man (B). Then determine the shortest path from A to\r\n * B regardless of terrain and walk that same path from B. This is the\r\n * destination.\r\n * </p>\r\n */\r\n@java.lang.Override\r\npublic java.util.Optional<nl.tudelft.jpacman.board.Direction> nextAiMove() {\r\n    assert this.hasSquare();\r\n    nl.tudelft.jpacman.board.Unit blinky = nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(nl.tudelft.jpacman.npc.ghost.Blinky.class, this.getSquare());\r\n    nl.tudelft.jpacman.board.Unit player = nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(nl.tudelft.jpacman.level.Player.class, this.getSquare());\r\n    if ((blinky == null) || (player == null)) {\r\n        return java.util.Optional.empty();\r\n    }\r\n    assert player.hasSquare();\r\n    nl.tudelft.jpacman.board.Square playerDestination = player.squaresAheadOf(nl.tudelft.jpacman.npc.ghost.Inky.SQUARES_AHEAD);\r\n    java.util.List<nl.tudelft.jpacman.board.Direction> firstHalf = nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(blinky.getSquare(), playerDestination, null);\r\n    if (firstHalf == null) {\r\n        return java.util.Optional.empty();\r\n    }\r\n    nl.tudelft.jpacman.board.Square destination = this.followPath(firstHalf, playerDestination);\r\n    java.util.List<nl.tudelft.jpacman.board.Direction> path = nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(this.getSquare(), destination, this);\r\n    if ((path != null) && (!path.isEmpty())) {\r\n        return java.util.Optional.ofNullable(path.get(0));\r\n    }\r\n    return java.util.Optional.empty();\r\n}", "docComment": "{@inheritDoc }\r\n\r\n<p>\r\nInky has the most complicated AI of all. Inky considers two things: Blinky's\r\nlocation, and the location two grid spaces ahead of Pac-Man. Inky\r\ndraws a line from Blinky to the spot that is two squares in front of\r\nPac-Man and extends that line twice as far. Therefore, if Inky is\r\nalongside Blinky when they are behind Pac-Man, Inky will usually\r\nfollow Blinky the whole time. But if Inky is in front of Pac-Man when\r\nBlinky is far behind him, Inky tends to want to move away from Pac-Man\r\n(in reality, to a point very far ahead of Pac-Man). Inky is affected\r\nby a similar targeting bug that affects Speedy. When Pac-Man is moving or\r\nfacing up, the spot Inky uses to draw the line is two squares above\r\nand left of Pac-Man.\r\n</p>\r\n\r\n<p>\r\n<b>Implementation:</b>\r\nTo actually implement this in jpacman we have the following approximation:\r\nfirst determine the square of Blinky (A) and the square 2\r\nsquares away from Pac-Man (B). Then determine the shortest path from A to\r\nB regardless of terrain and walk that same path from B. This is the\r\ndestination.\r\n</p>\r\n", "metaSrc": "source code", "description": "Calculates the next move for Inky based on the shortest path to Blinky and then to the player, ensuring it avoids obstacles.", "returns": "A java.util.Optional<nl.tudelft.jpacman.board.Direction> representing the next move or an empty Optional if no valid move can be determined.", "reason": "Inky's AI logic involves navigating towards Blinky and then to the player, ensuring it avoids obstacles by following calculated paths.", "howToUse": "Call this method on an instance of Inky to get its next move based on the game state.", "howItWorks": "The method first finds the nearest Blinky and player squares. It calculates the shortest path from Inky to both, then follows the path to Blinky and finally to the player, ensuring it avoids obstacles by following calculated paths.", "assertions": {"preConditions": ["this.hasSquare()"], "postConditions": ["The method returns a valid Direction or an empty Optional if no valid move can be determined."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Collides the two units and handles the result of the collision, which may\r\n * be nothing at all.\r\n *\r\n * @param <C1>\r\n * \t\tThe collider type.\r\n * @param <C2>\r\n * \t\tThe collidee (unit that was moved into) type.\r\n * @param collider\r\n * \t\tThe unit that causes the collision by occupying a square with\r\n * \t\tanother unit already on it.\r\n * @param collidee\r\n * \t\tThe unit that is already on the square that is being invaded.\r\n */\r\n<C1 extends nl.tudelft.jpacman.board.Unit, C2 extends nl.tudelft.jpacman.board.Unit> void collide(C1 collider, C2 collidee);", "docComment": "Collides the two units and handles the result of the collision, which may\r\nbe nothing at all.\r\n\r\n@param <C1>\r\n\t\tThe collider type.\r\n@param <C2>\r\n\t\tThe collidee (unit that was moved into) type.\r\n@param collider\r\n\t\tThe unit that causes the collision by occupying a square with\r\n\t\tanother unit already on it.\r\n@param collidee\r\n\t\tThe unit that is already on the square that is being invaded.\r\n", "metaSrc": "source code", "description": "Handles collisions between two units in the game board.", "returns": "", "reason": "This method is part of the game logic layer, as it handles interactions between different units in the game.", "howToUse": "Implement this method to define how two units should interact when they collide. This could include changing their states, removing them from the board, or applying special effects.", "howItWorks": "The method takes two units as parameters and checks if they are colliding based on their positions on the game board. Depending on the collision type, it performs the appropriate action.", "assertions": {"preConditions": ["Both collider and collidee must be valid instances of Unit."], "postConditions": ["The behavior of the units should change based on the collision."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "newImage(int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "kind": "method", "sourceText": "/**\r\n * Creates a new, empty image of the given width and height. Its\r\n * transparency will be a bitmask, so no try ARGB image.\r\n *\r\n * @param width\r\n * \t\tThe width of the new image.\r\n * @param height\r\n * \t\tThe height of the new image.\r\n * @return The new, empty image.\r\n */\r\nprivate java.awt.image.BufferedImage newImage(int width, int height) {\r\n    java.awt.GraphicsConfiguration gc = java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration();\r\n    return gc.createCompatibleImage(width, height, java.awt.Transparency.BITMASK);\r\n}", "docComment": "Creates a new, empty image of the given width and height. Its\r\ntransparency will be a bitmask, so no try ARGB image.\r\n\r\n@param width\r\n\t\tThe width of the new image.\r\n@param height\r\n\t\tThe height of the new image.\r\n@return The new, empty image.\r\n", "metaSrc": "source code", "description": "Creates a new BufferedImage with the specified width and height using the default screen device's configuration.", "returns": "A java.awt.image.BufferedImage object", "reason": "This method is used to create an image that can be used for rendering in the game, which falls under the domain layer as it deals with creating visual elements for the game.", "howToUse": "Call this method with the desired width and height to get a BufferedImage object.", "howItWorks": "The method uses the GraphicsEnvironment to get the default screen device's configuration and then creates a compatible image using that configuration.", "preConditions": [], "postConditions": ["A BufferedImage object is returned"], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(java.util.Map,javax.swing.JFrame)", "qualifiedName": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "kind": "constructor", "sourceText": "/**\r\n * Create a new button panel with a button for every action.\r\n *\r\n * @param buttons\r\n * \t\tThe map of caption - action for each button.\r\n * @param parent\r\n * \t\tThe parent frame, used to return window focus.\r\n */\r\nButtonPanel(final java.util.Map<java.lang.String, nl.tudelft.jpacman.ui.Action> buttons, final javax.swing.JFrame parent) {\r\n    super();\r\n    assert buttons != null;\r\n    assert parent != null;\r\n    for (final java.lang.String caption : buttons.keySet()) {\r\n        javax.swing.JButton button = new javax.swing.JButton(caption);\r\n        button.addActionListener((java.awt.event.ActionEvent e) -> {\r\n            buttons.get(caption).doAction();\r\n            parent.requestFocusInWindow();\r\n        });\r\n        this.add(button);\r\n    }\r\n}", "docComment": "Create a new button panel with a button for every action.\r\n\r\n@param buttons\r\n\t\tThe map of caption - action for each button.\r\n@param parent\r\n\t\tThe parent frame, used to return window focus.\r\n", "metaSrc": "source code", "description": "Creates a panel with buttons that, when clicked, perform actions in the Pacman game and focus the parent JFrame.", "returns": "None", "reason": "This method manages the user interface by creating buttons and handling their actions, which are part of the Presentation Layer.", "howToUse": "Create an instance of ButtonPanel with a map of button captions to action objects and a parent JFrame. The buttons will be added to the panel and will perform the corresponding actions when clicked.", "howItWorks": "The method iterates over the keys in the buttons map, creates a JButton for each caption, adds an ActionListener that performs the associated action and focuses the parent JFrame, and then adds the button to the panel.", "assertions": {"preConditions": ["buttons is not null", "parent is not null"], "postConditions": ["All buttons are added to the panel", "Each button's ActionListener performs the corresponding action and focuses the parent JFrame"]}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).0", "labels": ["Variable"], "properties": {"simpleName": "board", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The board on which the level will be played."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.boardPanel", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The panel displaying the game.\r\n */\r\nprivate final nl.tudelft.jpacman.ui.BoardPanel boardPanel;", "visibility": "private", "simpleName": "boardPanel", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI.boardPanel", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.stopNPCs()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "stopNPCs()", "qualifiedName": "nl.tudelft.jpacman.level.Level.stopNPCs()", "kind": "method", "sourceText": "/**\r\n * Stops all NPC movement scheduling and interrupts any movements being\r\n * executed.\r\n */\r\nprivate void stopNPCs() {\r\n    for (java.util.Map.Entry<nl.tudelft.jpacman.npc.Ghost, java.util.concurrent.ScheduledExecutorService> entry : this.npcs.entrySet()) {\r\n        java.util.concurrent.ScheduledExecutorService schedule = entry.getValue();\r\n        assert schedule != null;\r\n        schedule.shutdownNow();\r\n    }\r\n}", "docComment": "Stops all NPC movement scheduling and interrupts any movements being\r\nexecuted.\r\n", "metaSrc": "source code", "description": "Stops all scheduled tasks for NPCs in the game level.", "returns": "", "reason": "The method is responsible for managing NPC behavior by stopping their scheduled tasks, ensuring that they do not continue to perform actions after the level has ended or been paused.", "howToUse": "Call this method when you want to stop all NPCs' activities in a game level.", "howItWorks": "Iterates over each NPC and its associated ScheduledExecutorService, shutting down the service to stop any ongoing tasks.", "assertions": {"preConditions": ["The Level object is initialized and contains valid NPC entries."], "postConditions": ["All scheduled tasks for NPCs are stopped, and no further actions will be performed by these NPCs."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getHeight()", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic int getHeight() {\r\n    assert this.currentSprite() != null;\r\n    return this.currentSprite().getHeight();\r\n}", "docComment": "", "metaSrc": "source code", "description": "Returns the height of the current sprite in an animated sequence.", "returns": "The height of the current sprite as an integer.", "reason": "This method provides a straightforward way to access the height of the current sprite, which is essential for rendering and positioning animations correctly.", "howToUse": "Call this method on an instance of AnimatedSprite to get its height.", "howItWorks": "The method first checks if the current sprite is not null. If it's not, it retrieves the height of the current sprite using the `getHeight()` method of the sprite object and returns that value.", "assertions": {"preConditions": ["this.currentSprite() != null"], "postConditions": ["The returned value is an integer representing the height of the current sprite."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "kind": "method", "sourceText": "/**\r\n * Returns a map of animated ghost sprites for all directions.\r\n *\r\n * @param color\r\n * \t\tThe colour of the ghost.\r\n * @return The Sprite for the ghost.\r\n */\r\npublic java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor color) {\r\n    assert color != null;\r\n    java.lang.String resource = (\"/sprite/ghost_\" + color.name().toLowerCase()) + \".png\";\r\n    return this.directionSprite(resource, nl.tudelft.jpacman.sprite.PacManSprites.GHOST_ANIMATION_FRAMES);\r\n}", "docComment": "Returns a map of animated ghost sprites for all directions.\r\n\r\n@param color\r\n\t\tThe colour of the ghost.\r\n@return The Sprite for the ghost.\r\n", "metaSrc": "source code", "description": "Returns animated sprites for each direction based on a base image and splits it into frames.", "returns": "A map from directions to animated sprites.", "reason": "This method provides a convenient way to retrieve animated sprite resources for different ghost colors, which is essential for rendering ghosts in the game.", "howToUse": "Call this method with a GhostColor enum value to get the corresponding animated sprite for that color. The returned map contains sprites for all four directions (up, down, left, right).", "howItWorks": "The method constructs a resource path based on the provided GhostColor and calls the directionSprite method to create animated sprites for each direction. It then returns a map with these sprites.", "assertions": {"preConditions": ["color is not null"], "postConditions": ["returns a non-null map of animated sprites"]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "labels": ["Structure"], "properties": {"docComment": "A task that moves an NPC and reschedules itself after it finished.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "NpcMoveTask", "qualifiedName": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for orchestrating the movement of NPCs in the game by determining their next move and scheduling it to repeat at a specified interval.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["NPC", "movement", "ScheduledExecutorService"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.isInProgress()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "isInProgress()", "qualifiedName": "nl.tudelft.jpacman.game.Game.isInProgress()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return <code>true</code> iff the game is started and in progress.\r\n */\r\npublic boolean isInProgress() {\r\n    return this.inProgress;\r\n}", "docComment": "\r\n@return <code>true</code> iff the game is started and in progress.\r\n", "metaSrc": "source code", "description": "Returns whether the game is currently in progress.", "returns": "Boolean indicating if the game is in progress.", "reason": "The method provides a simple interface to check the current state of the game, which is essential for managing game flow and user interactions.", "howToUse": "Call `isInProgress()` on an instance of `Game` to determine if the game is active.", "howItWorks": "The method simply returns the value stored in the `inProgress` field, which is a boolean indicating whether the game has started but not yet ended.", "preConditions": [], "postConditions": ["The returned value accurately reflects the current state of the game."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.serialVersionUID", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Default serialisation UID.\r\n */\r\nprivate static final long serialVersionUID = 1L;", "visibility": "private", "simpleName": "serialVersionUID", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI.serialVersionUID", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new node.\r\n *\r\n * @param direction\r\n * \t\tThe direction, which is <code>null</code> for the root\r\n * \t\tnode.\r\n * @param square\r\n * \t\tThe square.\r\n * @param parent\r\n * \t\tThe parent node, which is <code>null</code> for the root\r\n * \t\tnode.\r\n */\r\nNode(nl.tudelft.jpacman.board.Direction direction, nl.tudelft.jpacman.board.Square square, nl.tudelft.jpacman.npc.ghost.Navigation.Node parent) {\r\n    super();\r\n    this.direction = direction;\r\n    this.square = square;\r\n    this.parent = parent;\r\n}", "docComment": "Creates a new node.\r\n\r\n@param direction\r\n\t\tThe direction, which is <code>null</code> for the root\r\n\t\tnode.\r\n@param square\r\n\t\tThe square.\r\n@param parent\r\n\t\tThe parent node, which is <code>null</code> for the root\r\n\t\tnode.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.lang.String,java.lang.Throwable)", "qualifiedName": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)", "kind": "constructor", "sourceText": "/**\r\n * A configuration exception with a root cause and additional explanation.\r\n *\r\n * @param message\r\n * \t\tThe explanation.\r\n * @param cause\r\n * \t\tThe root cause.\r\n */\r\npublic PacmanConfigurationException(java.lang.String message, java.lang.Throwable cause) {\r\n    super(message, cause);\r\n}", "docComment": "A configuration exception with a root cause and additional explanation.\r\n\r\n@param message\r\n\t\tThe explanation.\r\n@param cause\r\n\t\tThe root cause.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).2", "labels": ["Variable"], "properties": {"simpleName": "window", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The size of the window in which to render the board."}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).2", "labels": ["Variable"], "properties": {"simpleName": "startPositions", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "A list of starting positions for the player and other entities on the board."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.SQUARES_AHEAD", "labels": ["Variable"], "properties": {"sourceText": "private static final int SQUARES_AHEAD = 2;", "visibility": "private", "simpleName": "SQUARES_AHEAD", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky.SQUARES_AHEAD", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "kind": "method", "sourceText": "/**\r\n * Method called whenever a player meets a ghost.\r\n * It can be used to update the player's points accordingly.\r\n *\r\n * @param player\r\n * \t\tThe player that will die.\r\n * @param ghost\r\n * \t\tThe ghost causing the player to die.\r\n */\r\nvoid collidedWithAGhost(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.npc.Ghost ghost);", "docComment": "Method called whenever a player meets a ghost.\r\nIt can be used to update the player's points accordingly.\r\n\r\n@param player\r\n\t\tThe player that will die.\r\n@param ghost\r\n\t\tThe ghost causing the player to die.\r\n", "metaSrc": "source code", "description": "Updates player points based on collision with a ghost.", "returns": "", "reason": "This method is part of the service layer as it orchestrates the logic for updating player points based on a collision event, which is a domain operation.", "howToUse": "Call this method when a collision between a player and a ghost occurs in the game. It should be triggered by an event handler or observer mechanism.", "howItWorks": "The method retrieves the current score of the player from the point calculator, adjusts it based on the type of ghost (e.g., different points for different ghosts), and updates the player's score accordingly.", "assertions": {"preConditions": ["A valid Player object is provided."], "postConditions": ["The player's score has been updated based on the collision with a ghost."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).1", "labels": ["Variable"], "properties": {"simpleName": "action", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The action to be performed when the key is pressed."}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player making a move."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getPacManDeathAnimation()", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The animation of a dying Pac-Man.\r\n */\r\npublic nl.tudelft.jpacman.sprite.AnimatedSprite getPacManDeathAnimation() {\r\n    java.lang.String resource = \"/sprite/dead.png\";\r\n    nl.tudelft.jpacman.sprite.Sprite baseImage = this.loadSprite(resource);\r\n    nl.tudelft.jpacman.sprite.AnimatedSprite animation = this.createAnimatedSprite(baseImage, nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_DEATH_FRAMES, nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY, false);\r\n    animation.setAnimating(false);\r\n    return animation;\r\n}", "docComment": "\r\n@return The animation of a dying Pac-Man.\r\n", "metaSrc": "source code", "description": "Returns an animated sprite representing Pac-Man's death animation.", "returns": "A new AnimatedSprite object for Pac-Man's death animation.", "reason": "The method creates a visual representation of Pac-Man dying, which is part of the game's graphical user interface (GUI).", "howToUse": "Call this method to get an animated sprite that can be displayed when Pac-Man dies in the game.", "howItWorks": "The method loads a death image, splits it into frames, and creates an AnimatedSprite object. It then sets the animation to not loop and returns the resulting sprite.", "assertions": {"preConditions": [], "postConditions": ["Returns an animated sprite for Pac-Man's death animation."]}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.collisions", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The table of possible collisions between units.\r\n */\r\nprivate final nl.tudelft.jpacman.level.CollisionMap collisions;", "visibility": "private", "simpleName": "collisions", "qualifiedName": "nl.tudelft.jpacman.level.Level.collisions", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image).0", "labels": ["Variable"], "properties": {"simpleName": "img", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).0", "labels": ["Variable"], "properties": {"simpleName": "grid", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The 2D array representing the game board."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "leaveSquare()", "qualifiedName": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "kind": "method", "sourceText": "/**\r\n * Leaves the currently occupying square, thus removing this unit from the board.\r\n */\r\npublic void leaveSquare() {\r\n    if (this.square != null) {\r\n        this.square.remove(this);\r\n        this.square = null;\r\n    }\r\n    assert this.invariant();\r\n}", "docComment": "Leaves the currently occupying square, thus removing this unit from the board.\r\n", "metaSrc": "source code", "description": "Removes the unit from its current square and asserts that the invariant is maintained.", "returns": "", "reason": "The method ensures that a unit is properly removed from its square, maintaining the integrity of the game state.", "howToUse": "Call `leaveSquare()` on an instance of `Unit` to remove it from its current square.", "howItWorks": "Checks if the unit has a square, removes it from the square's list of occupants, sets the square to null, and asserts that the invariant is true.", "assertions": {"preConditions": ["The unit must be on a square for `leaveSquare()` to function correctly."], "postConditions": ["The unit should not be present in its current square after calling `leaveSquare()`, and the invariant should hold."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "kind": "method", "sourceText": "/**\r\n * Method called whenever a player consumes a pellet.\r\n * It can be used to update the player's points accordingly.\r\n *\r\n * @param player\r\n * \t\tThe player consuming a pellet\r\n * @param pellet\r\n * \t\tThe pellet consumed.\r\n */\r\nvoid consumedAPellet(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.level.Pellet pellet);", "docComment": "Method called whenever a player consumes a pellet.\r\nIt can be used to update the player's points accordingly.\r\n\r\n@param player\r\n\t\tThe player consuming a pellet\r\n@param pellet\r\n\t\tThe pellet consumed.\r\n", "metaSrc": "source code", "description": "Updates player's score by adding points earned from consuming a pellet.", "returns": "", "reason": "This method is part of the Service Layer as it orchestrates the domain logic to update the player's score based on consuming a pellet.", "howToUse": "Call this method with the player and pellet objects when a pellet is consumed by the player.", "howItWorks": "The method retrieves the points associated with the pellet, adds them to the player's current score, and updates the player's score in the game state.", "assertions": {"preConditions": ["The player object must be valid and have a non-null score attribute.", "The pellet object must be valid and have a non-zero points value."], "postConditions": ["The player's score should be updated by the points earned from consuming the pellet.", "The game state should reflect the updated score of the player."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.mappings", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The mappings of keyCode to action.\r\n */\r\nprivate final java.util.Map<java.lang.Integer, nl.tudelft.jpacman.ui.Action> mappings;", "visibility": "private", "simpleName": "mappings", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener.mappings", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new map parser.\r\n *\r\n * @param levelFactory\r\n * \t\tThe factory providing the NPC objects and the level.\r\n * @param boardFactory\r\n * \t\tThe factory providing the Square objects and the board.\r\n */\r\npublic MapParser(nl.tudelft.jpacman.level.LevelFactory levelFactory, nl.tudelft.jpacman.board.BoardFactory boardFactory) {\r\n    super();\r\n    this.levelCreator = levelFactory;\r\n    this.boardCreator = boardFactory;\r\n}", "docComment": "Creates a new map parser.\r\n\r\n@param levelFactory\r\n\t\tThe factory providing the NPC objects and the level.\r\n@param boardFactory\r\n\t\tThe factory providing the Square objects and the board.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player who consumes the pellet."}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.sprite.PacManSprites)", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new BoardFactory that will create a board with the provided\r\n * background sprites.\r\n *\r\n * @param spriteStore\r\n * \t\tThe sprite store providing the sprites for the background.\r\n */\r\npublic BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites spriteStore) {\r\n    super();\r\n    this.sprites = spriteStore;\r\n}", "docComment": "Creates a new BoardFactory that will create a board with the provided\r\nbackground sprites.\r\n\r\n@param spriteStore\r\n\t\tThe sprite store providing the sprites for the background.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class).0", "labels": ["Variable"], "properties": {"simpleName": "clazz", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.isAlive()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "isAlive()", "qualifiedName": "nl.tudelft.jpacman.level.Player.isAlive()", "kind": "method", "sourceText": "/**\r\n * Returns whether this player is alive or not.\r\n *\r\n * @return <code>true</code> iff the player is alive.\r\n */\r\npublic boolean isAlive() {\r\n    return this.alive;\r\n}", "docComment": "Returns whether this player is alive or not.\r\n\r\n@return <code>true</code> iff the player is alive.\r\n", "metaSrc": "source code", "description": "Checks if the player is currently alive in the game.", "returns": "Boolean indicating whether the player is alive.", "reason": "The method provides a simple check to determine the current state of the player, which is essential for game logic and user interaction.", "howToUse": "Call `isAlive()` on an instance of `Player` to get the current life status.", "howItWorks": "The method simply returns the value stored in the `alive` field of the `Player` class.", "preConditions": [], "postConditions": [], "layer": "Domain Layer"}}}, {"data": {"id": "float", "labels": ["Primitive"], "properties": {"simpleName": "float", "qualifiedName": "float", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "private void playerColliding(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.board.Unit collidedOn) {\r\n    if (collidedOn instanceof nl.tudelft.jpacman.npc.Ghost) {\r\n        this.playerVersusGhost(player, ((nl.tudelft.jpacman.npc.Ghost) (collidedOn)));\r\n    }\r\n    if (collidedOn instanceof nl.tudelft.jpacman.level.Pellet) {\r\n        this.playerVersusPellet(player, ((nl.tudelft.jpacman.level.Pellet) (collidedOn)));\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Handles player collisions with pellets or ghosts, updating scores and game state accordingly.", "returns": "", "reason": "This method is part of the Service Layer as it orchestrates the game logic for handling collisions between the player and different entities in the game.", "howToUse": "Call this method when a collision occurs between the player and an entity on the board. It will determine if the collision was with a pellet or a ghost and call the appropriate handler method.", "howItWorks": "The method checks if the collidedOn unit is an instance of Ghost or Pellet. If it is, it calls the corresponding handler method to update the player's score or set them as dead.", "assertions": {"preConditions": ["A collision has occurred between the player and a unit on the board."], "postConditions": ["The player's score is updated if they collided with a pellet, or they are set as dead if they collided with a ghost."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "kind": "static method", "sourceText": "/**\r\n * Finds the nearest unit of the given type and returns its location. This\r\n * method will perform a breadth first search starting from the given\r\n * square.\r\n *\r\n * @param type\r\n * \t\tThe type of unit to search for.\r\n * @param currentLocation\r\n * \t\tThe starting location for the search.\r\n * @return The nearest unit of the given type, or <code>null</code> if no\r\nsuch unit could be found.\r\n */\r\npublic static nl.tudelft.jpacman.board.Unit findNearest(java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> type, nl.tudelft.jpacman.board.Square currentLocation) {\r\n    java.util.List<nl.tudelft.jpacman.board.Square> toDo = new java.util.ArrayList<nl.tudelft.jpacman.board.Square>();\r\n    java.util.Set<nl.tudelft.jpacman.board.Square> visited = new java.util.HashSet<nl.tudelft.jpacman.board.Square>();\r\n    toDo.add(currentLocation);\r\n    while (!toDo.isEmpty()) {\r\n        nl.tudelft.jpacman.board.Square square = toDo.remove(0);\r\n        nl.tudelft.jpacman.board.Unit unit = nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(type, square);\r\n        if (unit != null) {\r\n            assert unit.hasSquare();\r\n            return unit;\r\n        }\r\n        visited.add(square);\r\n        for (nl.tudelft.jpacman.board.Direction direction : nl.tudelft.jpacman.board.Direction.values()) {\r\n            nl.tudelft.jpacman.board.Square newTarget = square.getSquareAt(direction);\r\n            if ((!visited.contains(newTarget)) && (!toDo.contains(newTarget))) {\r\n                toDo.add(newTarget);\r\n            }\r\n        }\r\n    } \r\n    return null;\r\n}", "docComment": "Finds the nearest unit of the given type and returns its location. This\r\nmethod will perform a breadth first search starting from the given\r\nsquare.\r\n\r\n@param type\r\n\t\tThe type of unit to search for.\r\n@param currentLocation\r\n\t\tThe starting location for the search.\r\n@return The nearest unit of the given type, or <code>null</code> if no\r\nsuch unit could be found.\r\n", "metaSrc": "source code", "description": "Finds the nearest unit of a specified type on the game board from a given starting square.", "returns": "A nl.tudelft.jpacman.board.Unit instance representing the nearest unit of the specified type, or null if no such unit is found.", "reason": "This method implements a breadth-first search algorithm to find the nearest unit of a specific type on the game board from a given starting square. It uses a queue (toDo) and a set (visited) to keep track of squares that have been processed and those that have not, respectively.", "howToUse": "Call this method with the desired unit class and the starting square as arguments to find the nearest instance of that unit on the board.", "howItWorks": "The method initializes a queue (toDo) with the starting square and a set (visited) to keep track of visited squares. It then enters a loop where it removes the first square from the queue, checks if there is an instance of the specified unit class on that square, and returns it if found. If not, it marks the square as visited and adds all unvisited adjacent squares to the queue for further processing.", "assertions": {"preConditions": ["The starting square must be valid and exist in the game board."], "postConditions": ["The method returns a unit of the specified type if found, or null if no such unit is present on the board."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "neighbour", "qualifiedName": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The square to be linked."}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "checkMapFormat(java.util.List)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "kind": "method", "sourceText": "/**\r\n * Check the correctness of the map lines in the text.\r\n *\r\n * @param text\r\n * \t\tMap to be checked\r\n * @throws PacmanConfigurationException\r\n * \t\tif map is not OK.\r\n */\r\nprivate void checkMapFormat(java.util.List<java.lang.String> text) {\r\n    if (text == null) {\r\n        throw new nl.tudelft.jpacman.PacmanConfigurationException(\"Input text cannot be null.\");\r\n    }\r\n    if (text.isEmpty()) {\r\n        throw new nl.tudelft.jpacman.PacmanConfigurationException(\"Input text must consist of at least 1 row.\");\r\n    }\r\n    int width = text.get(0).length();\r\n    if (width == 0) {\r\n        throw new nl.tudelft.jpacman.PacmanConfigurationException(\"Input text lines cannot be empty.\");\r\n    }\r\n    for (java.lang.String line : text) {\r\n        if (line.length() != width) {\r\n            throw new nl.tudelft.jpacman.PacmanConfigurationException(\"Input text lines are not of equal width.\");\r\n        }\r\n    }\r\n}", "docComment": "Check the correctness of the map lines in the text.\r\n\r\n@param text\r\n\t\tMap to be checked\r\n@throws PacmanConfigurationException\r\n\t\tif map is not OK.\r\n", "metaSrc": "source code", "description": "Checks if the input text is valid for parsing as a map in the Pacman game.", "returns": "", "reason": "The method ensures that the input text is well-formed for parsing into a Pacman game map.", "howToUse": "Call this method with a list of strings representing the map, and it will throw an exception if the input is invalid.", "howItWorks": "The method checks if the input list is null or empty, then verifies that all lines have the same width. If any condition fails, it throws a `PacmanConfigurationException`.", "assertions": {"preConditions": ["text != null", "text.size() > 0"], "postConditions": ["No exceptions are thrown if the input is valid."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.points.PointCalculator)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)", "kind": "constructor", "sourceText": "/**\r\n * Create a simple player-based collision map, informing the\r\n * point calculator about points to be added.\r\n *\r\n * @param pointCalculator\r\n * \t\tStrategy for calculating points.\r\n */\r\npublic PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator pointCalculator) {\r\n    super();\r\n    this.pointCalculator = pointCalculator;\r\n}", "docComment": "Create a simple player-based collision map, informing the\r\npoint calculator about points to be added.\r\n\r\n@param pointCalculator\r\n\t\tStrategy for calculating points.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.INTERVAL_VARIATION", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The variation in intervals, this makes the ghosts look more dynamic and\r\n * less predictable.\r\n */\r\nprivate static final int INTERVAL_VARIATION = 50;", "visibility": "private", "simpleName": "INTERVAL_VARIATION", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Clyde.INTERVAL_VARIATION", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).0", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "X-coordinate to check"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player", "labels": ["Structure"], "properties": {"docComment": "A player operated unit in our game.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Player", "qualifiedName": "nl.tudelft.jpacman.level.Player", "kind": "class", "metaSrc": "source code", "description": "The Player class is responsible for managing the state and behavior of Pac-Man in the game, including its score, health, and interactions with other entities.", "layer": "Domain Layer", "roleStereotype": "Controller", "keywords": ["player", "pacman", "score", "health", "interactions"], "dependencyProfile": "transit"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0", "labels": ["Variable"], "properties": {"simpleName": "spriteMap", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The sprites for every direction."}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "kind": "method", "sourceText": "/**\r\n * creates a Square with the specified ghost on it\r\n * and appends the placed ghost into the ghost list.\r\n *\r\n * @param ghosts\r\n * \t\tall the ghosts in the level so far, the new ghost will be appended\r\n * @param ghost\r\n * \t\tthe newly created ghost to be placed\r\n * @return a square with the ghost on it.\r\n */\r\nprotected nl.tudelft.jpacman.board.Square makeGhostSquare(java.util.List<nl.tudelft.jpacman.npc.Ghost> ghosts, nl.tudelft.jpacman.npc.Ghost ghost) {\r\n    nl.tudelft.jpacman.board.Square ghostSquare = this.boardCreator.createGround();\r\n    ghosts.add(ghost);\r\n    ghost.occupy(ghostSquare);\r\n    return ghostSquare;\r\n}", "docComment": "creates a Square with the specified ghost on it\r\nand appends the placed ghost into the ghost list.\r\n\r\n@param ghosts\r\n\t\tall the ghosts in the level so far, the new ghost will be appended\r\n@param ghost\r\n\t\tthe newly created ghost to be placed\r\n@return a square with the ghost on it.\r\n", "metaSrc": "source code", "description": "Creates a new Ground square for a ghost and adds it to the board.", "returns": "A new Ground square representing the ground.", "reason": "This method is part of the Domain Layer as it handles the creation and management of game entities, specifically ghosts on the game board.", "howToUse": "Call this method with a list of ghosts and a specific ghost to create a new Ground square for that ghost and add it to the board.", "howItWorks": "The method creates a new Ground square using the `boardCreator.createGround()` method. It then adds the specified ghost to the list of ghosts and occupies the newly created ground square with the ghost, updating the ghost's state accordingly.", "assertions": {"preConditions": ["A valid List<Ghost> is provided.", "The Ghost object is not null."], "postConditions": ["A new Ground square is created and added to the board.", "The ghost is occupied on the newly created ground square."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "labels": ["Variable"], "properties": {"simpleName": "spriteStore", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite", "labels": ["Container"], "properties": {"simpleName": "sprite", "qualifiedName": "nl.tudelft.jpacman.sprite", "kind": "package", "metaSrc": "source code", "description": "The package manages and provides access to various game sprites, including walls, pellets, and Pac-Man characters, handling loading and caching of these sprites from resource files.", "layer": "Service Layer", "title": "Sprite Management", "keywords": ["sprite", "management", "game", "sprites", "loading", "caching"]}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.Launcher()", "kind": "constructor", "sourceText": "Launcher() {\r\n    super();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "labels": ["Variable"], "properties": {"simpleName": "type", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The class type of the unit to find."}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.inProgress", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * <code>true</code> if the game is in progress.\r\n */\r\nprivate boolean inProgress;", "visibility": "private", "simpleName": "inProgress", "qualifiedName": "nl.tudelft.jpacman.game.Game.inProgress", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "withinImage(int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "kind": "method", "sourceText": "private boolean withinImage(int x, int y) {\r\n    return (((x < this.image.getWidth(null)) && (x >= 0)) && (y < this.image.getHeight(null))) && (y >= 0);\r\n}", "docComment": "", "metaSrc": "source code", "description": "Checks if given coordinates are within the bounds of the image.", "returns": "Boolean indicating if the coordinates are within the image bounds", "reason": "The method is part of the ImageSprite class, which represents a sprite with an associated image. It ensures that the coordinates provided do not exceed the dimensions of the image.", "howToUse": "Call `withinImage(int x, int y)` to check if a given coordinate pair is within the bounds of the image.", "howItWorks": "The method checks if both the X and Y coordinates are within the valid range defined by the image's width and height. It returns true if both conditions are met, otherwise false.", "assertions": {"preConditions": ["x >= 0", "y >= 0"], "postConditions": ["returns true if x < this.image.getWidth(null) && y < this.image.getHeight(null)", "returns false otherwise"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).1", "labels": ["Variable"], "properties": {"simpleName": "board", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The game board to search on."}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][]).0", "labels": ["Variable"], "properties": {"simpleName": "grid", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][]).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The grid representing the board."}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void pacmanMoved(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.board.Direction direction) {\r\n    // no points for moving\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "graphics", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.npcs", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The NPCs of this level and, if they are running, their schedules.\r\n */\r\nprivate final java.util.Map<nl.tudelft.jpacman.npc.Ghost, java.util.concurrent.ScheduledExecutorService> npcs;", "visibility": "private", "simpleName": "npcs", "qualifiedName": "nl.tudelft.jpacman.level.Level.npcs", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory", "labels": ["Container", "Structure"], "properties": {"docComment": "Factory that creates levels and units.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "LevelFactory", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for creating and managing game entities such as ghosts, pellets, and levels in a Pacman game.", "layer": "Domain Layer", "roleStereotype": "Service Provider", "keywords": ["game", "entity", "factory", "level", "ghost", "pellet"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel.serialVersionUID", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Default serialisation ID.\r\n */\r\nprivate static final long serialVersionUID = 1L;", "visibility": "private", "simpleName": "serialVersionUID", "qualifiedName": "nl.tudelft.jpacman.ui.ButtonPanel.serialVersionUID", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$LevelObserver", "labels": ["Structure"], "properties": {"docComment": "An observer that will be notified when the level is won or lost.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "LevelObserver", "qualifiedName": "nl.tudelft.jpacman.level.Level$LevelObserver", "kind": "interface", "metaSrc": "source code", "description": "The Level$LevelObserver interface is responsible for notifying observers about changes in the game's level state, specifically when a level is lost or won.", "layer": "Service Layer", "roleStereotype": "Controller", "keywords": ["level observer", "game events", "observer pattern"], "dependencyProfile": "hidden"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "labels": ["Variable"], "properties": {"simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The point calculator to use for scoring."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.isInProgress()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "isInProgress()", "qualifiedName": "nl.tudelft.jpacman.level.Level.isInProgress()", "kind": "method", "sourceText": "/**\r\n * Returns whether this level is in progress, i.e. whether moves can be made\r\n * on the board.\r\n *\r\n * @return <code>true</code> iff this level is in progress.\r\n */\r\npublic boolean isInProgress() {\r\n    return this.inProgress;\r\n}", "docComment": "Returns whether this level is in progress, i.e. whether moves can be made\r\non the board.\r\n\r\n@return <code>true</code> iff this level is in progress.\r\n", "metaSrc": "source code", "description": "Returns whether the level is currently in progress.", "returns": "Boolean indicating if the level is in progress.", "reason": "The method provides a simple getter for the `inProgress` flag, which indicates the current state of the game level.", "howToUse": "Call `isInProgress()` to check if the level is active or not.", "howItWorks": "The method simply returns the value of the `inProgress` field, which is a boolean indicating whether the level has started and is ongoing.", "preConditions": [], "postConditions": [], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory", "labels": ["Container", "Structure"], "properties": {"docComment": "A factory that creates {@link Board} objects from 2-dimensional arrays of\r\n{@link Square}s.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "BoardFactory", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory", "kind": "class", "metaSrc": "source code", "description": "The BoardFactory class is responsible for creating game board components such as squares and walls, and managing their relationships to form a playable grid.", "layer": "Domain Layer", "roleStereotype": "Service Provider", "keywords": ["BoardFactory", "Game Board Components", "Square Creation", "Wall Creation", "Grid Management"], "dependencyProfile": "transit"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).1", "labels": ["Variable"], "properties": {"simpleName": "ghost", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The ghost to be added to the board."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "kind": "method", "sourceText": "/**\r\n * Let the score panel use a dedicated score formatter.\r\n *\r\n * @param scoreFormatter\r\n * \t\tScore formatter to be used.\r\n */\r\npublic void setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel.ScoreFormatter scoreFormatter) {\r\n    assert scoreFormatter != null;\r\n    this.scoreFormatter = scoreFormatter;\r\n}", "docComment": "Let the score panel use a dedicated score formatter.\r\n\r\n@param scoreFormatter\r\n\t\tScore formatter to be used.\r\n", "metaSrc": "source code", "description": "Sets the score formatter for displaying scores in the Pacman game.", "returns": "", "reason": "This method is part of the Presentation Layer as it manages the user interface by setting up how scores are displayed.", "howToUse": "Call this method with an instance of ScoreFormatter to customize the score display in the game.", "howItWorks": "The method checks if the provided score formatter is not null and then assigns it to the class variable scoreFormatter, which controls how scores are formatted and displayed.", "assertions": {"preConditions": ["scoreFormatter != null"], "postConditions": ["this.scoreFormatter == scoreFormatter"]}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "loadPointCalculator()", "qualifiedName": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "kind": "method", "sourceText": "private nl.tudelft.jpacman.points.PointCalculator loadPointCalculator() {\r\n    return new nl.tudelft.jpacman.points.PointCalculatorLoader().load();\r\n}", "docComment": "", "metaSrc": "source code", "description": "Loads a point calculator dynamically from a file or uses a default if not found.", "returns": "The loaded PointCalculator instance.", "reason": "This method is part of the Service Layer as it controls the application flow by loading a points calculator, which is essential for managing game scoring in the Pacman game.", "howToUse": "Call this method to obtain an instance of PointCalculator that can be used to calculate scores in the game.", "howItWorks": "The method uses a PointCalculatorLoader to dynamically load a point calculator class. If no specific class is found, it defaults to using a default implementation.", "assertions": {"preConditions": [], "postConditions": ["The returned PointCalculator instance is not null."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent).0", "labels": ["Variable"], "properties": {"simpleName": "event", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.EAST", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * East, or right.\r\n */\r\nEAST(1, 0)", "visibility": "public", "simpleName": "EAST", "qualifiedName": "nl.tudelft.jpacman.board.Direction.EAST", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.parent", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The parent node, which is <code>null</code> for the root node.\r\n */\r\nprivate final nl.tudelft.jpacman.npc.ghost.Navigation.Node parent;", "visibility": "private", "simpleName": "parent", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.parent", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite", "labels": ["Structure"], "properties": {"docComment": "Animated sprite, renders the frame depending on the time of requesting the\r\ndraw.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "AnimatedSprite", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for managing and animating sprites, handling user input, and updating game state.", "layer": "Service Layer", "roleStereotype": "Controller", "keywords": ["sprite management", "animation", "user input", "game state"], "dependencyProfile": "inbound"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "labels": ["Structure"], "properties": {"docComment": "Provide means to format the score for a given player.\r\n", "simpleName": "ScoreFormatter", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "kind": "interface", "metaSrc": "source code", "description": "The ScoreFormatter interface is responsible for formatting scores in the Pacman game, providing a readable string representation of players' scores.", "layer": "Presentation Layer", "roleStereotype": "User Interfacer", "keywords": ["Score", "Formatting", "Pacman", "User Interface"], "dependencyProfile": "hidden"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites()", "kind": "constructor", "sourceText": "PacManSprites() {\r\n    super();\r\n}", "docComment": "", "metaSrc": "source code", "description": "Initializes a new instance of PacManSprites by setting up an empty HashMap to store sprite mappings.", "returns": "A newly created instance of PacManSprites with an empty HashMap for storing sprite mappings.", "reason": "This method initializes the PacManSprites class, which is responsible for managing sprite resources used in the game. By creating an empty HashMap, it prepares the storage structure needed to map sprite names to their corresponding images or graphics.", "howToUse": "To use this method, simply instantiate a new instance of PacManSprites by calling its constructor without any arguments.", "howItWorks": "The constructor calls the superclass's constructor using `super()` to initialize the SpriteStore. This ensures that the base class is properly set up before additional initialization occurs in the PacManSprites class.", "assertions": {"preConditions": [], "postConditions": ["A new instance of PacManSprites with an empty HashMap for sprite mappings is created."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_ANIMATION_FRAMES", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The amount of frames in the pacman animation.\r\n */\r\nprivate static final int PACMAN_ANIMATION_FRAMES = 4;", "visibility": "private", "simpleName": "PACMAN_ANIMATION_FRAMES", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_ANIMATION_FRAMES", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createWall()", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "kind": "method", "sourceText": "/**\r\n * Creates a new square that cannot be occupied by any unit.\r\n *\r\n * @return A new square that cannot be occupied by any unit.\r\n */\r\npublic nl.tudelft.jpacman.board.Square createWall() {\r\n    return new nl.tudelft.jpacman.board.BoardFactory.Wall(this.sprites.getWallSprite());\r\n}", "docComment": "Creates a new square that cannot be occupied by any unit.\r\n\r\n@return A new square that cannot be occupied by any unit.\r\n", "metaSrc": "source code", "description": "Creates a new Wall square on the board using the specified wall sprite.", "returns": "A new Square representing a wall on the board.", "reason": "The method is part of the BoardFactory class, which is responsible for creating game elements like walls and squares. It uses the getWallSprite() method to load the appropriate image for the wall.", "howToUse": "Call createWall() from within the BoardFactory class to add a new wall square to the board.", "howItWorks": "The method creates a new Wall object by passing the loaded wall sprite to its constructor. This wall is then returned as a Square object, which represents a physical space on the game board where Pacman cannot move.", "assertions": {"preConditions": ["getWallSprite() returns an ImageSprite representing the wall"], "postConditions": ["createWall() returns a new WallSquare instance"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.getBoard()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getBoard()", "qualifiedName": "nl.tudelft.jpacman.level.Level.getBoard()", "kind": "method", "sourceText": "/**\r\n * Returns the board of this level.\r\n *\r\n * @return The board of this level.\r\n */\r\npublic nl.tudelft.jpacman.board.Board getBoard() {\r\n    return this.board;\r\n}", "docComment": "Returns the board of this level.\r\n\r\n@return The board of this level.\r\n", "metaSrc": "source code", "description": "Returns the current board configuration for the Pacman game.", "returns": "The Board object representing the current state of the game.", "reason": "This method provides access to the game's internal representation, allowing other parts of the application to interact with and manipulate the game board.", "howToUse": "To use this method, simply call it on an instance of Level. This will return the Board object that contains all the entities (e.g., Pacman, ghosts, pellets) in their current positions.", "howItWorks": "The method returns a reference to the private field 'board' which holds the current state of the game board. This is done by simply returning this.board.", "assertions": {"preConditions": [], "postConditions": []}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).0", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).1", "labels": ["Variable"], "properties": {"simpleName": "deathAnimation", "qualifiedName": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The animation to play when the player dies."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).0", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The x-coordinate to check."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.getSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSprite()", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.getSprite()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite getSprite() {\r\n    return this.sprites.get(this.getDirection());\r\n}", "docComment": "", "metaSrc": "source code", "description": "Returns the sprite corresponding to the current direction of the ghost.", "returns": "The Sprite representing the ghost in its current direction.", "reason": "This method provides a way to dynamically change the visual representation of the ghost based on its movement direction, which is essential for creating an interactive and visually appealing Pacman game.", "howToUse": "Call this method whenever you need to update the sprite displayed on the screen to reflect the ghost's current position and direction.", "howItWorks": "The method retrieves the current direction of the ghost using the `getDirection()` method and uses it as an index to access the corresponding sprite from a list stored in the `sprites` field. This allows for smooth transitions between different directions as the ghost moves around the game board.", "preConditions": ["The `sprites` field must be initialized with valid sprites for each direction.", "The `getDirection()` method must return a valid direction enum value."], "postConditions": ["The returned sprite should match the current direction of the ghost.", "The method should handle cases where the direction is not recognized by returning a default or placeholder sprite if necessary."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky", "labels": ["Structure"], "properties": {"docComment": "<p>\r\nAn implementation of the classic Pac-Man ghost Shadow.\r\n</p>\r\n<p>\r\nNickname: Blinky. As his name implies, Shadow is usually a constant shadow on\r\nPac-Man's tail. When he's not patrolling the top-right corner of the maze,\r\nShadow tries to find the quickest route to Pac-Man's position. Despite the\r\nfact that Pinky's real name is Speedy, Shadow is actually the fastest of the\r\nghosts because of when there are only a few pellets left, Blinky drastically\r\nspeeds up, which can make him quite deadly. In the original Japanese version,\r\nhis name is Oikake/Akabei.\r\n</p>\r\n<p>\r\n<b>AI:</b> When the ghosts are not patrolling in their home corners (Blinky:\r\ntop-right, Pinky: top-left, Inky: bottom-right, Clyde: bottom-left), Blinky\r\nwill attempt to shorten the distance between Pac-Man and himself. If he has\r\nto choose between shortening the horizontal or vertical distance, he will\r\nchoose to shorten whichever is greatest. For example, if Pac-Man is four grid\r\nspaces to the left, and seven grid spaces above Blinky, he'll try to move up\r\ntowards Pac-Man before he moves to the left.\r\n</p>\r\n<p>\r\nSource: http://strategywiki.org/wiki/Pac-Man/Getting_Started\r\n</p>\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Blinky", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Blinky", "kind": "class", "metaSrc": "source code", "description": "The Blinky class is responsible for managing the behavior and movement of the Blinky ghost in the Pac-Man game. It initializes the ghost with specific configurations, determines the next move based on finding the nearest player, and implements AI logic to navigate towards the player.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["Blinky", "Ghost", "Pac-Man", "AI", "Movement", "Pathfinding"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.boardCreator", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The factory that creates the squares and board.\r\n */\r\nprivate final nl.tudelft.jpacman.board.BoardFactory boardCreator;", "visibility": "private", "simpleName": "boardCreator", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.boardCreator", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidedOn", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that was collided with, which must be a player."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent).0", "labels": ["Variable"], "properties": {"simpleName": "event", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The KeyEvent object containing information about the pressed key."}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "mover", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that causes the collision by occupying a square with another unit already on it."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.DEFAULT_SCORE_FORMATTER", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The default way in which the score is shown.\r\n */\r\npublic static final nl.tudelft.jpacman.ui.ScorePanel.ScoreFormatter DEFAULT_SCORE_FORMATTER = (nl.tudelft.jpacman.level.Player player) -> java.lang.String.format(\"Score: %3d\", player.getScore());", "visibility": "public", "simpleName": "DEFAULT_SCORE_FORMATTER", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel.DEFAULT_SCORE_FORMATTER", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelMap()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getLevelMap()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getLevelMap()", "kind": "method", "sourceText": "/**\r\n * The map file used to populate the level.\r\n *\r\n * @return The name of the map file.\r\n */\r\nprotected java.lang.String getLevelMap() {\r\n    return this.levelMap;\r\n}", "docComment": "The map file used to populate the level.\r\n\r\n@return The name of the map file.\r\n", "metaSrc": "source code", "description": "Returns the level map for the Pacman game.", "returns": "The level map as a string.", "reason": "This method provides access to the current level map of the Pacman game, which is essential for rendering and updating the game's state.", "howToUse": "Call this method from within the game logic or UI components to retrieve the current level configuration.", "howItWorks": "The method simply returns the value stored in the `levelMap` field of the class. This field is typically initialized during the setup of the game and contains the layout information for each level.", "preConditions": [], "postConditions": [], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.SHYNESS", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The amount of cells Clyde wants to stay away from Pac Man.\r\n */\r\nprivate static final int SHYNESS = 8;", "visibility": "private", "simpleName": "SHYNESS", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Clyde.SHYNESS", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.handlers", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The collection of collision handlers.\r\n */\r\nprivate final java.util.Map<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, java.util.Map<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<? extends java.lang.Object, ? extends java.lang.Object>>> handlers;", "visibility": "private", "simpleName": "handlers", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.handlers", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).0", "labels": ["Variable"], "properties": {"simpleName": "spriteStore", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "kind": "method", "sourceText": "/**\r\n * Adds a button to the UI.\r\n *\r\n * @param caption\r\n * \t\tThe caption of the button.\r\n * @param action\r\n * \t\tThe action to execute when the button is clicked.\r\n * @return The builder.\r\n */\r\npublic nl.tudelft.jpacman.ui.PacManUiBuilder addButton(java.lang.String caption, nl.tudelft.jpacman.ui.Action action) {\r\n    assert caption != null;\r\n    assert !caption.isEmpty();\r\n    assert action != null;\r\n    this.buttons.put(caption, action);\r\n    return this;\r\n}", "docComment": "Adds a button to the UI.\r\n\r\n@param caption\r\n\t\tThe caption of the button.\r\n@param action\r\n\t\tThe action to execute when the button is clicked.\r\n@return The builder.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The width of the target sprite."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.MOVE_INTERVAL", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The base movement interval.\r\n */\r\nprivate static final int MOVE_INTERVAL = 250;", "visibility": "private", "simpleName": "MOVE_INTERVAL", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Clyde.MOVE_INTERVAL", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getPath()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "kind": "method", "sourceText": "/**\r\n * Returns the list of values from the root of the tree to this node.\r\n *\r\n * @return The list of values from the root of the tree to this node.\r\n */\r\nprivate java.util.List<nl.tudelft.jpacman.board.Direction> getPath() {\r\n    if (this.parent == null) {\r\n        return new java.util.ArrayList<nl.tudelft.jpacman.board.Direction>();\r\n    }\r\n    java.util.List<nl.tudelft.jpacman.board.Direction> path = this.parent.getPath();\r\n    path.add(this.getDirection());\r\n    return path;\r\n}", "docComment": "Returns the list of values from the root of the tree to this node.\r\n\r\n@return The list of values from the root of the tree to this node.\r\n", "metaSrc": "source code", "description": "Returns the list of directions from the root node to the current node in the navigation tree.", "returns": "A list of Direction objects representing the path from the root to the current node.", "reason": "The method is part of a navigation system for ghosts in the Pacman game, providing a way to trace their movement through the board.", "howToUse": "Call this method on a Navigation$Node object to get the path it represents.", "howItWorks": "If the node has no parent (i.e., it's the root), it returns an empty list. Otherwise, it recursively retrieves the path from its parent and adds the current node's direction to the end of the list.", "assertions": {"preConditions": ["The method is called on a valid Navigation$Node object."], "postConditions": ["The returned list contains all directions from the root to the current node, including the current node's direction."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics).0", "labels": ["Variable"], "properties": {"simpleName": "g", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).0", "labels": ["Variable"], "properties": {"simpleName": "resource", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The path to the resource file containing the sprite."}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The direction of the move."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "graphics", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.levelWon()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "levelWon()", "qualifiedName": "nl.tudelft.jpacman.game.Game.levelWon()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void levelWon() {\r\n    this.stop();\r\n}", "docComment": "", "metaSrc": "source code", "description": "Stops the game by pausing it and setting the in-progress flag to false.", "returns": "", "reason": "The method is part of the Game class, which manages the overall state and flow of the Pacman game. It stops the game when a level is won, ensuring that the game can be restarted or ended appropriately.", "howToUse": "Call `levelWon()` to stop the current level and pause the game.", "howItWorks": "The method calls the `stop()` method, which sets the in-progress flag to false and stops the current level. This ensures that the game state is updated correctly and that the user can interact with the UI or restart the game if desired.", "preConditions": ["The game must be in progress.", "A level must have been won."], "postConditions": ["The game is stopped and paused.", "The in-progress flag is set to false.", "The current level is no longer active."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "load()", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "kind": "method", "sourceText": "/**\r\n * Load a points calculator and return it.\r\n *\r\n * @return The (dynamically loaded) points calculator.\r\n */\r\npublic nl.tudelft.jpacman.points.PointCalculator load() {\r\n    try {\r\n        if (nl.tudelft.jpacman.points.PointCalculatorLoader.clazz == null) {\r\n            nl.tudelft.jpacman.points.PointCalculatorLoader.clazz = this.loadClassFromFile();\r\n        }\r\n        return ((nl.tudelft.jpacman.points.PointCalculator) (nl.tudelft.jpacman.points.PointCalculatorLoader.clazz.newInstance()));\r\n    } catch (java.lang.Exception e) {\r\n        throw new java.lang.RuntimeException(\"Could not dynamically load the points calculator.\", e);\r\n    }\r\n}", "docComment": "Load a points calculator and return it.\r\n\r\n@return The (dynamically loaded) points calculator.\r\n", "metaSrc": "source code", "description": "Loads a point calculator class dynamically from a file or uses a default if not found.", "returns": "The loaded PointCalculator instance.", "reason": "This method is part of the Service Layer as it manages dynamic loading of a point calculator, which is an essential operation for configuring game behavior in a Pacman implementation.", "howToUse": "Call this method to obtain a PointCalculator instance. It will load the class from a specified file or use a default if not found.", "howItWorks": "The method first checks if the clazz field is null, indicating that the class has not been loaded yet. If so, it calls loadClassFromFile() to load the class dynamically. Then, it creates an instance of the loaded class using newInstance().", "assertions": {"preConditions": ["The PointCalculatorLoader class must be initialized and accessible.", "The loadClassFromFile() method should return a valid Class object for the point calculator."], "postConditions": ["A new PointCalculator instance is returned if successful, or an exception is thrown if loading fails."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.playerFactory", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The factory providing the player objects.\r\n */\r\nprivate final nl.tudelft.jpacman.level.PlayerFactory playerFactory;", "visibility": "private", "simpleName": "playerFactory", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory.playerFactory", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "parseMap(char[][])", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "kind": "method", "sourceText": "/**\r\n * Parses the text representation of the board into an actual level.\r\n *\r\n * <ul>\r\n * <li>Supported characters:\r\n * <li>' ' (space) an empty square.\r\n * <li>'#' (bracket) a wall.\r\n * <li>'.' (period) a square with a pellet.\r\n * <li>'P' (capital P) a starting square for players.\r\n * <li>'G' (capital G) a square with a ghost.\r\n * </ul>\r\n *\r\n * @param map\r\n * \t\tThe text representation of the board, with map[x][y]\r\n * \t\trepresenting the square at position x,y.\r\n * @return The level as represented by this text.\r\n */\r\npublic nl.tudelft.jpacman.level.Level parseMap(char[][] map) {\r\n    int width = map.length;\r\n    int height = map[0].length;\r\n    nl.tudelft.jpacman.board.Square[][] grid = new nl.tudelft.jpacman.board.Square[width][height];\r\n    java.util.List<nl.tudelft.jpacman.npc.Ghost> ghosts = new java.util.ArrayList<nl.tudelft.jpacman.npc.Ghost>();\r\n    java.util.List<nl.tudelft.jpacman.board.Square> startPositions = new java.util.ArrayList<nl.tudelft.jpacman.board.Square>();\r\n    this.makeGrid(map, width, height, grid, ghosts, startPositions);\r\n    nl.tudelft.jpacman.board.Board board = this.boardCreator.createBoard(grid);\r\n    return this.levelCreator.createLevel(board, ghosts, startPositions);\r\n}", "docComment": "Parses the text representation of the board into an actual level.\r\n\r\n<ul>\r\n<li>Supported characters:\r\n<li>' ' (space) an empty square.\r\n<li>'#' (bracket) a wall.\r\n<li>'.' (period) a square with a pellet.\r\n<li>'P' (capital P) a starting square for players.\r\n<li>'G' (capital G) a square with a ghost.\r\n</ul>\r\n\r\n@param map\r\n\t\tThe text representation of the board, with map[x][y]\r\n\t\trepresenting the square at position x,y.\r\n@return The level as represented by this text.\r\n", "metaSrc": "source code", "description": "Parses a map file and constructs a game board for Pacman, initializing ghosts and start positions.", "returns": "An instance of nl.tudelft.jpacman.level.Level.", "reason": "The method is responsible for parsing a map file and creating a game board, which involves initializing various components such as ghosts and start positions.", "howToUse": "Call the parseMap method with a 2D array representing the game map to create a new level for Pacman.", "howItWorks": "The method first determines the width and height of the map. It then creates a grid of squares, initializes lists for ghosts and start positions, and uses the makeGrid method to populate these lists based on the map characters. After creating the board, it uses the boardCreator to create a new board instance from the grid and the levelCreator to create a new level using the board, ghosts, and start positions.", "assertions": {"preConditions": ["The input map is a valid 2D array of characters."], "postConditions": ["A new Level instance is returned with initialized components such as ghosts and start positions."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.getLevel()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getLevel()", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame.getLevel()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.level.Level getLevel() {\r\n    return this.level;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.getHeight()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getHeight()", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.getHeight()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic int getHeight() {\r\n    return this.image.getHeight(null);\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "labels": ["Constructor"], "properties": {"visibility": "protected", "simpleName": "<init>(nl.tudelft.jpacman.points.PointCalculator)", "qualifiedName": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new game.\r\n *\r\n * @param pointCalculator\r\n * \t\tThe way to calculate points upon collisions.\r\n */\r\nprotected Game(nl.tudelft.jpacman.points.PointCalculator pointCalculator) {\r\n    super();\r\n    this.pointCalculator = pointCalculator;\r\n    this.inProgress = false;\r\n}", "docComment": "Creates a new game.\r\n\r\n@param pointCalculator\r\n\t\tThe way to calculate points upon collisions.\r\n", "metaSrc": "source code", "description": "Initializes a new game instance with a specified point calculator.", "returns": "A new instance of the Game class.", "reason": "This method is responsible for setting up the initial state of a game, including initializing the point calculator and marking the game as not in progress.", "howToUse": "Create an instance of nl.tudelft.jpacman.points.PointCalculator and pass it to this constructor when creating a new Game object.", "howItWorks": "The method initializes the superclass with no arguments, sets the provided point calculator, and marks the game as not in progress.", "preConditions": ["A valid PointCalculator instance is provided."], "postConditions": ["A new Game instance is created with the specified point calculator and marked as not in progress."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.deathSprite", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The animation that is to be played when Pac-Man dies.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.AnimatedSprite deathSprite;", "visibility": "private", "simpleName": "deathSprite", "qualifiedName": "nl.tudelft.jpacman.level.Player.deathSprite", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "square", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The square to render."}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void collidedWithAGhost(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.npc.Ghost ghost) {\r\n    // no points for colliding with a ghost\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidedOn", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that the mover collided with."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.util.List)", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new score panel with a column for each player.\r\n *\r\n * @param players\r\n * \t\tThe players to display the scores of.\r\n */\r\npublic ScorePanel(java.util.List<nl.tudelft.jpacman.level.Player> players) {\r\n    super();\r\n    assert players != null;\r\n    this.setLayout(new java.awt.GridLayout(2, players.size()));\r\n    for (int i = 1; i <= players.size(); i++) {\r\n        this.add(new javax.swing.JLabel(\"Player \" + i, javax.swing.JLabel.CENTER));\r\n    }\r\n    this.scoreLabels = new java.util.LinkedHashMap<nl.tudelft.jpacman.level.Player, javax.swing.JLabel>();\r\n    for (nl.tudelft.jpacman.level.Player player : players) {\r\n        javax.swing.JLabel scoreLabel = new javax.swing.JLabel(\"0\", javax.swing.JLabel.CENTER);\r\n        this.scoreLabels.put(player, scoreLabel);\r\n        this.add(scoreLabel);\r\n    }\r\n}", "docComment": "Creates a new score panel with a column for each player.\r\n\r\n@param players\r\n\t\tThe players to display the scores of.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String).0", "labels": ["Variable"], "properties": {"simpleName": "message", "qualifiedName": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "paint(java.awt.Graphics)", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void paint(java.awt.Graphics g) {\r\n    assert g != null;\r\n    this.render(this.game.getLevel().getBoard(), g, this.getSize());\r\n}", "docComment": "", "metaSrc": "source code", "description": "Renders the Pacman game board by drawing each square and its contents.", "returns": "void", "reason": "The method is responsible for updating the visual representation of the game board in the user interface.", "howToUse": "Call this method to refresh the display of the game board after changes have been made, such as eating a pellet or moving a character.", "howItWorks": "The method retrieves the current level and board from the game object, then calls the render method with these objects and the size of the panel to draw the board on the graphics context.", "assertions": {"preConditions": ["g is not null"], "postConditions": []}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).1", "labels": ["Variable"], "properties": {"simpleName": "delay", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "Delay between each frame in milliseconds."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.refresh()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "refresh()", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel.refresh()", "kind": "method", "sourceText": "/**\r\n * Refreshes the scores of the players.\r\n */\r\nprotected void refresh() {\r\n    for (java.util.Map.Entry<nl.tudelft.jpacman.level.Player, javax.swing.JLabel> entry : this.scoreLabels.entrySet()) {\r\n        nl.tudelft.jpacman.level.Player player = entry.getKey();\r\n        java.lang.String score = \"\";\r\n        if (!player.isAlive()) {\r\n            score = \"You died. \";\r\n        }\r\n        score += this.scoreFormatter.format(player);\r\n        entry.getValue().setText(score);\r\n    }\r\n}", "docComment": "Refreshes the scores of the players.\r\n", "metaSrc": "source code", "description": "Updates the score panel to reflect player scores and death status.", "returns": "None", "reason": "The method updates the user interface based on game state changes, providing real-time feedback to the player.", "howToUse": "Call this method whenever a player's score or death status changes in the game.", "howItWorks": "Iterates over each player and their corresponding label, checks if the player is alive, formats the score, and updates the label text accordingly.", "assertions": {"preConditions": ["The `scoreLabels` map contains valid entries for players and labels.", "The `scoreFormatter` instance is properly initialized."], "postConditions": ["All labels in the `scoreLabels` map are updated with the correct score or death message."]}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.updateObservers()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "updateObservers()", "qualifiedName": "nl.tudelft.jpacman.level.Level.updateObservers()", "kind": "method", "sourceText": "/**\r\n * Updates the observers about the state of this level.\r\n */\r\nprivate void updateObservers() {\r\n    java.lang.Iterable<nl.tudelft.jpacman.level.Level.LevelObserver> observers = new java.util.ArrayList<nl.tudelft.jpacman.level.Level.LevelObserver>(this.observers);\r\n    if (!this.isAnyPlayerAlive()) {\r\n        for (nl.tudelft.jpacman.level.Level.LevelObserver observer : observers) {\r\n            observer.levelLost();\r\n        }\r\n    }\r\n    if (this.remainingPellets() == 0) {\r\n        for (nl.tudelft.jpacman.level.Level.LevelObserver observer : observers) {\r\n            observer.levelWon();\r\n        }\r\n    }\r\n}", "docComment": "Updates the observers about the state of this level.\r\n", "metaSrc": "source code", "description": "Notifies observers when the level is lost or won based on player status and remaining pellets.", "returns": "", "reason": "The method updates observers about the game's state, which is a domain operation that affects the game logic but does not directly interact with user interface elements or data sources.", "howToUse": "Call `updateObservers()` when the level status changes to determine if any players are alive or if all pellets have been collected.", "howItWorks": "The method iterates over a copy of the observers list, notifying each observer about the level's state. It checks for player death and pellet collection to trigger specific events.", "assertions": {"preConditions": ["Observers must be initialized before calling `updateObservers()`.", "Level status (alive players, pellets remaining) should be correctly set before updating observers."], "postConditions": ["Observers are notified about the level's state changes.", "The method does not modify any external resources or data sources."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.addPoints(int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "addPoints(int)", "qualifiedName": "nl.tudelft.jpacman.level.Player.addPoints(int)", "kind": "method", "sourceText": "/**\r\n * Adds points to the score of this player.\r\n *\r\n * @param points\r\n * \t\tThe amount of points to add to the points this player already\r\n * \t\thas.\r\n */\r\npublic void addPoints(int points) {\r\n    this.score += points;\r\n}", "docComment": "Adds points to the score of this player.\r\n\r\n@param points\r\n\t\tThe amount of points to add to the points this player already\r\n\t\thas.\r\n", "metaSrc": "source code", "description": "Adds points to the player's score.", "returns": "void", "reason": "This method is part of the Domain Layer as it handles the business logic for updating a player's score.", "howToUse": "Call `addPoints(int)` with the desired number of points to increase the player's score.", "howItWorks": "The method increments the `score` field by the specified number of points.", "preConditions": ["A valid integer value for points is provided."], "postConditions": ["The player's score has been updated by the specified amount."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "setDirection(nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "/**\r\n * Sets this unit to face the new direction.\r\n *\r\n * @param newDirection\r\n * \t\tThe new direction this unit is facing.\r\n */\r\npublic void setDirection(nl.tudelft.jpacman.board.Direction newDirection) {\r\n    this.direction = newDirection;\r\n}", "docComment": "Sets this unit to face the new direction.\r\n\r\n@param newDirection\r\n\t\tThe new direction this unit is facing.\r\n", "metaSrc": "source code", "description": "Sets the direction for a unit in the game board.", "returns": "", "reason": "This method is part of the Domain Layer as it handles the logic related to setting a unit's direction in the game board.", "howToUse": "Call this method with the desired direction to update the unit's movement.", "howItWorks": "The method assigns the new direction to the unit's internal state, which is then used by other methods to determine the unit's next move.", "preConditions": ["A valid Direction object must be provided."], "postConditions": ["The unit's direction is updated to the specified value."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "kind": "method", "sourceText": "/**\r\n * Actual case of player consuming a pellet.\r\n *\r\n * @param player\r\n * \t\tThe player involved in the collision.\r\n * @param pellet\r\n * \t\tThe pellet involved in the collision.\r\n */\r\npublic void playerVersusPellet(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.level.Pellet pellet) {\r\n    this.pointCalculator.consumedAPellet(player, pellet);\r\n    pellet.leaveSquare();\r\n}", "docComment": "Actual case of player consuming a pellet.\r\n\r\n@param player\r\n\t\tThe player involved in the collision.\r\n@param pellet\r\n\t\tThe pellet involved in the collision.\r\n", "metaSrc": "source code", "description": "Updates player's score by adding points earned from consuming a pellet and removes the pellet from its square.", "returns": "", "reason": "This method is part of the Domain Layer as it handles the business logic related to player consumption of pellets and updates the game state accordingly.", "howToUse": "Call this method when a player consumes a pellet. It will update the player's score and remove the pellet from its square.", "howItWorks": "The method calls `consumedAPellet` on the `pointCalculator` to update the player's score, then calls `leaveSquare` on the pellet to remove it from its current square.", "assertions": {"preConditions": ["A valid `Player` and `Pellet` object are provided."], "postConditions": ["The player's score is updated by adding points earned from consuming the pellet.", "The pellet is removed from its current square."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft", "labels": ["Container"], "properties": {"simpleName": "tudelft", "qualifiedName": "nl.tudelft", "kind": "package", "metaSrc": "source code", "description": "Manages game-related operations, including parsing maps, creating levels, and handling player movements.", "layer": "Service Layer", "title": "Game Management Layer", "keywords": ["game", "operations", "map", "level", "player"]}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite", "labels": ["Structure"], "properties": {"docComment": "Visual representation of some object.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Sprite", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite", "kind": "interface", "metaSrc": "source code", "description": "The `Sprite` interface is responsible for defining the basic operations and properties that all sprite objects in the Pacman game must implement. It provides methods for drawing, measuring dimensions, splitting into smaller sprites, and handling requests to split regions.", "layer": "Domain Layer", "roleStereotype": "Service Provider", "keywords": ["draw", "measure", "split", "request"], "dependencyProfile": "inbound"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "/**\r\n * Moves the unit into the given direction if possible and handles all\r\n * collisions.\r\n *\r\n * @param unit\r\n * \t\tThe unit to move.\r\n * @param direction\r\n * \t\tThe direction to move the unit in.\r\n */\r\npublic void move(nl.tudelft.jpacman.board.Unit unit, nl.tudelft.jpacman.board.Direction direction) {\r\n    assert unit != null;\r\n    assert direction != null;\r\n    assert unit.hasSquare();\r\n    if (!this.isInProgress()) {\r\n        return;\r\n    }\r\n    synchronized(this.moveLock) {\r\n        unit.setDirection(direction);\r\n        nl.tudelft.jpacman.board.Square location = unit.getSquare();\r\n        nl.tudelft.jpacman.board.Square destination = location.getSquareAt(direction);\r\n        if (destination.isAccessibleTo(unit)) {\r\n            java.util.List<nl.tudelft.jpacman.board.Unit> occupants = destination.getOccupants();\r\n            unit.occupy(destination);\r\n            for (nl.tudelft.jpacman.board.Unit occupant : occupants) {\r\n                this.collisions.collide(unit, occupant);\r\n            }\r\n        }\r\n        this.updateObservers();\r\n    }\r\n}", "docComment": "Moves the unit into the given direction if possible and handles all\r\ncollisions.\r\n\r\n@param unit\r\n\t\tThe unit to move.\r\n@param direction\r\n\t\tThe direction to move the unit in.\r\n", "metaSrc": "source code", "description": "Moves a unit in the game board based on the given direction and updates the level state.", "returns": "", "reason": "This method is part of the Domain Layer as it handles the game logic and state updates for moving units on a board.", "howToUse": "Call this method with a Unit object and a Direction to move the unit in that direction. Ensure the level is in progress before calling this method.", "howItWorks": "The method first checks if the unit has a square, if the level is in progress, and then updates the unit's direction and position on the board. It also handles collisions with other units and updates observers based on the game state.", "assertions": {"preConditions": ["unit != null", "direction != null", "unit.hasSquare()", "this.isInProgress()"], "postConditions": ["The unit's position is updated to the destination square if it is accessible.", "Collisions with other units are handled, and observers are notified of changes."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.Action", "labels": ["Structure"], "properties": {"docComment": "An action that can be executed.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Action", "qualifiedName": "nl.tudelft.jpacman.ui.Action", "kind": "interface", "metaSrc": "source code", "description": "The Action interface in the Pacman game is responsible for defining how actions are performed in the game, which involves moving Pacman and eating pellets. It acts as a controller by directing the flow of actions within the game.", "layer": "Presentation Layer", "roleStereotype": "Controller", "keywords": ["Action", "Pacman", "Game", "Controller"], "dependencyProfile": "hidden"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "qualifiedName": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "kind": "method", "sourceText": "/**\r\n * Adds key events UP, DOWN, LEFT and RIGHT to a game.\r\n *\r\n * @param builder\r\n * \t\tThe {@link PacManUiBuilder} that will provide the UI.\r\n */\r\nprotected void addSinglePlayerKeys(final nl.tudelft.jpacman.ui.PacManUiBuilder builder) {\r\n    builder.addKey(java.awt.event.KeyEvent.VK_UP, this.moveTowardsDirection(nl.tudelft.jpacman.board.Direction.NORTH)).addKey(java.awt.event.KeyEvent.VK_DOWN, this.moveTowardsDirection(nl.tudelft.jpacman.board.Direction.SOUTH)).addKey(java.awt.event.KeyEvent.VK_LEFT, this.moveTowardsDirection(nl.tudelft.jpacman.board.Direction.WEST)).addKey(java.awt.event.KeyEvent.VK_RIGHT, this.moveTowardsDirection(nl.tudelft.jpacman.board.Direction.EAST));\r\n}", "docComment": "Adds key events UP, DOWN, LEFT and RIGHT to a game.\r\n\r\n@param builder\r\n\t\tThe {@link PacManUiBuilder} that will provide the UI.\r\n", "metaSrc": "source code", "description": "Adds key bindings for moving in four directions (up, down, left, right) to the single player's controls in the PacMan game.", "returns": "This method returns the current instance of PacManUiBuilder.", "reason": "The method provides a convenient way to set up key bindings for player movement in the game, which is part of the user interface layer.", "howToUse": "Call this method with an instance of PacManUiBuilder to configure the UI for single-player mode.", "howItWorks": "The method uses the addKey method from the builder object to map specific key codes (up, down, left, right) to actions that move the player in the corresponding direction. The moveTowardsDirection method returns a lambda expression representing the action.", "preConditions": ["A valid instance of PacManUiBuilder is provided."], "postConditions": ["The builder object has been configured with key bindings for single-player movement.", "The returned builder object can be used to further configure other UI elements or actions."], "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.DELAY", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The suggested delay between moves.\r\n */\r\nprivate static final long DELAY = 175L;", "visibility": "private", "simpleName": "DELAY", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.DELAY", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void consumedAPellet(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.level.Pellet pellet) {\r\n    player.addPoints(pellet.getValue());\r\n}", "docComment": "", "metaSrc": "source code", "description": "Adds the point value of a Pellet to the player's score.", "returns": "void", "reason": "This method provides a straightforward way to update the player's score based on the value of the consumed Pellet.", "howToUse": "Call this method with a Player object and a Pellet object as arguments. The Pellet's value will be added to the player's total score.", "howItWorks": "The method retrieves the point value of the Pellet using its `getValue()` method and adds it to the player's current score using the `addPoints(int)` method.", "preConditions": ["A valid Player object must be provided.", "A valid Pellet object must be provided."], "postConditions": ["The player's score should have been updated by the point value of the consumed Pellet."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void collide(nl.tudelft.jpacman.board.Unit mover, nl.tudelft.jpacman.board.Unit movedInto) {\r\n    this.collisions.collide(mover, movedInto);\r\n}", "docComment": "", "metaSrc": "source code", "description": "Handles collisions between two units in the game board.", "returns": "", "reason": "This method is part of the service layer as it orchestrates the collision handling logic between two units in the game board.", "howToUse": "Call this method with two Unit objects to handle collisions between them.", "howItWorks": "The method delegates the collision handling to the `collisions` object, which is assumed to be an instance of a class that handles specific collision behaviors.", "assertions": {"preConditions": ["Both mover and movedInto are valid Unit objects."], "postConditions": ["The collision handling logic is executed based on the types of units involved."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getWidth()", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic int getWidth() {\r\n    assert this.currentSprite() != null;\r\n    return this.currentSprite().getWidth();\r\n}", "docComment": "", "metaSrc": "source code", "description": "Returns the width of the current sprite in an animated sequence.", "returns": "The width of the current sprite as an integer.", "reason": "This method provides a straightforward way to access the width of the current sprite, which is essential for rendering and layout purposes in a Pacman game.", "howToUse": "Call this method on an instance of AnimatedSprite to get its width.", "howItWorks": "The method first checks if the current sprite is not null. If it's not, it retrieves the width of the current sprite using the getWidth() method of the sprite object and returns that value.", "assertions": {"preConditions": ["this.currentSprite() != null"], "postConditions": ["the returned value is an integer representing the width of the current sprite"]}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getPelletSprite()", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The sprite for the\r\n */\r\npublic nl.tudelft.jpacman.sprite.Sprite getPelletSprite() {\r\n    return this.loadSprite(\"/sprite/pellet.png\");\r\n}", "docComment": "\r\n@return The sprite for the\r\n", "metaSrc": "source code", "description": "Loads a pellet sprite from a resource file and caches it if it doesn't exist.", "returns": "A new ImageSprite object representing the loaded pellet sprite.", "reason": "The method provides a convenient way to load and cache pellet sprites for use in the game, ensuring efficient access to images without redundant loading.", "howToUse": "Call `getPelletSprite()` to retrieve a cached or newly loaded pellet sprite.", "howItWorks": "The method uses the `loadSprite` helper method to load the pellet image from a resource file. If the image is not already in the cache, it is added; otherwise, the cached version is returned.", "preConditions": ["The method assumes all sprites are provided and does not throw exceptions.", "The method caches images for efficient access."], "postConditions": ["A new ImageSprite object representing the loaded pellet sprite is returned.", "Images are cached for future use to improve performance."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "nextAiMove()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "kind": "method", "sourceText": "/**\r\n * {@inheritDoc }\r\n *\r\n * <p>\r\n * When the ghosts are not patrolling their home corners, Pinky wants to go\r\n * to the place that is four grid spaces ahead of Pac-Man in the direction\r\n * that Pac-Man is facing. If Pac-Man is facing down, Pinky wants to go to\r\n * the location exactly four spaces below Pac-Man. Moving towards this place\r\n * uses the same logic that Blinky uses to find Pac-Man's exact location.\r\n * Pinky is affected by a targeting bug if Pac-Man is facing up - when he\r\n * moves or faces up, Pinky tries moving towards a point up, and left, four\r\n * spaces.\r\n * </p>\r\n */\r\n@java.lang.Override\r\npublic java.util.Optional<nl.tudelft.jpacman.board.Direction> nextAiMove() {\r\n    assert this.hasSquare();\r\n    nl.tudelft.jpacman.board.Unit player = nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(nl.tudelft.jpacman.level.Player.class, this.getSquare());\r\n    if (player == null) {\r\n        return java.util.Optional.empty();\r\n    }\r\n    assert player.hasSquare();\r\n    nl.tudelft.jpacman.board.Square destination = player.squaresAheadOf(nl.tudelft.jpacman.npc.ghost.Pinky.SQUARES_AHEAD);\r\n    java.util.List<nl.tudelft.jpacman.board.Direction> path = nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(this.getSquare(), destination, this);\r\n    if ((path != null) && (!path.isEmpty())) {\r\n        return java.util.Optional.ofNullable(path.get(0));\r\n    }\r\n    return java.util.Optional.empty();\r\n}", "docComment": "{@inheritDoc }\r\n\r\n<p>\r\nWhen the ghosts are not patrolling their home corners, Pinky wants to go\r\nto the place that is four grid spaces ahead of Pac-Man in the direction\r\nthat Pac-Man is facing. If Pac-Man is facing down, Pinky wants to go to\r\nthe location exactly four spaces below Pac-Man. Moving towards this place\r\nuses the same logic that Blinky uses to find Pac-Man's exact location.\r\nPinky is affected by a targeting bug if Pac-Man is facing up - when he\r\nmoves or faces up, Pinky tries moving towards a point up, and left, four\r\nspaces.\r\n</p>\r\n", "metaSrc": "source code", "description": "Determines the next move for Pinky based on the nearest player's position and calculates the shortest path to that player.", "returns": "A java.util.Optional<nl.tudelft.jpacman.board.Direction> representing the next move for Pinky.", "reason": "This method implements the AI logic for Pinky, a ghost NPC in the Pacman game. It calculates the shortest path to the nearest player and returns the direction to move towards them.", "howToUse": "Call this method on an instance of Pinky to get its next move based on the current state of the game board.", "howItWorks": "The method first checks if Pinky has a square. It then finds the nearest player using the `findNearest` method and calculates the destination by moving ahead in the direction of the player. The shortest path is found from Pinky's current position to the destination using the `shortestPath` method. If a valid path exists, it returns the first direction in the path; otherwise, it returns an empty Optional.", "assertions": {"preConditions": ["this.hasSquare()", "player != null"], "postConditions": ["The returned value is either a non-empty Optional containing a Direction or an empty Optional."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The image size in pixels.\r\n */\r\nprivate static final int SPRITE_SIZE = 16;", "visibility": "private", "simpleName": "SPRITE_SIZE", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.SOUTH", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * South, or down.\r\n */\r\nSOUTH(0, 1)", "visibility": "public", "simpleName": "SOUTH", "qualifiedName": "nl.tudelft.jpacman.board.Direction.SOUTH", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.sprites", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The sprite store containing the ghost sprites.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.PacManSprites sprites;", "visibility": "private", "simpleName": "sprites", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory.sprites", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).0", "labels": ["Variable"], "properties": {"simpleName": "frames", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "Array of sprites representing the animation frames."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.moveLock", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The lock that ensures moves are executed sequential.\r\n */\r\nprivate final java.lang.Object moveLock = new java.lang.Object();", "visibility": "private", "simpleName": "moveLock", "qualifiedName": "nl.tudelft.jpacman.level.Level.moveLock", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "graphics", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The graphics context to draw."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "qualifiedName": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "kind": "method", "sourceText": "/**\r\n * Adds an observer that will be notified when the level is won or lost.\r\n *\r\n * @param observer\r\n * \t\tThe observer that will be notified.\r\n */\r\npublic void addObserver(nl.tudelft.jpacman.level.Level.LevelObserver observer) {\r\n    this.observers.add(observer);\r\n}", "docComment": "Adds an observer that will be notified when the level is won or lost.\r\n\r\n@param observer\r\n\t\tThe observer that will be notified.\r\n", "metaSrc": "source code", "description": "Adds an observer to the list of observers for level updates.", "returns": "", "reason": "This method is part of the Service Layer as it manages the level's observers, which are responsible for receiving updates about changes in the game state.", "howToUse": "To use this method, create an instance of LevelObserver and pass it to addObserver().", "howItWorks": "The method adds the observer to a list of observers stored in the Level class. This allows other parts of the application to be notified when certain events occur within the level.", "assertions": {"preConditions": ["observer is not null"], "postConditions": ["observer is added to the list of observers"]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0", "labels": ["Variable"], "properties": {"simpleName": "spriteMap", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The sprites for every direction."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.FRAME_INTERVAL", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The desired frame rate interval for the graphics in milliseconds, 40\r\n * being 25 fps.\r\n */\r\nprivate static final int FRAME_INTERVAL = 40;", "visibility": "private", "simpleName": "FRAME_INTERVAL", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI.FRAME_INTERVAL", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.nextFrame()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "nextFrame()", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI.nextFrame()", "kind": "method", "sourceText": "/**\r\n * Draws the next frame, i.e. refreshes the scores and game.\r\n */\r\nprivate void nextFrame() {\r\n    this.boardPanel.repaint();\r\n    this.scorePanel.refresh();\r\n}", "docComment": "Draws the next frame, i.e. refreshes the scores and game.\r\n", "metaSrc": "source code", "description": "Updates the score panel to reflect player scores and death status.", "returns": "", "reason": "The method updates the user interface by refreshing the score panel, which is part of the presentation layer.", "howToUse": "Call this method when you need to update the score display in the game.", "howItWorks": "The method calls `boardPanel.repaint()` and `scorePanel.refresh()`, which are methods that update the respective UI components.", "preConditions": [], "postConditions": [], "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit", "labels": ["Structure"], "properties": {"docComment": "A unit that can be placed on a {@link Square}.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Unit", "qualifiedName": "nl.tudelft.jpacman.board.Unit", "kind": "abstract class", "metaSrc": "source code", "description": "The abstract class is responsible for managing the state and behavior of game entities, providing common functionality for all units in the game.", "layer": "Domain Layer", "roleStereotype": "Controller", "keywords": ["game", "entity", "state", "behavior", "common", "functionality"], "dependencyProfile": "inbound"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidee", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that is being collided with."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.image", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Internal image.\r\n */\r\nprivate final java.awt.Image image;", "visibility": "private", "simpleName": "image", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.image", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String).0", "labels": ["Variable"], "properties": {"simpleName": "resource", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The path to the resource file containing the sprite image."}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.clazz", "labels": ["Variable"], "properties": {"sourceText": "private static java.lang.Class clazz = null;", "visibility": "private", "simpleName": "clazz", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculatorLoader.clazz", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "start()", "qualifiedName": "nl.tudelft.jpacman.game.Game.start()", "kind": "method", "sourceText": "/**\r\n * Starts or resumes the game.\r\n */\r\npublic void start() {\r\n    synchronized(this.progressLock) {\r\n        if (this.isInProgress()) {\r\n            return;\r\n        }\r\n        if (this.getLevel().isAnyPlayerAlive() && (this.getLevel().remainingPellets() > 0)) {\r\n            this.inProgress = true;\r\n            this.getLevel().addObserver(this);\r\n            this.getLevel().start();\r\n        }\r\n    }\r\n}", "docComment": "Starts or resumes the game.\r\n", "metaSrc": "source code", "description": "Starts the game if it's not already in progress and there are alive players and pellets left.", "returns": "", "reason": "The method manages the game state by checking conditions before starting the level, ensuring that the game is only started when necessary.", "howToUse": "Call this method to start the game if it's not already in progress.", "howItWorks": "The method checks if the game is in progress and if there are alive players and pellets left. If both conditions are met, it sets the game as in progress, adds itself as an observer to the level, and starts the level.", "assertions": {"preConditions": ["Game is not already in progress", "There are alive players", "There are remaining pellets"], "postConditions": ["Game is set as in progress", "Observer added to level", "Level started"]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new collision handler.\r\n *\r\n * @param handler\r\n * \t\tThe symmetric handler for this collision.\r\n */\r\nInverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<C2, C1> handler) {\r\n    super();\r\n    this.handler = handler;\r\n}", "docComment": "Creates a new collision handler.\r\n\r\n@param handler\r\n\t\tThe symmetric handler for this collision.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int)", "labels": ["Constructor"], "properties": {"visibility": "private", "simpleName": "<init>(int,int)", "qualifiedName": "nl.tudelft.jpacman.board.Direction(int,int)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new Direction with the given parameters.\r\n *\r\n * @param deltaX\r\n * \t\tThe delta x (width difference) to an element in the direction\r\n * \t\tin a matrix with 0,0 (x,y) as its top-left element.\r\n * @param deltaY\r\n * \t\tThe delta y (height difference) to an element in the direction\r\n * \t\tin a matrix with 0,0 (x,y) as its top-left element.\r\n */\r\nDirection(int deltaX, int deltaY) {\r\n    super();\r\n    this.deltaX = deltaX;\r\n    this.deltaY = deltaY;\r\n}", "docComment": "Creates a new Direction with the given parameters.\r\n\r\n@param deltaX\r\n\t\tThe delta x (width difference) to an element in the direction\r\n\t\tin a matrix with 0,0 (x,y) as its top-left element.\r\n@param deltaY\r\n\t\tThe delta y (height difference) to an element in the direction\r\n\t\tin a matrix with 0,0 (x,y) as its top-left element.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.points.PointCalculator)", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)", "kind": "constructor", "sourceText": "/**\r\n * Create a simple player-based collision map, informing the\r\n * point calculator about points to be added.\r\n *\r\n * @param pointCalculator\r\n * \t\tStrategy for calculating points.\r\n */\r\npublic DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator pointCalculator) {\r\n    super();\r\n    this.pointCalculator = pointCalculator;\r\n}", "docComment": "Create a simple player-based collision map, informing the\r\npoint calculator about points to be added.\r\n\r\n@param pointCalculator\r\n\t\tStrategy for calculating points.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getSpriteStore()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The default {@link PacManSprites}.\r\n */\r\nprotected nl.tudelft.jpacman.sprite.PacManSprites getSpriteStore() {\r\n    return nl.tudelft.jpacman.Launcher.SPRITE_STORE;\r\n}", "docComment": "\r\n@return The default {@link PacManSprites}.\r\n", "metaSrc": "source code", "description": "Returns the singleton instance of PacManSprites class.", "returns": "nl.tudelft.jpacman.sprite.PacManSprites", "reason": "The method provides a way to access the shared resource of PacMan sprites, ensuring consistent and efficient usage across the application.", "howToUse": "Call `getSpriteStore()` to retrieve the singleton instance of PacManSprites.", "howItWorks": "The method returns the static field SPRITE_STORE which holds the single instance of PacManSprites. This ensures that only one instance is created and reused throughout the application.", "preConditions": [], "postConditions": ["Returns a non-null instance of PacManSprites."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game", "labels": ["Structure"], "properties": {"docComment": "A basic implementation of a Pac-Man game.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Game", "qualifiedName": "nl.tudelft.jpacman.game.Game", "kind": "abstract class", "metaSrc": "source code", "description": "The abstract class is responsible for managing the game state, providing methods to interact with the game board and players, and handling events such as starting and stopping the game.", "layer": "Service Layer", "roleStereotype": "Coordinator", "keywords": ["game", "state", "interaction", "events"], "dependencyProfile": "transit"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void collide(nl.tudelft.jpacman.board.Unit mover, nl.tudelft.jpacman.board.Unit collidedOn) {\r\n    if (mover instanceof nl.tudelft.jpacman.level.Player) {\r\n        this.playerColliding(((nl.tudelft.jpacman.level.Player) (mover)), collidedOn);\r\n    } else if (mover instanceof nl.tudelft.jpacman.npc.Ghost) {\r\n        this.ghostColliding(((nl.tudelft.jpacman.npc.Ghost) (mover)), collidedOn);\r\n    } else if (mover instanceof nl.tudelft.jpacman.level.Pellet) {\r\n        this.pelletColliding(((nl.tudelft.jpacman.level.Pellet) (mover)), collidedOn);\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Handles collisions between player units (Pellets, Ghosts) and updates game state accordingly.", "returns": "", "reason": "This method manages the game's collision logic, which is a core part of the domain layer where business rules and state transitions are defined.", "howToUse": "Call this method when a collision between a player unit and another unit occurs. It will determine the appropriate action based on the types of units involved (Pellet or Ghost) and update the game state accordingly.", "howItWorks": "The method checks the type of the mover and collidedOn units using instanceof checks. Depending on their types, it calls the corresponding collision handling method (`pelletColliding`, `ghostColliding`, or `playerColliding`). These methods update the player's score, set the player as dead, or handle pellet consumption.", "assertions": {"preConditions": ["The mover and collidedOn units are valid instances of Unit."], "postConditions": ["The game state is updated based on the collision type (score update, death, pellet consumption)."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "labels": ["Variable"], "properties": {"simpleName": "collidee", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The collidee (unit that was moved into) type."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.moveInterval", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The base move interval of the ghost.\r\n */\r\nprivate final int moveInterval;", "visibility": "private", "simpleName": "moveInterval", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.moveInterval", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int).1", "labels": ["Variable"], "properties": {"simpleName": "deltaY", "qualifiedName": "nl.tudelft.jpacman.board.Direction(int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.game", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The game to display.\r\n */\r\nprivate final nl.tudelft.jpacman.game.Game game;", "visibility": "private", "simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.game", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.sprites", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The sprite store providing the sprites for the background.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.PacManSprites sprites;", "visibility": "private", "simpleName": "sprites", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory.sprites", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "movedInto", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that is already on the square that is being invaded."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player involved in the collision."}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.PELLET_VALUE", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The default value of a pellet.\r\n */\r\nprivate static final int PELLET_VALUE = 10;", "visibility": "private", "simpleName": "PELLET_VALUE", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.PELLET_VALUE", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List).0", "labels": ["Variable"], "properties": {"simpleName": "text", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A list of strings representing the lines of the map."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.observers", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The objects observing this level.\r\n */\r\nprivate final java.util.Set<nl.tudelft.jpacman.level.Level.LevelObserver> observers;", "visibility": "private", "simpleName": "observers", "qualifiedName": "nl.tudelft.jpacman.level.Level.observers", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator", "labels": ["Structure"], "properties": {"docComment": "The responsibility of the point calculator is to update the points\r\nof the player when certain activities happen.\r\nDifferent calculation strategies can be employed,\r\ngiving rise to different types of games, for example at different levels.\r\n", "simpleName": "PointCalculator", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator", "kind": "interface", "metaSrc": "source code", "description": "The PointCalculator interface is responsible for managing and updating player scores based on various game events such as collisions with ghosts, consumption of pellets, and successful movements.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["point calculator", "player score", "collision", "pellet", "movement"], "dependencyProfile": "inbound"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).1", "labels": ["Variable"], "properties": {"simpleName": "ghostFactory", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.direction", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The direction this unit is facing.\r\n */\r\nprivate nl.tudelft.jpacman.board.Direction direction;", "visibility": "private", "simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.board.Unit.direction", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeGame()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "makeGame()", "qualifiedName": "nl.tudelft.jpacman.Launcher.makeGame()", "kind": "method", "sourceText": "/**\r\n * Creates a new game using the level from {@link #makeLevel()}.\r\n *\r\n * @return a new Game.\r\n */\r\npublic nl.tudelft.jpacman.game.Game makeGame() {\r\n    nl.tudelft.jpacman.game.GameFactory gf = this.getGameFactory();\r\n    nl.tudelft.jpacman.level.Level level = this.makeLevel();\r\n    this.game = gf.createSinglePlayerGame(level, this.loadPointCalculator());\r\n    return this.game;\r\n}", "docComment": "Creates a new game using the level from {@link #makeLevel()}.\r\n\r\n@return a new Game.\r\n", "metaSrc": "source code", "description": "Creates a new single-player game instance for Pacman using a specified level and point calculator.", "returns": "A new SinglePlayerGame instance representing the Pacman game.", "reason": "This method orchestrates the creation of a single-player game by initializing the necessary components and returning the final game instance.", "howToUse": "To use this method, create an instance of Launcher and call makeGame() to start a new game.", "howItWorks": "The method first retrieves a GameFactory using getGameFactory(), then creates a level using makeLevel(). It uses these components to create a single-player game with the specified point calculator and returns the resulting game instance.", "assertions": {"preConditions": ["A Launcher object is instantiated."], "postConditions": ["A SinglePlayerGame instance is returned representing the Pacman game."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The size (in pixels) of a square on the board. The initial size of this\r\n * panel will scale to fit a board with square of this size.\r\n */\r\nprivate static final int SQUARE_SIZE = 16;", "visibility": "private", "simpleName": "SQUARE_SIZE", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.levelMap", "labels": ["Variable"], "properties": {"sourceText": "private java.lang.String levelMap = nl.tudelft.jpacman.Launcher.DEFAULT_MAP;", "visibility": "private", "simpleName": "levelMap", "qualifiedName": "nl.tudelft.jpacman.Launcher.levelMap", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "labels": ["Constructor"], "properties": {"visibility": "protected", "simpleName": "<init>(java.util.Map,int,int)", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new ghost.\r\n *\r\n * @param spriteMap\r\n * \t\tThe sprites for every direction.\r\n * @param moveInterval\r\n * \t\tThe base interval of movement.\r\n * @param intervalVariation\r\n * \t\tThe variation of the interval.\r\n */\r\nprotected Ghost(java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> spriteMap, int moveInterval, int intervalVariation) {\r\n    super();\r\n    this.sprites = spriteMap;\r\n    this.intervalVariation = intervalVariation;\r\n    this.moveInterval = moveInterval;\r\n}", "docComment": "Creates a new ghost.\r\n\r\n@param spriteMap\r\n\t\tThe sprites for every direction.\r\n@param moveInterval\r\n\t\tThe base interval of movement.\r\n@param intervalVariation\r\n\t\tThe variation of the interval.\r\n", "metaSrc": "source code", "description": "Initializes a new Ghost instance with specified sprite map, move interval, and interval variation.", "returns": "A newly created Ghost instance.", "reason": "This method initializes a new Ghost object with its sprite map, move interval, and interval variation, which are essential properties for the ghost's behavior and appearance.", "howToUse": "To use this method, create an instance of `Ghost` by providing a map of directions to their corresponding sprites, along with the base and variation intervals.", "howItWorks": "The method initializes the Ghost object by setting its sprite map, move interval, and interval variation. It then calls the superclass constructor to initialize the Unit class.", "assertions": {"preConditions": ["A valid `Map` of directions to sprites is provided.", "Both `moveInterval` and `intervalVariation` are non-negative integers."], "postConditions": ["The Ghost object is created with the specified properties.", "The superclass constructor is called successfully."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "build(nl.tudelft.jpacman.game.Game)", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "kind": "method", "sourceText": "/**\r\n * Creates a new Pac-Man UI with the set keys and buttons.\r\n *\r\n * @param game\r\n * \t\tThe game to build the UI for.\r\n * @return A new Pac-Man UI with the set keys and buttons.\r\n */\r\npublic nl.tudelft.jpacman.ui.PacManUI build(final nl.tudelft.jpacman.game.Game game) {\r\n    assert game != null;\r\n    if (this.defaultButtons) {\r\n        this.addStartButton(game);\r\n        this.addStopButton(game);\r\n    }\r\n    return new nl.tudelft.jpacman.ui.PacManUI(game, this.buttons, this.keyMappings, this.scoreFormatter);\r\n}", "docComment": "Creates a new Pac-Man UI with the set keys and buttons.\r\n\r\n@param game\r\n\t\tThe game to build the UI for.\r\n@return A new Pac-Man UI with the set keys and buttons.\r\n", "metaSrc": "source code", "description": "Builds a PacMan UI for a given game, adding start and stop buttons if configured.", "returns": "A new instance of nl.tudelft.jpacman.ui.PacManUI.", "reason": "This method is part of the Presentation Layer as it manages the user interface and adds buttons to control the game.", "howToUse": "Call this method with a valid Game object to create a PacMan UI that includes start and stop buttons if configured.", "howItWorks": "The method first checks if default buttons are enabled. If so, it adds start and stop buttons to the game using the addStartButton and addStopButton methods. It then creates and returns a new instance of PacManUI with the provided game, buttons, key mappings, and score formatter.", "assertions": {"preConditions": ["game is not null"], "postConditions": ["a new instance of PacManUI is returned"]}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman", "labels": ["Container"], "properties": {"simpleName": "jpacman", "qualifiedName": "nl.tudelft.jpacman", "kind": "package", "metaSrc": "source code", "description": "Manages game-related operations, including parsing maps, creating levels, and handling player movements.", "layer": "Service Layer", "title": "Service Layer", "keywords": ["game", "operations", "map", "level", "player"]}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "split(int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite split(int x, int y, int width, int height) {\r\n    return new nl.tudelft.jpacman.sprite.EmptySprite();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level", "labels": ["Container"], "properties": {"simpleName": "level", "qualifiedName": "nl.tudelft.jpacman.level", "kind": "package", "metaSrc": "source code", "description": "Manages game levels, player interactions, and collision handling in a Pac-Man game.", "layer": "Service Layer", "title": "Game Level Management", "keywords": ["game", "levels", "player", "interactions", "collision"]}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.INTERVAL_VARIATION", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The variation in intervals, this makes the ghosts look more dynamic and\r\n * less predictable.\r\n */\r\nprivate static final int INTERVAL_VARIATION = 50;", "visibility": "private", "simpleName": "INTERVAL_VARIATION", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky.INTERVAL_VARIATION", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "loadClassFromFile()", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "kind": "method", "sourceText": "private java.lang.Class loadClassFromFile() throws java.io.IOException, java.lang.ClassNotFoundException {\r\n    java.lang.String strategyToLoad = this.getCalculatorClassName();\r\n    if (\"DefaultPointCalculator\".equals(strategyToLoad)) {\r\n        return nl.tudelft.jpacman.points.DefaultPointCalculator.class;\r\n    }\r\n    java.net.URL[] urls = new java.net.URL[]{ this.getClass().getClassLoader().getResource(\"scoreplugins/\") };\r\n    try (java.net.URLClassLoader classLoader = new java.net.URLClassLoader(urls, this.getClass().getClassLoader())) {\r\n        return classLoader.loadClass(strategyToLoad);\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Loads a point calculator class from a specified file path or uses a default if not found.", "returns": "The loaded Class object for the point calculator.", "reason": "This method is part of the Service Layer as it orchestrates the loading of a specific class based on configuration settings, which is a core business operation in a Pacman game implementation.", "howToUse": "Call this method to retrieve the appropriate PointCalculator class based on its name or default if not specified.", "howItWorks": "The method first checks for a custom class name from a properties file. If none is found, it uses a default class. It then loads the class using a URLClassLoader that includes the scoreplugins directory in its search path.", "assertions": {"preConditions": ["A valid ClassLoader instance is available.", "The method has access to the necessary resources and configurations."], "postConditions": ["The returned Class object is either the loaded custom class or the default class if not found."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.board", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The grid of squares with board[x][y] being the square at column x, row y.\r\n */\r\nprivate final nl.tudelft.jpacman.board.Square[][] board;", "visibility": "private", "simpleName": "board", "qualifiedName": "nl.tudelft.jpacman.board.Board.board", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).0", "labels": ["Variable"], "properties": {"simpleName": "board", "qualifiedName": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).0", "labels": ["Variable"], "properties": {"simpleName": "board", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The board to render."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "qualifiedName": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "kind": "method", "sourceText": "/**\r\n * Removes an observer if it was listed.\r\n *\r\n * @param observer\r\n * \t\tThe observer to be removed.\r\n */\r\npublic void removeObserver(nl.tudelft.jpacman.level.Level.LevelObserver observer) {\r\n    this.observers.remove(observer);\r\n}", "docComment": "Removes an observer if it was listed.\r\n\r\n@param observer\r\n\t\tThe observer to be removed.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "loadSpriteFromResource(java.lang.String)", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "kind": "method", "sourceText": "/**\r\n * Loads a sprite from a resource on the class path.\r\n *\r\n * @param resource\r\n * \t\tThe resource path.\r\n * @return A new sprite for the resource.\r\n * @throws IOException\r\n * \t\tWhen the resource could not be loaded.\r\n */\r\n@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE\", justification = \"false positive in java 11\")\r\nprivate nl.tudelft.jpacman.sprite.Sprite loadSpriteFromResource(java.lang.String resource) throws java.io.IOException {\r\n    try (java.io.InputStream input = nl.tudelft.jpacman.sprite.SpriteStore.class.getResourceAsStream(resource)) {\r\n        if (input == null) {\r\n            throw new java.io.IOException((\"Unable to load \" + resource) + \", resource does not exist.\");\r\n        }\r\n        java.awt.image.BufferedImage image = javax.imageio.ImageIO.read(input);\r\n        return new nl.tudelft.jpacman.sprite.ImageSprite(image);\r\n    }\r\n}", "docComment": "Loads a sprite from a resource on the class path.\r\n\r\n@param resource\r\n\t\tThe resource path.\r\n@return A new sprite for the resource.\r\n@throws IOException\r\n\t\tWhen the resource could not be loaded.\r\n", "metaSrc": "source code", "description": "Loads a sprite from a resource file and returns an ImageSprite.", "returns": "A new ImageSprite object representing the loaded sprite.", "reason": "This method is part of the Domain Layer as it handles the loading and representation of game sprites, which are essential for the game's visual elements.", "howToUse": "Call this method with the path to a resource file containing an image. The method will return an ImageSprite object that can be used in the game.", "howItWorks": "The method uses Java's `getResourceAsStream` to load the sprite image from the specified resource path. It checks if the input stream is null and throws an IOException if it is, indicating that the resource does not exist. If the stream is valid, it reads the image using `ImageIO.read`, creates a new ImageSprite object with the loaded image, and returns it.", "preConditions": ["The method expects a valid string representing the path to a resource file containing an image."], "postConditions": ["If successful, the method returns a new ImageSprite object representing the loaded sprite. If the resource does not exist, an IOException is thrown."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.GHOSTS", "labels": ["Variable"], "properties": {"sourceText": "private static final int GHOSTS = 4;", "visibility": "private", "simpleName": "GHOSTS", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.GHOSTS", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "unit", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.ghostIndex", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Used to cycle through the various ghost types.\r\n */\r\nprivate int ghostIndex;", "visibility": "private", "simpleName": "ghostIndex", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.ghostIndex", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).3", "labels": ["Variable"], "properties": {"simpleName": "collisionMap", "qualifiedName": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.getLevel()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getLevel()", "qualifiedName": "nl.tudelft.jpacman.game.Game.getLevel()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The level currently being played.\r\n */\r\npublic abstract nl.tudelft.jpacman.level.Level getLevel();", "docComment": "\r\n@return The level currently being played.\r\n", "metaSrc": "source code", "description": "Returns the current level in the game.", "returns": "The current Level object representing the current state of the game.", "reason": "This method provides access to the current level, which is a fundamental part of the game's state and progression.", "howToUse": "To use this method, simply call it on an instance of Game. It will return the current level object.", "howItWorks": "The method returns the Level object that has been set as the current level in the game. This is typically done by the game's logic when a new level is loaded or when the player progresses to the next level.", "preConditions": ["An instance of Game must be created and initialized before calling this method."], "postConditions": ["The returned Level object represents the current state of the game, including all entities, walls, pellets, etc.", "The method does not modify any game state or data structures."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "collider", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that is colliding."}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The direction in which the player moved."}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).1", "labels": ["Variable"], "properties": {"simpleName": "boardFactory", "qualifiedName": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The x start coordinate."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int).0", "labels": ["Variable"], "properties": {"simpleName": "deltaX", "qualifiedName": "nl.tudelft.jpacman.board.Direction(int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).5", "labels": ["Variable"], "properties": {"simpleName": "startPositions", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).5", "kind": "parameter", "parameterPosition": 5, "metaSrc": "source code", "description": "List of all start positions that were added to the map."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "default", "simpleName": "put(nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Adds a new occupant to this square.\r\n *\r\n * @param occupant\r\n * \t\tThe unit to occupy this square.\r\n */\r\nvoid put(nl.tudelft.jpacman.board.Unit occupant) {\r\n    assert occupant != null;\r\n    assert !this.occupants.contains(occupant);\r\n    this.occupants.add(occupant);\r\n}", "docComment": "Adds a new occupant to this square.\r\n\r\n@param occupant\r\n\t\tThe unit to occupy this square.\r\n", "metaSrc": "source code", "description": "Adds an occupant to the square, asserting that the occupant is not null and not already present.", "returns": "", "reason": "This method ensures that only valid units are placed on squares, maintaining the integrity of the game board.", "howToUse": "Call this method with a Unit object to add it to a Square. Ensure the unit is not null and not already present on the square.", "howItWorks": "The method first checks if the occupant is null or already in the occupants list. If both conditions are met, it adds the occupant to the list.", "assertions": {"preConditions": ["occupant != null", "!this.occupants.contains(occupant)"], "postConditions": ["this.occupants.contains(occupant)"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createBlinky()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "kind": "method", "sourceText": "/**\r\n * Creates a new Blinky / Shadow, the red Ghost.\r\n *\r\n * @see Blinky\r\n * @return A new Blinky.\r\n */\r\npublic nl.tudelft.jpacman.npc.Ghost createBlinky() {\r\n    return new nl.tudelft.jpacman.npc.ghost.Blinky(this.sprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor.RED));\r\n}", "docComment": "Creates a new Blinky / Shadow, the red Ghost.\r\n\r\n@see Blinky\r\n@return A new Blinky.\r\n", "metaSrc": "source code", "description": "Creates a Blinky ghost using specified sprites.", "returns": "A new instance of nl.tudelft.jpacman.npc.ghost.Blinky.", "reason": "The method is part of the domain layer as it creates a specific type of ghost based on provided sprites.", "howToUse": "Call this method with an array of animated sprites to create a Blinky ghost.", "howItWorks": "The method retrieves the appropriate sprite for the Blinky ghost using the specified color and returns a new instance of Blinky initialized with these sprites.", "preConditions": ["sprites must be non-null and contain at least one element."], "postConditions": ["A new Blinky ghost is created with the provided sprites."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).0", "labels": ["Variable"], "properties": {"simpleName": "ghosts", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A list of ghosts."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][]).0", "labels": ["Variable"], "properties": {"simpleName": "grid", "qualifiedName": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][]).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A 2D array of Square objects representing the game board."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).3", "labels": ["Variable"], "properties": {"simpleName": "loop", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "Whether the animation should loop or not."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory", "labels": ["Structure"], "properties": {"docComment": "Factory that creates Players.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "PlayerFactory", "qualifiedName": "nl.tudelft.jpacman.level.PlayerFactory", "kind": "class", "metaSrc": "source code", "description": "The PlayerFactory class is responsible for creating and managing PacMan players in the game, including initializing their sprites and death animation.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["PlayerFactory", "PacMan", "SpriteFactory", "GameEntity"], "dependencyProfile": "transit"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getCalculatorClassName()", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "kind": "method", "sourceText": "private java.lang.String getCalculatorClassName() throws java.io.IOException {\r\n    java.util.Properties properties = new java.util.Properties();\r\n    properties.load(this.getClass().getClassLoader().getResourceAsStream(\"scorecalc.properties\"));\r\n    return properties.getProperty(\"scorecalculator.name\");\r\n}", "docComment": "", "metaSrc": "source code", "description": "Loads the class name for a point calculator from a properties file.", "returns": "The class name of the point calculator as a string.", "reason": "This method is part of the Service Layer, responsible for orchestrating domain operations and connecting UI events with domain logic.", "howToUse": "Call this method to retrieve the class name of the point calculator from the 'scorecalc.properties' file.", "howItWorks": "The method reads a properties file using the class loader, retrieves the value associated with the key 'scorecalculator.name', and returns it as a string.", "preConditions": ["The 'scorecalc.properties' file exists in the classpath.", "The 'scorecalculator.name' property is defined in the file."], "postConditions": ["The method returns the correct class name of the point calculator.", "An IOException is thrown if there is an error reading the properties file or accessing its contents."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The height of the region to split."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "labels": ["Variable"], "properties": {"simpleName": "symetric", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "Indicates whether to add a handler for the reverse collision (collidee colliding with collider)."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite", "labels": ["Structure"], "properties": {"docComment": "Basic implementation of a Sprite, it merely consists of a static image.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "ImageSprite", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite", "kind": "class", "metaSrc": "source code", "description": "The ImageSprite class is responsible for managing and rendering images in the game, providing methods to create, split, and check image boundaries.", "layer": "Domain Layer", "roleStereotype": "Information Holder", "keywords": ["image management", "sprite rendering", "image manipulation"], "dependencyProfile": "hidden"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "default", "simpleName": "remove(nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Removes the unit from this square if it was present.\r\n *\r\n * @param occupant\r\n * \t\tThe unit to be removed from this square.\r\n */\r\nvoid remove(nl.tudelft.jpacman.board.Unit occupant) {\r\n    assert occupant != null;\r\n    this.occupants.remove(occupant);\r\n}", "docComment": "Removes the unit from this square if it was present.\r\n\r\n@param occupant\r\n\t\tThe unit to be removed from this square.\r\n", "metaSrc": "source code", "description": "Removes an occupant from the square's list of occupants.", "returns": "", "reason": "This method is part of the Domain Layer as it manages the domain logic related to removing an occupant from a square.", "howToUse": "Call this method with the Unit object you want to remove from the square.", "howItWorks": "The method first checks if the occupant is not null, then removes it from the list of occupants using the `remove` method of the `occupants` collection.", "assertions": {"preConditions": ["occupant != null"], "postConditions": ["occupant is removed from the square's list of occupants"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).1", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The direction in which the neighbour is connected."}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser", "labels": ["Structure"], "properties": {"docComment": "Creates new {@link Level}s from text representations.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "MapParser", "qualifiedName": "nl.tudelft.jpacman.level.MapParser", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for managing and parsing game maps, including initializing ghosts and start positions.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["game", "map", "parser", "ghosts", "start", "positions"], "dependencyProfile": "transit"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "kind": "method", "sourceText": "/**\r\n * Adds a collision interaction to this collection.\r\n *\r\n * @param <C1>\r\n * \t\tThe collider type.\r\n * @param <C2>\r\n * \t\tThe collidee (unit that was moved into) type.\r\n * @param collider\r\n * \t\tThe collider type.\r\n * @param collidee\r\n * \t\tThe collidee type.\r\n * @param symetric\r\n * \t\t<code>true</code> if this collision is used for both\r\n * \t\tC1 against C2 and vice versa;\r\n * \t\t<code>false</code> if only for C1 against C2.\r\n * @param handler\r\n * \t\tThe handler that handles the collision.\r\n */\r\npublic <C1 extends nl.tudelft.jpacman.board.Unit, C2 extends nl.tudelft.jpacman.board.Unit> void onCollision(java.lang.Class<C1> collider, java.lang.Class<C2> collidee, boolean symetric, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<C1, C2> handler) {\r\n    this.addHandler(collider, collidee, handler);\r\n    if (symetric) {\r\n        this.addHandler(collidee, collider, new nl.tudelft.jpacman.level.CollisionInteractionMap.InverseCollisionHandler<C2, C1>(handler));\r\n    }\r\n}", "docComment": "Adds a collision interaction to this collection.\r\n\r\n@param <C1>\r\n\t\tThe collider type.\r\n@param <C2>\r\n\t\tThe collidee (unit that was moved into) type.\r\n@param collider\r\n\t\tThe collider type.\r\n@param collidee\r\n\t\tThe collidee type.\r\n@param symetric\r\n\t\t<code>true</code> if this collision is used for both\r\n\t\tC1 against C2 and vice versa;\r\n\t\t<code>false</code> if only for C1 against C2.\r\n@param handler\r\n\t\tThe handler that handles the collision.\r\n", "metaSrc": "source code", "description": "Adds collision handlers for unit pairs and their inverses, allowing for bidirectional collision detection.", "returns": "void", "reason": "This method provides a way to manage collision interactions in the game by adding handlers for both direct and reverse collisions.", "howToUse": "Call this method with appropriate unit types and a handler that defines how to handle collisions between those units. If symetric is true, it will also add a handler for the reverse collision.", "howItWorks": "The method first adds a handler for the specified collider-collidee pair using `addHandler`. If symetric is true, it then adds an inverse handler for the collidee-collider pair using `InverseCollisionHandler`.", "assertions": {"preConditions": ["collider and collidee are valid unit types", "handler is a valid collision handler"], "postConditions": ["collision handlers are added to the CollisionInteractionMap for both collider-collidee and collidee-collider pairs if symetric is true"]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSprite()", "qualifiedName": "nl.tudelft.jpacman.board.Unit.getSprite()", "kind": "method", "sourceText": "/**\r\n * Returns the sprite of this unit.\r\n *\r\n * @return The sprite of this unit.\r\n */\r\npublic abstract nl.tudelft.jpacman.sprite.Sprite getSprite();", "docComment": "Returns the sprite of this unit.\r\n\r\n@return The sprite of this unit.\r\n", "metaSrc": "source code", "description": "Returns the sprite representation of the unit.", "returns": "A Sprite object representing the visual appearance of the unit.", "reason": "The method provides a way to access the graphical representation of a game entity, which is essential for rendering and displaying units on the game board.", "howToUse": "Call this method on an instance of a Unit subclass to retrieve its sprite.", "howItWorks": "The method returns the sprite object associated with the unit. This object contains information about the image file or resource used to render the unit's appearance.", "preConditions": [], "postConditions": ["The returned Sprite object is not null and represents the visual representation of the unit."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.CLYDE", "labels": ["Variable"], "properties": {"sourceText": "private static final int CLYDE = 3;", "visibility": "private", "simpleName": "CLYDE", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.CLYDE", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "pellet", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The pellet involved in the collision."}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.nextAiMove()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "nextAiMove()", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.nextAiMove()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic java.util.Optional<nl.tudelft.jpacman.board.Direction> nextAiMove() {\r\n    return java.util.Optional.empty();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).4", "labels": ["Variable"], "properties": {"simpleName": "ghosts", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code", "description": "List of all ghosts that were added to the map."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).1", "labels": ["Variable"], "properties": {"simpleName": "key", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The class to find in the map."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.PINK", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Speedy, a.k.a. Pinky.\r\n */\r\nPINK()", "visibility": "public", "simpleName": "PINK", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostColor.PINK", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "graphics", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The graphics context for drawing the square and its contents."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).0", "labels": ["Variable"], "properties": {"simpleName": "points", "qualifiedName": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The number of points associated with this pellet."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "labels": ["Structure"], "properties": {"docComment": "Handles the collision between two colliding parties.\r\n\r\n@author Michael de Jong\r\n@param <C1>\r\n\t\tThe collider type.\r\n@param <C2>\r\n\t\tThe collidee type.\r\n", "simpleName": "CollisionHandler", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "kind": "interface", "metaSrc": "source code", "description": "Handles collisions between units in the game board, updating the game state accordingly.", "layer": "Domain Layer", "roleStereotype": "Service Provider", "keywords": ["collision", "handler", "units", "game", "board"], "dependencyProfile": "inbound"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.GHOST_ANIMATION_FRAMES", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The amount of frames in the ghost animation.\r\n */\r\nprivate static final int GHOST_ANIMATION_FRAMES = 2;", "visibility": "private", "simpleName": "GHOST_ANIMATION_FRAMES", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.GHOST_ANIMATION_FRAMES", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.getBoardCreator()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getBoardCreator()", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.getBoardCreator()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return the BoardCreator\r\n */\r\nprotected nl.tudelft.jpacman.board.BoardFactory getBoardCreator() {\r\n    return this.boardCreator;\r\n}", "docComment": "\r\n@return the BoardCreator\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.score", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The amount of points accumulated by this player.\r\n */\r\nprivate int score;", "visibility": "private", "simpleName": "score", "qualifiedName": "nl.tudelft.jpacman.level.Player.score", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game", "labels": ["Container"], "properties": {"simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.game", "kind": "package", "metaSrc": "source code", "description": "The package manages game state, provides methods to interact with the game board and players, and handles events such as starting and stopping the game.", "layer": "Service Layer", "title": "Game Management", "keywords": ["game", "state", "interaction", "events"]}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).0", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.level.PlayerFactory)", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new game factory.\r\n *\r\n * @param playerFactory\r\n * \t\tThe factory providing the player objects.\r\n */\r\npublic GameFactory(nl.tudelft.jpacman.level.PlayerFactory playerFactory) {\r\n    super();\r\n    this.playerFactory = playerFactory;\r\n}", "docComment": "Creates a new game factory.\r\n\r\n@param playerFactory\r\n\t\tThe factory providing the player objects.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "kind": "method", "sourceText": "/**\r\n * Actual case of player bumping into ghost or vice versa.\r\n *\r\n * @param player\r\n * \t\tThe player involved in the collision.\r\n * @param ghost\r\n * \t\tThe ghost involved in the collision.\r\n */\r\npublic void playerVersusGhost(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.npc.Ghost ghost) {\r\n    this.pointCalculator.collidedWithAGhost(player, ghost);\r\n    player.setAlive(false);\r\n    player.setKiller(ghost);\r\n}", "docComment": "Actual case of player bumping into ghost or vice versa.\r\n\r\n@param player\r\n\t\tThe player involved in the collision.\r\n@param ghost\r\n\t\tThe ghost involved in the collision.\r\n", "metaSrc": "source code", "description": "Updates player points based on collision with a ghost and sets the player as dead.", "returns": "", "reason": "This method is part of the Service Layer as it orchestrates the game logic by updating player points and setting the player's state.", "howToUse": "Call this method when a collision between a player and a ghost occurs.", "howItWorks": "The method first updates the player's points using the `pointCalculator.collidedWithAGhost` method. It then sets the player as dead by calling `player.setAlive(false)` and sets the killer to the ghost by calling `player.setKiller(ghost).", "assertions": {"preConditions": ["The player must be alive before colliding with a ghost.", "The ghost must exist in the game."], "postConditions": ["The player's points should be updated based on the collision.", "The player should be set as dead.", "The killer of the player should be set to the ghost."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "kind": "method", "sourceText": "/**\r\n * Renders a single square on the given graphics context on the specified\r\n * rectangle.\r\n *\r\n * @param square\r\n * \t\tThe square to render.\r\n * @param graphics\r\n * \t\tThe graphics context to draw on.\r\n * @param x\r\n * \t\tThe x position to start drawing.\r\n * @param y\r\n * \t\tThe y position to start drawing.\r\n * @param width\r\n * \t\tThe width of this square (in pixels.)\r\n * @param height\r\n * \t\tThe height of this square (in pixels.)\r\n */\r\nprivate void render(nl.tudelft.jpacman.board.Square square, java.awt.Graphics graphics, int x, int y, int width, int height) {\r\n    square.getSprite().draw(graphics, x, y, width, height);\r\n    for (nl.tudelft.jpacman.board.Unit unit : square.getOccupants()) {\r\n        unit.getSprite().draw(graphics, x, y, width, height);\r\n    }\r\n}", "docComment": "Renders a single square on the given graphics context on the specified\r\nrectangle.\r\n\r\n@param square\r\n\t\tThe square to render.\r\n@param graphics\r\n\t\tThe graphics context to draw on.\r\n@param x\r\n\t\tThe x position to start drawing.\r\n@param y\r\n\t\tThe y position to start drawing.\r\n@param width\r\n\t\tThe width of this square (in pixels.)\r\n@param height\r\n\t\tThe height of this square (in pixels.)\r\n", "metaSrc": "source code", "description": "Renders a square on the board, drawing its sprite and then each unit occupying it.", "returns": "void", "reason": "This method is responsible for rendering the visual representation of a square and its contents on the game board.", "howToUse": "Call this method with the appropriate parameters to draw a square and its occupants on the board.", "howItWorks": "The method first draws the sprite of the square using its `getSprite().draw()` method. Then, it iterates over each unit occupying the square and draws their sprites at the same position.", "assertions": {"preConditions": ["square is not null", "graphics is not null", "x, y, width, height are valid integers"], "postConditions": ["The square and its occupants are drawn on the board."]}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Determines whether the unit is allowed to occupy this square.\r\n *\r\n * @param unit\r\n * \t\tThe unit to grant or deny access.\r\n * @return <code>true</code> iff the unit is allowed to occupy this square.\r\n */\r\npublic abstract boolean isAccessibleTo(nl.tudelft.jpacman.board.Unit unit);", "docComment": "Determines whether the unit is allowed to occupy this square.\r\n\r\n@param unit\r\n\t\tThe unit to grant or deny access.\r\n@return <code>true</code> iff the unit is allowed to occupy this square.\r\n", "metaSrc": "source code", "description": "Determines if a given unit can access or occupy the square.", "returns": "Boolean indicating whether the unit is accessible to the square.", "reason": "This method provides a fundamental interface for determining accessibility, which is crucial for game logic in Pacman.", "howToUse": "Call this method with an instance of Unit to check if it can access the current square.", "howItWorks": "The method checks if the unit's movement rules allow it to enter the square. This typically involves checking collision detection and other game-specific conditions.", "preConditions": ["A valid Unit object is provided.", "The Square object exists in the game board."], "postConditions": ["Returns true if the unit can access the square, false otherwise."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.scoreFormatter", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Way to format the score.\r\n */\r\nprivate nl.tudelft.jpacman.ui.ScorePanel.ScoreFormatter scoreFormatter = null;", "visibility": "private", "simpleName": "scoreFormatter", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.scoreFormatter", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.getPlayers()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getPlayers()", "qualifiedName": "nl.tudelft.jpacman.game.Game.getPlayers()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return An immutable list of the participants of this game.\r\n */\r\npublic abstract java.util.List<nl.tudelft.jpacman.level.Player> getPlayers();", "docComment": "\r\n@return An immutable list of the participants of this game.\r\n", "metaSrc": "source code", "description": "Returns a list of players currently playing in the game.", "returns": "A List of Player objects representing the current players in the game.", "reason": "The method provides access to the players participating in the game, which is essential for managing player interactions and scores.", "howToUse": "Call this method on an instance of a subclass of Game to retrieve the list of players.", "howItWorks": "The method returns a list that contains all the Player objects associated with the current game state. This involves iterating over the game's level entities, identifying those that are instances of Player, and adding them to the list.", "assertions": {"preConditions": ["An instance of Game is created and initialized."], "postConditions": ["The returned list contains all players currently in the game."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.util.Map)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new \"Clyde\", a.k.a. \"Pokey\".\r\n *\r\n * @param spriteMap\r\n * \t\tThe sprites for this ghost.\r\n */\r\npublic Clyde(java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> spriteMap) {\r\n    super(spriteMap, nl.tudelft.jpacman.npc.ghost.Clyde.MOVE_INTERVAL, nl.tudelft.jpacman.npc.ghost.Clyde.INTERVAL_VARIATION);\r\n}", "docComment": "Creates a new \"Clyde\", a.k.a. \"Pokey\".\r\n\r\n@param spriteMap\r\n\t\tThe sprites for this ghost.\r\n", "metaSrc": "source code", "description": "Initializes a new Clyde ghost with specified sprite map, move interval, and interval variation.", "returns": "A newly created Clyde ghost instance.", "reason": "This method initializes a new Ghost instance with specific parameters required to create and configure the Clyde character in the game.", "howToUse": "To use this method, you need to provide a map of sprites for each direction. This setup is crucial for rendering the Clyde character correctly on the game board.", "howItWorks": "The method calls the superclass constructor with the provided sprite map and sets specific move interval and interval variation values for Clyde.", "assertions": {"preConditions": ["A valid Map of sprites for each direction is provided."], "postConditions": ["A new Clyde ghost instance is created with the specified parameters."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "private void pelletColliding(nl.tudelft.jpacman.level.Pellet pellet, nl.tudelft.jpacman.board.Unit collidedOn) {\r\n    if (collidedOn instanceof nl.tudelft.jpacman.level.Player) {\r\n        this.playerVersusPellet(((nl.tudelft.jpacman.level.Player) (collidedOn)), pellet);\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Updates player's score by adding points earned from consuming a pellet and removes the pellet from its square.", "returns": "", "reason": "This method handles the logic for when a player collides with a pellet, updating the player's score and removing the pellet from its square.", "howToUse": "Call this method with a Pellet object and a Unit object that represents the player. The method will update the player's score and remove the pellet from the game board.", "howItWorks": "The method checks if the collidedOn unit is an instance of Player. If it is, it calls the playerVersusPellet method with the player and the pellet as arguments. This method updates the player's score by adding points earned from consuming the pellet and removes the pellet from its square.", "assertions": {"preConditions": ["The collidedOn unit must be an instance of Player."], "postConditions": ["The player's score should be updated by adding points earned from consuming the pellet.", "The pellet should be removed from its square on the game board."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The y start coordinate."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.serialVersionUID", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Default serialisation ID.\r\n */\r\nprivate static final long serialVersionUID = 1L;", "visibility": "private", "simpleName": "serialVersionUID", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.serialVersionUID", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1", "labels": ["Variable"], "properties": {"simpleName": "buttons", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "A map of button labels to corresponding actions."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.scorePanel", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The panel displaying the player scores.\r\n */\r\nprivate final nl.tudelft.jpacman.ui.ScorePanel scorePanel;", "visibility": "private", "simpleName": "scorePanel", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI.scorePanel", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getOccupants()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getOccupants()", "qualifiedName": "nl.tudelft.jpacman.board.Square.getOccupants()", "kind": "method", "sourceText": "/**\r\n * Returns an immutable list of units occupying this square, in the order in\r\n * which they occupied this square (i.e. oldest first.)\r\n *\r\n * @return An immutable list of units occupying this square, in the order in\r\nwhich they occupied this square (i.e. oldest first.)\r\n */\r\npublic java.util.List<nl.tudelft.jpacman.board.Unit> getOccupants() {\r\n    return com.google.common.collect.ImmutableList.copyOf(this.occupants);\r\n}", "docComment": "Returns an immutable list of units occupying this square, in the order in\r\nwhich they occupied this square (i.e. oldest first.)\r\n\r\n@return An immutable list of units occupying this square, in the order in\r\nwhich they occupied this square (i.e. oldest first.)\r\n", "metaSrc": "source code", "description": "Returns an immutable list of units occupying the square.", "returns": "An ImmutableList containing all units on the square.", "reason": "The method provides a read-only view of the occupants, ensuring that the internal state cannot be modified directly.", "howToUse": "Call `getOccupants()` to retrieve a list of units currently occupying the square.", "howItWorks": "The method uses Guava's ImmutableList.copyOf() to create an immutable copy of the private List<nl.tudelft.jpacman.board.Unit> occupants, ensuring that any modifications to this list are not reflected in the returned list.", "preConditions": ["The square has been initialized with units."], "postConditions": ["The returned list is immutable and contains all units currently occupying the square."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.DEFAULT_MAP", "labels": ["Variable"], "properties": {"sourceText": "public static final java.lang.String DEFAULT_MAP = \"/board.txt\";", "visibility": "public", "simpleName": "DEFAULT_MAP", "qualifiedName": "nl.tudelft.jpacman.Launcher.DEFAULT_MAP", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).3", "labels": ["Variable"], "properties": {"simpleName": "scoreFormatter", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "An optional score formatter for displaying scores."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.SPRITE_STORE", "labels": ["Variable"], "properties": {"sourceText": "private static final nl.tudelft.jpacman.sprite.PacManSprites SPRITE_STORE = new nl.tudelft.jpacman.sprite.PacManSprites();", "visibility": "private", "simpleName": "SPRITE_STORE", "qualifiedName": "nl.tudelft.jpacman.Launcher.SPRITE_STORE", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.ghostFact", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The factory providing ghosts.\r\n */\r\nprivate final nl.tudelft.jpacman.npc.ghost.GhostFactory ghostFact;", "visibility": "private", "simpleName": "ghostFact", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.ghostFact", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getSinglePlayer(nl.tudelft.jpacman.game.Game)", "qualifiedName": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "kind": "method", "sourceText": "private nl.tudelft.jpacman.level.Player getSinglePlayer(final nl.tudelft.jpacman.game.Game game) {\r\n    java.util.List<nl.tudelft.jpacman.level.Player> players = game.getPlayers();\r\n    if (players.isEmpty()) {\r\n        throw new java.lang.IllegalArgumentException(\"Game has 0 players.\");\r\n    }\r\n    return players.get(0);\r\n}", "docComment": "", "metaSrc": "source code", "description": "Returns the single player from the game if there is exactly one, otherwise throws an exception.", "returns": "A Player object representing the single player in the game.", "reason": "The method provides a simple way to access the sole player in a single-player game, ensuring that only one player can be present.", "howToUse": "Call this method with an instance of nl.tudelft.jpacman.game.Game to retrieve the single player.", "howItWorks": "The method retrieves all players from the game using getPlayers() and checks if there is exactly one. If not, it throws an IllegalArgumentException. Otherwise, it returns the first (and only) player in the list.", "assertions": {"preConditions": ["game is a valid instance of nl.tudelft.jpacman.game.Game"], "postConditions": ["returns a Player object if there is exactly one player in the game"]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getKiller()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getKiller()", "qualifiedName": "nl.tudelft.jpacman.level.Player.getKiller()", "kind": "method", "sourceText": "/**\r\n * Returns the unit that caused the death of Pac-Man.\r\n *\r\n * @return <code>Unit</code> iff the player died by collision, otherwise <code>null</code>.\r\n */\r\npublic nl.tudelft.jpacman.board.Unit getKiller() {\r\n    return this.killer;\r\n}", "docComment": "Returns the unit that caused the death of Pac-Man.\r\n\r\n@return <code>Unit</code> iff the player died by collision, otherwise <code>null</code>.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "labels": ["Variable"], "properties": {"simpleName": "observer", "qualifiedName": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The observer to be added."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The height of the sub-image to be split."}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.player", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The player of this game.\r\n */\r\nprivate final nl.tudelft.jpacman.level.Player player;", "visibility": "private", "simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame.player", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).1", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The width of the grid."}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.lang.String)", "qualifiedName": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)", "kind": "constructor", "sourceText": "/**\r\n * A configuration exception with a direct message.\r\n *\r\n * @param message\r\n * \t\tThe exception message.\r\n */\r\npublic PacmanConfigurationException(java.lang.String message) {\r\n    super(message);\r\n}", "docComment": "A configuration exception with a direct message.\r\n\r\n@param message\r\n\t\tThe exception message.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.sprite.PacManSprites)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new ghost factory.\r\n *\r\n * @param spriteStore\r\n * \t\tThe sprite provider.\r\n */\r\npublic GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites spriteStore) {\r\n    super();\r\n    this.sprites = spriteStore;\r\n}", "docComment": "Creates a new ghost factory.\r\n\r\n@param spriteStore\r\n\t\tThe sprite provider.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions", "labels": ["Structure"], "properties": {"docComment": "A simple implementation of a collision map for the JPacman player.\r\n<p>\r\nIt uses a number of instanceof checks to implement the multiple dispatch for the \r\ncollisionmap. For more realistic collision maps, this approach will not scale,\r\nand the recommended approach is to use a {@link CollisionInteractionMap}.\r\n\r\n@author Arie van Deursen, 2014\r\n", "simpleName": "PlayerCollisions", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for managing game logic, including handling player interactions and updating scores based on collisions with ghosts and pellets.", "layer": "Domain Layer", "roleStereotype": "Service Provider", "keywords": ["game", "logic", "player", "interaction", "score", "collision"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "kind": "method", "sourceText": "/**\r\n * Adds a square to the grid based on a given character. These\r\n * character come from the map files and describe the type\r\n * of square.\r\n *\r\n * @param grid\r\n * \t\tThe grid of squares with board[x][y] being the\r\n * \t\tsquare at column x, row y.\r\n * @param ghosts\r\n * \t\tList of all ghosts that were added to the map.\r\n * @param startPositions\r\n * \t\tList of all start positions that were added\r\n * \t\tto the map.\r\n * @param x\r\n * \t\tx coordinate of the square.\r\n * @param y\r\n * \t\ty coordinate of the square.\r\n * @param c\r\n * \t\tCharacter describing the square type.\r\n */\r\nprotected void addSquare(nl.tudelft.jpacman.board.Square[][] grid, java.util.List<nl.tudelft.jpacman.npc.Ghost> ghosts, java.util.List<nl.tudelft.jpacman.board.Square> startPositions, int x, int y, char c) {\r\n    switch (c) {\r\n        case ' ' :\r\n            grid[x][y] = this.boardCreator.createGround();\r\n            break;\r\n        case '#' :\r\n            grid[x][y] = this.boardCreator.createWall();\r\n            break;\r\n        case '.' :\r\n            nl.tudelft.jpacman.board.Square pelletSquare = this.boardCreator.createGround();\r\n            grid[x][y] = pelletSquare;\r\n            this.levelCreator.createPellet().occupy(pelletSquare);\r\n            break;\r\n        case 'G' :\r\n            nl.tudelft.jpacman.board.Square ghostSquare = this.makeGhostSquare(ghosts, this.levelCreator.createGhost());\r\n            grid[x][y] = ghostSquare;\r\n            break;\r\n        case 'P' :\r\n            nl.tudelft.jpacman.board.Square playerSquare = this.boardCreator.createGround();\r\n            grid[x][y] = playerSquare;\r\n            startPositions.add(playerSquare);\r\n            break;\r\n        default :\r\n            throw new nl.tudelft.jpacman.PacmanConfigurationException(((((\"Invalid character at \" + x) + \",\") + y) + \": \") + c);\r\n    }\r\n}", "docComment": "Adds a square to the grid based on a given character. These\r\ncharacter come from the map files and describe the type\r\nof square.\r\n\r\n@param grid\r\n\t\tThe grid of squares with board[x][y] being the\r\n\t\tsquare at column x, row y.\r\n@param ghosts\r\n\t\tList of all ghosts that were added to the map.\r\n@param startPositions\r\n\t\tList of all start positions that were added\r\n\t\tto the map.\r\n@param x\r\n\t\tx coordinate of the square.\r\n@param y\r\n\t\ty coordinate of the square.\r\n@param c\r\n\t\tCharacter describing the square type.\r\n", "metaSrc": "source code", "description": "Parses a map file and constructs a game board based on the specified characters.", "returns": "None", "reason": "This method is responsible for parsing a map file and constructing a game board based on the specified characters.", "howToUse": "Call this method with the appropriate parameters to parse a map file and construct a game board.", "howItWorks": "The method uses a switch statement to determine the type of square represented by the character 'c' at the current position (x, y) in the grid. It then creates the corresponding square using the board creator and adds it to the grid. Depending on the character, it may also create additional objects such as ghosts or pellets.", "assertions": {"preConditions": ["The grid is a valid 2D array of squares.", "The ghosts list is not null.", "The startPositions list is not null.", "x and y are within the bounds of the grid."], "postConditions": ["The grid has been updated with the appropriate squares based on the map file characters.", "Ghosts have been created and added to the ghosts list if necessary.", "Starting positions have been added to the startPositions list if necessary."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent).0", "labels": ["Variable"], "properties": {"simpleName": "event", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "labels": ["Variable"], "properties": {"simpleName": "type", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The class of the unit to find."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "labels": ["Variable"], "properties": {"simpleName": "currentLocation", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The starting square from which to search for the nearest unit."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky", "labels": ["Structure"], "properties": {"docComment": "<p>\r\nAn implementation of the classic Pac-Man ghost Inky.\r\n</p>\r\n<b>AI:</b> Inky has the most complicated AI of all. Inky considers two things: Blinky's\r\nlocation, and the location two grid spaces ahead of Pac-Man. Inky draws a\r\nline from Blinky to the spot that is two squares in front of Pac-Man and\r\nextends that line twice as far. Therefore, if Inky is alongside Blinky\r\nwhen they are behind Pac-Man, Inky will usually follow Blinky the whole\r\ntime. But if Inky is in front of Pac-Man when Blinky is far behind him,\r\nInky tends to want to move away from Pac-Man (in reality, to a point very\r\nfar ahead of Pac-Man). Inky is affected by a similar targeting bug that\r\naffects Speedy. When Pac-Man is moving or facing up, the spot Inky uses to\r\ndraw the line is two squares above and left of Pac-Man.\r\n<p>\r\nSource: http://strategywiki.org/wiki/Pac-Man/Getting_Started\r\n</p>\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Inky", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for managing the AI logic and movement of an Inky ghost in a Pac-Man game, including following paths to Blinky and the player while avoiding obstacles.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["AI", "Ghost", "Pac-Man", "Pathfinding", "Movement"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "labels": ["Variable"], "properties": {"simpleName": "level", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The level to be used in the game."}}}, {"data": {"id": "nl.tudelft.jpacman.ui", "labels": ["Container"], "properties": {"simpleName": "ui", "qualifiedName": "nl.tudelft.jpacman.ui", "kind": "package", "metaSrc": "source code", "description": "The nl.tudelft.jpacman.ui package contains classes and interfaces that manage the user interface for a Pacman game, including rendering the game board, handling user input, displaying scores, and managing buttons.", "layer": "Presentation Layer", "title": "Pacman User Interface", "keywords": ["pacman", "ui", "game", "panel", "button", "keylistener"]}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getScore()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getScore()", "qualifiedName": "nl.tudelft.jpacman.level.Player.getScore()", "kind": "method", "sourceText": "/**\r\n * Returns the amount of points accumulated by this player.\r\n *\r\n * @return The amount of points accumulated by this player.\r\n */\r\npublic int getScore() {\r\n    return this.score;\r\n}", "docComment": "Returns the amount of points accumulated by this player.\r\n\r\n@return The amount of points accumulated by this player.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.RED", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Shadow, a.k.a. Blinky.\r\n */\r\nRED()", "visibility": "public", "simpleName": "RED", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostColor.RED", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The width of the destination draw area."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The delay between frames.\r\n */\r\nprivate static final int ANIMATION_DELAY = 200;", "visibility": "private", "simpleName": "ANIMATION_DELAY", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "labels": ["Variable"], "properties": {"simpleName": "ghost", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The width of the sprite to draw."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder()", "kind": "constructor", "sourceText": "/**\r\n * Creates a new Pac-Man UI builder without any mapped keys or buttons.\r\n */\r\npublic PacManUiBuilder() {\r\n    super();\r\n    this.defaultButtons = false;\r\n    this.buttons = new java.util.LinkedHashMap<java.lang.String, nl.tudelft.jpacman.ui.Action>();\r\n    this.keyMappings = new java.util.HashMap<java.lang.Integer, nl.tudelft.jpacman.ui.Action>();\r\n}", "docComment": "Creates a new Pac-Man UI builder without any mapped keys or buttons.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "labels": ["Variable"], "properties": {"simpleName": "pellet", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The pellet consumed."}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.levelLost()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "levelLost()", "qualifiedName": "nl.tudelft.jpacman.game.Game.levelLost()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void levelLost() {\r\n    this.stop();\r\n}", "docComment": "", "metaSrc": "source code", "description": "Stops the game by pausing it and setting the in-progress flag to false.", "returns": "", "reason": "The method is part of the Game class, which manages the overall state and flow of the Pacman game. It stops the game when a level is lost, ensuring that the game can be restarted or ended appropriately.", "howToUse": "Call `levelLost()` to stop the current level of the game.", "howItWorks": "The method calls the `stop()` method, which pauses the game and sets the in-progress flag to false. This ensures that the game state is updated correctly when a level is lost.", "preConditions": ["The game is currently in progress."], "postConditions": ["The game is paused, and the in-progress flag is set to false."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "labels": ["Variable"], "properties": {"simpleName": "pellet", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The Pellet that is consumed by the player."}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).2", "labels": ["Variable"], "properties": {"simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The point calculator for scoring in the game."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap", "labels": ["Container", "Structure"], "properties": {"docComment": "A map of possible collisions and their handlers.\r\n\r\n@author Michael de Jong\r\n@author Jeroen Roosen\r\n", "simpleName": "CollisionInteractionMap", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap", "kind": "class", "metaSrc": "source code", "description": "Manages collision interactions between game units, providing methods to add handlers for direct and reverse collisions.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["collision", "interaction", "handler", "unit"], "dependencyProfile": "hidden"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getDirection()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getDirection()", "qualifiedName": "nl.tudelft.jpacman.board.Unit.getDirection()", "kind": "method", "sourceText": "/**\r\n * Returns the current direction this unit is facing.\r\n *\r\n * @return The current direction this unit is facing.\r\n */\r\npublic nl.tudelft.jpacman.board.Direction getDirection() {\r\n    return this.direction;\r\n}", "docComment": "Returns the current direction this unit is facing.\r\n\r\n@return The current direction this unit is facing.\r\n", "metaSrc": "source code", "description": "Returns the current direction of the unit.", "returns": "The current direction of the unit as an enum value.", "reason": "This method provides a simple getter for the direction attribute, which is essential for determining the movement of the Pacman character in the game.", "howToUse": "Call this method on an instance of Unit to retrieve its current direction.", "howItWorks": "The method simply returns the value stored in the 'direction' field of the Unit object.", "preConditions": ["An instance of Unit is created and initialized with a direction."], "postConditions": ["The returned direction matches the direction attribute of the Unit object."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites", "labels": ["Structure"], "properties": {"docComment": "Sprite Store containing the classic Pac-Man sprites.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "PacManSprites", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for managing and providing access to various game sprites, including walls, walls, pellets, and walls. It handles loading and caching of these sprites from resource files.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["sprite management", "game assets", "resource handling"], "dependencyProfile": "inbound"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).0", "labels": ["Variable"], "properties": {"simpleName": "service", "qualifiedName": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.CYAN", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Bashful, a.k.a. Inky.\r\n */\r\nCYAN()", "visibility": "public", "simpleName": "CYAN", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostColor.CYAN", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.getDeltaY()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getDeltaY()", "qualifiedName": "nl.tudelft.jpacman.board.Direction.getDeltaY()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The delta y (height difference) for a single step in this\r\ndirection, in a matrix with 0,0 (x,y) as its top-left element.\r\n */\r\npublic int getDeltaY() {\r\n    return this.deltaY;\r\n}", "docComment": "\r\n@return The delta y (height difference) for a single step in this\r\ndirection, in a matrix with 0,0 (x,y) as its top-left element.\r\n", "metaSrc": "source code", "description": "Returns the vertical displacement associated with a given direction.", "returns": "An integer representing the vertical displacement.", "reason": "The method provides a straightforward way to access the vertical component of a direction, which is essential for movement in a game like Pacman.", "howToUse": "Call `getDeltaY()` on an instance of `Direction` to retrieve its vertical displacement.", "howItWorks": "The method returns the value stored in the `deltaY` field of the enum constant representing the direction.", "preConditions": [], "postConditions": [], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new level factory.\r\n *\r\n * @param spriteStore\r\n * \t\tThe sprite store providing the sprites for units.\r\n * @param ghostFactory\r\n * \t\tThe factory providing ghosts.\r\n * @param pointCalculator\r\n * \t\tThe algorithm to calculate the points.\r\n */\r\npublic LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites spriteStore, nl.tudelft.jpacman.npc.ghost.GhostFactory ghostFactory, nl.tudelft.jpacman.points.PointCalculator pointCalculator) {\r\n    super();\r\n    this.sprites = spriteStore;\r\n    this.ghostIndex = -1;\r\n    this.ghostFact = ghostFactory;\r\n    this.pointCalculator = pointCalculator;\r\n}", "docComment": "Creates a new level factory.\r\n\r\n@param spriteStore\r\n\t\tThe sprite store providing the sprites for units.\r\n@param ghostFactory\r\n\t\tThe factory providing ghosts.\r\n@param pointCalculator\r\n\t\tThe algorithm to calculate the points.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "withMapFile(java.lang.String)", "qualifiedName": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)", "kind": "method", "sourceText": "/**\r\n * Set the name of the file containing this level's map.\r\n *\r\n * @param fileName\r\n * \t\tMap to be used.\r\n * @return Level corresponding to the given map.\r\n */\r\npublic nl.tudelft.jpacman.Launcher withMapFile(java.lang.String fileName) {\r\n    this.levelMap = fileName;\r\n    return this;\r\n}", "docComment": "Set the name of the file containing this level's map.\r\n\r\n@param fileName\r\n\t\tMap to be used.\r\n@return Level corresponding to the given map.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "draw(java.awt.Graphics,int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void draw(java.awt.Graphics graphics, int x, int y, int width, int height) {\r\n    // nothing to draw.\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor()", "labels": ["Constructor"], "properties": {"visibility": "private", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostColor()", "kind": "constructor", "sourceText": "GhostColor() {\r\n    super();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.sprites", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The sprite store that provides sprites for units.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.PacManSprites sprites;", "visibility": "private", "simpleName": "sprites", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.sprites", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).0", "labels": ["Variable"], "properties": {"simpleName": "frames", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The frames of this animation."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.square", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The square this unit is currently occupying.\r\n */\r\nprivate nl.tudelft.jpacman.board.Square square;", "visibility": "private", "simpleName": "square", "qualifiedName": "nl.tudelft.jpacman.board.Unit.square", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).1", "labels": ["Variable"], "properties": {"simpleName": "ghosts", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "A list of ghosts to be placed in the level."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.scoreLabels", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The map of players and the labels their scores are on.\r\n */\r\nprivate final java.util.Map<nl.tudelft.jpacman.level.Player, javax.swing.JLabel> scoreLabels;", "visibility": "private", "simpleName": "scoreLabels", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel.scoreLabels", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit()", "labels": ["Constructor"], "properties": {"visibility": "protected", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.board.Unit()", "kind": "constructor", "sourceText": "/**\r\n * Creates a unit that is facing east.\r\n */\r\nprotected Unit() {\r\n    super();\r\n    this.direction = nl.tudelft.jpacman.board.Direction.EAST;\r\n}", "docComment": "Creates a unit that is facing east.\r\n", "metaSrc": "source code", "description": "Initializes a new Unit instance with an east-facing direction.", "returns": "A newly created Unit instance.", "reason": "The method initializes a unit object with a default direction, which is useful for setting up the initial state of units in the game.", "howToUse": "Call this constructor to create a new Unit object.", "howItWorks": "The constructor calls the superclass constructor and sets the direction to east.", "preConditions": [], "postConditions": ["A new Unit instance is created with an east-facing direction."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String).0", "labels": ["Variable"], "properties": {"simpleName": "mapName", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The name of the map file to parse."}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "kind": "method", "sourceText": "private void makeGrid(char[][] map, int width, int height, nl.tudelft.jpacman.board.Square[][] grid, java.util.List<nl.tudelft.jpacman.npc.Ghost> ghosts, java.util.List<nl.tudelft.jpacman.board.Square> startPositions) {\r\n    for (int x = 0; x < width; x++) {\r\n        for (int y = 0; y < height; y++) {\r\n            char c = map[x][y];\r\n            this.addSquare(grid, ghosts, startPositions, x, y, c);\r\n        }\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Parses a map file and constructs a game board based on the specified characters.", "returns": "None.", "reason": "The method is responsible for parsing a map file and constructing a game board based on the specified characters, which is a core functionality of the game logic layer.", "howToUse": "Call this method with the appropriate parameters to initialize the game board from a map file.", "howItWorks": "Iterates over each cell in the map, calls `addSquare` for each character, and populates the grid accordingly.", "assertions": {"preConditions": ["The input parameters are valid (non-null arrays and lists).", "The grid is initialized with the correct dimensions."], "postConditions": ["The grid contains all squares parsed from the map file.", "Ghosts and start positions are correctly added to their respective lists."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore()", "kind": "constructor", "sourceText": "/**\r\n * Create a new sprite store.\r\n */\r\npublic SpriteStore() {\r\n    super();\r\n    this.spriteMap = new java.util.HashMap<java.lang.String, nl.tudelft.jpacman.sprite.Sprite>();\r\n}", "docComment": "Create a new sprite store.\r\n", "metaSrc": "source code", "description": "Initializes a new instance of SpriteStore by setting up an empty HashMap to store sprite mappings.", "returns": "A newly created instance of SpriteStore with an empty HashMap for storing sprite mappings.", "reason": "This method initializes the core data structure used in the SpriteStore class, which is essential for managing and retrieving sprites based on their names.", "howToUse": "Create a new instance of SpriteStore to manage sprite resources.", "howItWorks": "The constructor calls super() to initialize the parent class, then creates an empty HashMap to store sprite mappings. This setup allows for efficient retrieval and management of sprites by name.", "preConditions": [], "postConditions": ["A new instance of SpriteStore is created with an empty HashMap for storing sprite mappings."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite()", "kind": "constructor", "sourceText": "EmptySprite() {\r\n    super();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "collider", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that is colliding."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "collider", "qualifiedName": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that is colliding with another unit."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation", "labels": ["Container", "Structure"], "properties": {"docComment": "Navigation provides utility to navigate on {@link Square}s.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Navigation", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for managing paths and providing information about squares on the game board, including finding shortest paths and identifying valid moves.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["pathfinding", "shortest path", "square management", "game board"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.levelCreator", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The factory that creates the levels.\r\n */\r\nprivate final nl.tudelft.jpacman.level.LevelFactory levelCreator;", "visibility": "private", "simpleName": "levelCreator", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.levelCreator", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde", "labels": ["Structure"], "properties": {"docComment": "<p>\r\nAn implementation of the classic Pac-Man ghost Clyde.\r\n</p>\r\n<p>\r\nPokey needs a new nickname because out of all the ghosts,\r\nClyde is the least likely to \"C'lyde\" with Pac-Man. Clyde is always the last\r\nghost out of the regenerator, and the loner of the gang, usually off doing\r\nhis own thing when not patrolling the bottom-left corner of the maze. His\r\nbehavior is very random, so while he's not likely to be following you in hot\r\npursuit with the other ghosts, he is a little less predictable, and still a\r\ndanger.\r\n</p>\r\n<p>\r\n<b>AI:</b> Clyde has two basic AIs, one for when he's far from Pac-Man, and\r\none for when he is near to Pac-Man. \r\nWhen Clyde is far away from Pac-Man (beyond eight grid spaces),\r\nClyde behaves very much like Blinky, trying to move to Pac-Man's exact\r\nlocation. However, when Clyde gets within eight grid spaces of Pac-Man, he\r\nautomatically changes his behavior and runs away.\r\n</p>\r\n<p>\r\nSource: http://strategywiki.org/wiki/Pac-Man/Getting_Started\r\n</p>\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Clyde", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Clyde", "kind": "class", "metaSrc": "source code", "description": "The Clyde class is responsible for managing the AI behavior and movement of the Clyde ghost in the Pacman game, including determining its next move based on the nearest player and calculating the shortest path while considering shyness.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["Clyde", "Ghost", "AI", "Movement", "Pathfinding", "Shyness"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.BLINKY", "labels": ["Variable"], "properties": {"sourceText": "private static final int BLINKY = 0;", "visibility": "private", "simpleName": "BLINKY", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.BLINKY", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points", "labels": ["Container"], "properties": {"simpleName": "points", "qualifiedName": "nl.tudelft.jpacman.points", "kind": "package", "metaSrc": "source code", "description": "The nl.tudelft.jpacman.points package contains classes and interfaces responsible for managing player points in a Pacman game, including calculating points based on various actions like consuming pellets and colliding with ghosts.", "layer": "Service Layer", "title": "Point Calculator Service Layer", "keywords": ["point calculator", "game scoring", "pacman", "points"]}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level", "labels": ["Container", "Structure"], "properties": {"docComment": "A level of Pac-Man. A level consists of the board with the players and the\r\nAIs on it.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Level", "qualifiedName": "nl.tudelft.jpacman.level.Level", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for managing the state and behavior of a game level, including player interactions, pellet collection, and game progression.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["game", "level", "player", "interaction", "pellet", "progression"], "dependencyProfile": "transit"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getMapParser()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getMapParser()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getMapParser()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return A new map parser object using the factories from\r\n{@link #getLevelFactory()} and {@link #getBoardFactory()}.\r\n */\r\nprotected nl.tudelft.jpacman.level.MapParser getMapParser() {\r\n    return new nl.tudelft.jpacman.level.MapParser(this.getLevelFactory(), this.getBoardFactory());\r\n}", "docComment": "\r\n@return A new map parser object using the factories from\r\n{@link #getLevelFactory()} and {@link #getBoardFactory()}.\r\n", "metaSrc": "source code", "description": "Returns a new MapParser instance initialized with the current LevelFactory and BoardFactory.", "returns": "A new MapParser instance", "reason": "The method is part of the Service Layer as it initializes and returns an object that is used to parse map data for the game.", "howToUse": "Call this method from a class that needs to use a MapParser, such as a GameEngine or LevelManager.", "howItWorks": "The method creates a new instance of MapParser by passing the current LevelFactory and BoardFactory instances to its constructor.", "assertions": {"preConditions": [], "postConditions": ["The returned MapParser is not null."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.getDeltaX()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getDeltaX()", "qualifiedName": "nl.tudelft.jpacman.board.Direction.getDeltaX()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The delta x (width difference) for a single step in this\r\ndirection, in a matrix with 0,0 (x,y) as its top-left element.\r\n */\r\npublic int getDeltaX() {\r\n    return this.deltaX;\r\n}", "docComment": "\r\n@return The delta x (width difference) for a single step in this\r\ndirection, in a matrix with 0,0 (x,y) as its top-left element.\r\n", "metaSrc": "source code", "description": "Returns the horizontal delta value associated with the direction.", "returns": "The integer representing the horizontal change in position for the given direction.", "reason": "This method provides a straightforward way to access the horizontal component of a direction, which is essential for movement logic in a Pacman game.", "howToUse": "Call `getDeltaX()` on an instance of `Direction` to retrieve its horizontal delta value.", "howItWorks": "The method directly returns the stored `deltaX` field, which holds the horizontal change associated with each direction (e.g., -1 for left, 1 for right).", "preConditions": [], "postConditions": [], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handler", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The handler of this collision.\r\n */\r\nprivate final nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<C2, C1> handler;", "visibility": "private", "simpleName": "handler", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handler", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player for the game."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square).0", "labels": ["Variable"], "properties": {"simpleName": "this", "qualifiedName": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).2", "labels": ["Variable"], "properties": {"simpleName": "loop", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "Indicates whether the animation should loop continuously."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "main(java.lang.String[])", "qualifiedName": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "kind": "static method", "sourceText": "/**\r\n * Main execution method for the Launcher.\r\n *\r\n * @param args\r\n * \t\tThe command line arguments - which are ignored.\r\n * @throws IOException\r\n * \t\tWhen a resource could not be read.\r\n */\r\npublic static void main(java.lang.String[] args) throws java.io.IOException {\r\n    new nl.tudelft.jpacman.Launcher().launch();\r\n}", "docComment": "Main execution method for the Launcher.\r\n\r\n@param args\r\n\t\tThe command line arguments - which are ignored.\r\n@throws IOException\r\n\t\tWhen a resource could not be read.\r\n", "metaSrc": "source code", "description": "Launches a single-player PacMan game by creating, configuring, and starting the UI.", "returns": "A new instance of nl.tudelft.jpacman.ui.PacManUI", "reason": "The method is responsible for initiating the game's execution, setting up the user interface, and managing the game loop.", "howToUse": "Call the `main` method with no arguments to start a single-player PacMan game.", "howItWorks": "The method creates an instance of `Launcher`, which in turn calls its `launch` method. The `launch` method initializes the UI and starts the game loop, displaying the game window and handling user input.", "assertions": {"preConditions": [], "postConditions": ["A new instance of nl.tudelft.jpacman.ui.PacManUI is returned."]}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.progressLock", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Object that locks the start and stop methods.\r\n */\r\nprivate final java.lang.Object progressLock = new java.lang.Object();", "visibility": "private", "simpleName": "progressLock", "qualifiedName": "nl.tudelft.jpacman.game.Game.progressLock", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.inProgress", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * <code>true</code> iff this level is currently in progress, i.e. players\r\n * and NPCs can move.\r\n */\r\nprivate boolean inProgress;", "visibility": "private", "simpleName": "inProgress", "qualifiedName": "nl.tudelft.jpacman.level.Level.inProgress", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation()", "labels": ["Constructor"], "properties": {"visibility": "private", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation()", "kind": "constructor", "sourceText": "private Navigation() {\r\n    super();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.players", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The players on this level.\r\n */\r\nprivate final java.util.List<nl.tudelft.jpacman.level.Player> players;", "visibility": "private", "simpleName": "players", "qualifiedName": "nl.tudelft.jpacman.level.Level.players", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Handles the collision between two colliding parties.\r\n *\r\n * @param collider\r\n * \t\tThe collider.\r\n * @param collidee\r\n * \t\tThe collidee.\r\n */\r\nvoid handleCollision(C1 collider, C2 collidee);", "docComment": "Handles the collision between two colliding parties.\r\n\r\n@param collider\r\n\t\tThe collider.\r\n@param collidee\r\n\t\tThe collidee.\r\n", "metaSrc": "source code", "description": "Handles collisions between units in the game board.", "returns": "", "reason": "This method is part of the collision handling logic in the game, which is a core component of the domain layer.", "howToUse": "Implement this method to define how units should interact when they collide. This could involve changing their state, removing them from the board, or triggering special effects.", "howItWorks": "The method takes two unit objects as parameters and determines what action should be taken based on their collision. It may update the game state accordingly.", "assertions": {"preConditions": ["Both collider and collidee are valid units in the game board."], "postConditions": ["The game state is updated to reflect the collision."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.invariant()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "invariant()", "qualifiedName": "nl.tudelft.jpacman.board.Unit.invariant()", "kind": "method", "sourceText": "/**\r\n * Tests whether the square this unit is occupying has this unit listed as\r\n * one of its occupiers.\r\n *\r\n * @return <code>true</code> if the square this unit is occupying has this\r\nunit listed as one of its occupiers, or if this unit is currently\r\nnot occupying any square.\r\n */\r\nprotected boolean invariant() {\r\n    return (this.square == null) || this.square.getOccupants().contains(this);\r\n}", "docComment": "Tests whether the square this unit is occupying has this unit listed as\r\none of its occupiers.\r\n\r\n@return <code>true</code> if the square this unit is occupying has this\r\nunit listed as one of its occupiers, or if this unit is currently\r\nnot occupying any square.\r\n", "metaSrc": "source code", "description": "Checks if the unit is on a square and if that square contains the unit.", "returns": "Boolean indicating whether the unit's square contains the unit.", "reason": "Ensures the integrity of the unit's position on the board.", "howToUse": "Call this method to verify the state of a unit on the game board.", "howItWorks": "Compares the unit's current square with its list of occupants. If they match, the unit is correctly placed on the board.", "assertions": {"preConditions": ["Unit exists and has a square assigned."], "postConditions": ["Returns true if the unit is on the correct square and contains itself in the square's occupants."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$LevelObserver.levelWon()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "levelWon()", "qualifiedName": "nl.tudelft.jpacman.level.Level$LevelObserver.levelWon()", "kind": "method", "sourceText": "/**\r\n * The level has been won. Typically the level should be stopped when\r\n * this event is received.\r\n */\r\nvoid levelWon();", "docComment": "The level has been won. Typically the level should be stopped when\r\nthis event is received.\r\n", "metaSrc": "source code", "description": "Notifies when the level is won in the Pacman game.", "returns": "", "reason": "The method `levelWon()` is part of the interface `Level$LevelObserver` and is used to notify observers that the current level has been successfully completed by the player. This functionality is essential for updating the game state, displaying a win message, and potentially starting a new level.", "howToUse": "Implement this method in classes that are registered as observers of the `Level` class. When the level is won, call the `levelWon()` method to notify all registered observers.", "howItWorks": "The method does not have any implementation details since it is an interface method. It simply declares a contract for observer objects to implement when they want to be notified about level completion.", "preConditions": [], "postConditions": [], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "keyReleased(java.awt.event.KeyEvent)", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void keyReleased(java.awt.event.KeyEvent event) {\r\n    // do nothing\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.getPlayerFactory()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getPlayerFactory()", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory.getPlayerFactory()", "kind": "method", "sourceText": "/**\r\n * Returns the player factory associated with this game factory.\r\n *\r\n * @return The player factory associated with this game factory.\r\n */\r\nprotected nl.tudelft.jpacman.level.PlayerFactory getPlayerFactory() {\r\n    return this.playerFactory;\r\n}", "docComment": "Returns the player factory associated with this game factory.\r\n\r\n@return The player factory associated with this game factory.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "kind": "static method", "sourceText": "private static void addNewTargets(nl.tudelft.jpacman.board.Unit traveller, java.util.List<nl.tudelft.jpacman.npc.ghost.Navigation.Node> targets, java.util.Set<nl.tudelft.jpacman.board.Square> visited, nl.tudelft.jpacman.npc.ghost.Navigation.Node node, nl.tudelft.jpacman.board.Square square) {\r\n    for (nl.tudelft.jpacman.board.Direction direction : nl.tudelft.jpacman.board.Direction.values()) {\r\n        nl.tudelft.jpacman.board.Square target = square.getSquareAt(direction);\r\n        if ((!visited.contains(target)) && ((traveller == null) || target.isAccessibleTo(traveller))) {\r\n            targets.add(new nl.tudelft.jpacman.npc.ghost.Navigation.Node(direction, target, node));\r\n        }\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Adds new targets for navigation based on accessible squares and directions.", "returns": "None", "reason": "This method is part of the domain layer as it handles navigation logic for ghosts in a Pacman game.", "howToUse": "Call this method with the current unit, list to store targets, set of visited squares, current node, and starting square.", "howItWorks": "Iterates over all possible directions from the given square. For each direction, it checks if the resulting square is accessible to the unit and not already visited. If so, it adds a new navigation node to the list with the direction, target square, and current node.", "assertions": {"preConditions": ["traveller must be a valid Unit object", "targets must be a non-null List of Navigation.Node objects", "visited must be a non-null Set of Square objects", "node must be a valid Navigation.Node object", "square must be a valid Square object"], "postConditions": ["targets list should contain new Navigation.Node objects for accessible squares not already visited"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.END_OF_LOOP", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Static empty sprite to serve as the end of a non-looping sprite.\r\n */\r\nprivate static final nl.tudelft.jpacman.sprite.Sprite END_OF_LOOP = new nl.tudelft.jpacman.sprite.EmptySprite();", "visibility": "private", "simpleName": "END_OF_LOOP", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.END_OF_LOOP", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean).0", "labels": ["Variable"], "properties": {"simpleName": "isAnimating", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationDelay", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The delay between frames.\r\n */\r\nprivate final int animationDelay;", "visibility": "private", "simpleName": "animationDelay", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationDelay", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Handles the collision between two colliding parties, if a suitable\r\n * collision handler is listed.\r\n *\r\n * @param <C1>\r\n * \t\tThe collider type.\r\n * @param <C2>\r\n * \t\tThe collidee (unit that was moved into) type.\r\n * @param collider\r\n * \t\tThe collider.\r\n * @param collidee\r\n * \t\tThe collidee.\r\n */\r\n@java.lang.SuppressWarnings(\"unchecked\")\r\n@java.lang.Override\r\npublic <C1 extends nl.tudelft.jpacman.board.Unit, C2 extends nl.tudelft.jpacman.board.Unit> void collide(C1 collider, C2 collidee) {\r\n    java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> colliderKey = this.getMostSpecificClass(this.handlers, collider.getClass());\r\n    if (colliderKey == null) {\r\n        return;\r\n    }\r\n    java.util.Map<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<? extends java.lang.Object, ? extends java.lang.Object>> map = this.handlers.get(colliderKey);\r\n    java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> collideeKey = this.getMostSpecificClass(map, collidee.getClass());\r\n    if (collideeKey == null) {\r\n        return;\r\n    }\r\n    nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<C1, C2> collisionHandler = ((nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<C1, C2>) (map.get(collideeKey)));\r\n    if (collisionHandler == null) {\r\n        return;\r\n    }\r\n    collisionHandler.handleCollision(collider, collidee);\r\n}", "docComment": "Handles the collision between two colliding parties, if a suitable\r\ncollision handler is listed.\r\n\r\n@param <C1>\r\n\t\tThe collider type.\r\n@param <C2>\r\n\t\tThe collidee (unit that was moved into) type.\r\n@param collider\r\n\t\tThe collider.\r\n@param collidee\r\n\t\tThe collidee.\r\n", "metaSrc": "source code", "description": "Handles collisions between units in the game board by determining appropriate collision handlers based on their classes.", "returns": "", "reason": "This method provides a flexible and extensible way to handle collisions in the game board by allowing different collision handlers for different types of units.", "howToUse": "To use this method, you need to provide two instances of `Unit` that are colliding. The method will determine the most specific collision handler based on their classes and call it to handle the collision.", "howItWorks": "The method first retrieves the most specific class for both the collider and collidee from a map of handlers. It then checks if there is a collision handler for the collidee's class. If so, it calls the handler with the collider and collidee as arguments.", "assertions": {"preConditions": ["The method expects two instances of `Unit` that are colliding."], "postConditions": ["If a collision handler is found for the collidee's class, it will be called to handle the collision. If no handler is found, nothing happens."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).2", "labels": ["Variable"], "properties": {"simpleName": "startPositions", "qualifiedName": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "parseMap(java.lang.String)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "kind": "method", "sourceText": "/**\r\n * Parses the provided input stream as a character stream and passes it\r\n * result to {@link #parseMap(List)}.\r\n *\r\n * @param mapName\r\n * \t\tName of a resource that will be read.\r\n * @return The parsed level as represented by the text on the input stream.\r\n * @throws IOException\r\n * \t\twhen the resource could not be read.\r\n */\r\n@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = { \"OBL_UNSATISFIED_OBLIGATION\", \"RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE\" }, justification = \"try with resources always cleans up / false positive in java 11\")\r\npublic nl.tudelft.jpacman.level.Level parseMap(java.lang.String mapName) throws java.io.IOException {\r\n    try (java.io.InputStream boardStream = nl.tudelft.jpacman.level.MapParser.class.getResourceAsStream(mapName)) {\r\n        if (boardStream == null) {\r\n            throw new nl.tudelft.jpacman.PacmanConfigurationException(\"Could not get resource for: \" + mapName);\r\n        }\r\n        return this.parseMap(boardStream);\r\n    }\r\n}", "docComment": "Parses the provided input stream as a character stream and passes it\r\nresult to {@link #parseMap(List)}.\r\n\r\n@param mapName\r\n\t\tName of a resource that will be read.\r\n@return The parsed level as represented by the text on the input stream.\r\n@throws IOException\r\n\t\twhen the resource could not be read.\r\n", "metaSrc": "source code", "description": "Parses a map file into a game level for Pacman.", "returns": "An instance of nl.tudelft.jpacman.level.Level representing the parsed game level.", "reason": "This method is responsible for loading and parsing a map file into a game level, which is a core functionality in the Pacman game implementation.", "howToUse": "Call this method with the name of the map file to parse. The method will return an instance of Level that represents the parsed map.", "howItWorks": "The method uses Java's `getResourceAsStream` to obtain an input stream for the specified map file. It checks if the stream is null and throws a configuration exception if it is not found. If the stream is valid, it calls the `parseMap` method with the input stream as an argument.", "assertions": {"preConditions": ["The provided mapName is a valid string representing the name of the map file."], "postConditions": ["The returned Level instance represents the parsed game level from the specified map file."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "intervalVariation", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The variation in milliseconds for the ghost's movement interval."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getSquare()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSquare()", "qualifiedName": "nl.tudelft.jpacman.board.Unit.getSquare()", "kind": "method", "sourceText": "/**\r\n * Returns the square this unit is currently occupying.\r\n * Precondition: <code>hasSquare()</code>.\r\n *\r\n * @return The square this unit is currently occupying.\r\n */\r\npublic nl.tudelft.jpacman.board.Square getSquare() {\r\n    assert this.invariant();\r\n    assert this.square != null;\r\n    return this.square;\r\n}", "docComment": "Returns the square this unit is currently occupying.\r\nPrecondition: <code>hasSquare()</code>.\r\n\r\n@return The square this unit is currently occupying.\r\n", "metaSrc": "source code", "description": "Returns the square on which the unit is currently located.", "returns": "The Square object representing the current location of the Unit.", "reason": "This method provides a straightforward way to access the current position of a Pacman-like game unit, ensuring that the unit's state is consistent and valid before returning its square.", "howToUse": "Call this method on an instance of a Unit class to retrieve the Square object where the unit is currently positioned.", "howItWorks": "The method first checks if the unit's invariant (i.e., it is on a square) and then returns the square attribute, which holds the current location of the unit.", "assertions": {"preConditions": ["this.invariant() must return true", "this.square must not be null"], "postConditions": ["the returned Square object represents the current position of the Unit"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "addStopButton(nl.tudelft.jpacman.game.Game)", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "kind": "method", "sourceText": "/**\r\n * Adds a button with the caption {@value #STOP_CAPTION} that stops the\r\n * game.\r\n *\r\n * @param game\r\n * \t\tThe game to stop.\r\n */\r\nprivate void addStopButton(final nl.tudelft.jpacman.game.Game game) {\r\n    assert game != null;\r\n    this.buttons.put(nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION, game::stop);\r\n}", "docComment": "Adds a button with the caption {@value #STOP_CAPTION} that stops the\r\ngame.\r\n\r\n@param game\r\n\t\tThe game to stop.\r\n", "metaSrc": "source code", "description": "Adds a stop button to the game UI that stops the game when clicked.", "returns": "", "reason": "The method provides functionality for adding a stop button to the game's user interface, allowing users to pause or terminate the game execution.", "howToUse": "Call this method with an instance of nl.tudelft.jpacman.game.Game as an argument to add a stop button to the UI.", "howItWorks": "The method uses the buttons.put() method to associate the STOP_CAPTION key with a lambda expression that calls the game's stop() method when executed.", "assertions": {"preConditions": ["game is not null"], "postConditions": []}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator).0", "labels": ["Variable"], "properties": {"simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel", "labels": ["Structure"], "properties": {"docComment": "Panel displaying a game.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "BoardPanel", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel", "kind": "class", "metaSrc": "source code", "description": "The BoardPanel class is responsible for rendering and managing the visual representation of the Pacman game board, including drawing squares, sprites, and units.", "layer": "Presentation Layer", "roleStereotype": "User Interfacer", "keywords": ["render", "board", "graphics", "game", "pacman"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "update()", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "kind": "method", "sourceText": "/**\r\n * Updates the current frame index depending on the current system time.\r\n */\r\nprivate void update() {\r\n    long now = java.lang.System.currentTimeMillis();\r\n    if (this.animating) {\r\n        while (this.lastUpdate < now) {\r\n            this.lastUpdate += this.animationDelay;\r\n            this.current++;\r\n            if (this.looping) {\r\n                this.current %= this.animationFrames.length;\r\n            } else if (this.current == this.animationFrames.length) {\r\n                this.animating = false;\r\n            }\r\n        } \r\n    } else {\r\n        this.lastUpdate = now;\r\n    }\r\n}", "docComment": "Updates the current frame index depending on the current system time.\r\n", "metaSrc": "source code", "description": "Updates the animation state of an animated sprite by advancing to the next frame if the current time exceeds the last update time plus the animation delay.", "returns": "", "reason": "The method manages the animation of a sprite, updating its appearance over time based on predefined frames and delays.", "howToUse": "Call this method in the main game loop to animate sprites like Pacman or other animated entities.", "howItWorks": "The method checks if the sprite is animating. If so, it calculates the current frame by adding the animation delay to the last update time. It then updates the current frame index and handles looping behavior. If not animating, it simply records the current time as the last update time.", "assertions": {"preConditions": ["The method is called in a game loop where the sprite's animation state is managed.", "The `animating` flag is set to true if the sprite should animate."], "postConditions": ["The sprite's current frame index is updated based on the elapsed time since the last update.", "If looping is enabled, the frame index wraps around after reaching the end of the animation frames."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).2", "labels": ["Variable"], "properties": {"simpleName": "parent", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidee", "qualifiedName": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that is being collided with by the collider."}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.level", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The level of this game.\r\n */\r\nprivate final nl.tudelft.jpacman.level.Level level;", "visibility": "private", "simpleName": "level", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame.level", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.killer", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * {@link Unit} iff this player died by collision, <code>null</code> otherwise.\r\n */\r\nprivate nl.tudelft.jpacman.board.Unit killer;", "visibility": "private", "simpleName": "killer", "qualifiedName": "nl.tudelft.jpacman.level.Player.killer", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).3", "labels": ["Variable"], "properties": {"simpleName": "grid", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The grid of squares to be populated."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.intervalVariation", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The random variation added to the {@link #moveInterval}.\r\n */\r\nprivate final int intervalVariation;", "visibility": "private", "simpleName": "intervalVariation", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.intervalVariation", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.util.Map)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new \"Inky\".\r\n *\r\n * @param spriteMap\r\n * \t\tThe sprites for this ghost.\r\n */\r\npublic Inky(java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> spriteMap) {\r\n    super(spriteMap, nl.tudelft.jpacman.npc.ghost.Inky.MOVE_INTERVAL, nl.tudelft.jpacman.npc.ghost.Inky.INTERVAL_VARIATION);\r\n}", "docComment": "Creates a new \"Inky\".\r\n\r\n@param spriteMap\r\n\t\tThe sprites for this ghost.\r\n", "metaSrc": "source code", "description": "Initializes an Inky ghost with a specified sprite map, move interval, and interval variation.", "returns": "A newly created Inky ghost instance.", "reason": "This method initializes a new Ghost instance with specific parameters, which is essential for the game's logic and rendering.", "howToUse": "Create an instance of Inky by passing a sprite map to its constructor. This setup is crucial for the ghost's appearance and movement in the game.", "howItWorks": "The method calls the superclass constructor with the provided sprite map, move interval, and interval variation. This initializes the ghost's properties and behavior.", "assertions": {"preConditions": ["A valid Map<Direction, Sprite> is provided."], "postConditions": ["An Inky ghost instance is created with the specified parameters."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String).0", "labels": ["Variable"], "properties": {"simpleName": "fileName", "qualifiedName": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startNPCs()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "startNPCs()", "qualifiedName": "nl.tudelft.jpacman.level.Level.startNPCs()", "kind": "method", "sourceText": "/**\r\n * Starts all NPC movement scheduling.\r\n */\r\nprivate void startNPCs() {\r\n    for (final nl.tudelft.jpacman.npc.Ghost npc : this.npcs.keySet()) {\r\n        java.util.concurrent.ScheduledExecutorService service = java.util.concurrent.Executors.newSingleThreadScheduledExecutor();\r\n        service.schedule(new nl.tudelft.jpacman.level.Level.NpcMoveTask(service, npc), npc.getInterval() / 2, java.util.concurrent.TimeUnit.MILLISECONDS);\r\n        this.npcs.put(npc, service);\r\n    }\r\n}", "docComment": "Starts all NPC movement scheduling.\r\n", "metaSrc": "source code", "description": "Starts scheduled tasks for each ghost in the level to move at regular intervals.", "returns": "", "reason": "The method manages the movement of ghosts in the game, ensuring they follow a predefined interval.", "howToUse": "Call this method after initializing the level to start the ghost movement tasks.", "howItWorks": "For each ghost, it creates a single-threaded scheduled executor service and schedules a task that moves the ghost at half of its interval. The task is then stored in the `npcs` map with the ghost as the key.", "assertions": {"preConditions": ["The level has been initialized with ghosts.", "The `npcs` map is not null or empty."], "postConditions": ["All scheduled tasks for ghost movement are active and running."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "occupant", "qualifiedName": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit to be removed from the square."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "loadSprite(java.lang.String)", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "kind": "method", "sourceText": "/**\r\n * Overloads the default sprite loading, ignoring the exception. This class\r\n * assumes all sprites are provided, hence the exception will be thrown as a\r\n * {@link RuntimeException}.\r\n *\r\n * {@inheritDoc }\r\n */\r\n@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite loadSprite(java.lang.String resource) {\r\n    try {\r\n        return super.loadSprite(resource);\r\n    } catch (java.io.IOException e) {\r\n        throw new nl.tudelft.jpacman.PacmanConfigurationException(\"Unable to load sprite: \" + resource, e);\r\n    }\r\n}", "docComment": "Overloads the default sprite loading, ignoring the exception. This class\r\nassumes all sprites are provided, hence the exception will be thrown as a\r\n{@link RuntimeException}.\r\n\r\n{@inheritDoc }\r\n", "metaSrc": "source code", "description": "Loads a sprite from a resource file, caching it if it doesn't exist in the cache.", "returns": "A new ImageSprite object representing the loaded sprite.", "reason": "This method provides a robust way to load sprites from resources, ensuring that each sprite is only loaded once and cached for future use. It handles exceptions gracefully by throwing a custom configuration exception if the resource cannot be loaded.", "howToUse": "Call this method with the path to the sprite file as an argument to retrieve or load the sprite.", "howItWorks": "The method attempts to load the sprite using the superclass's `loadSprite` method. If an `IOException` is caught, it throws a custom configuration exception with a descriptive message and the original exception.", "assertions": {"preConditions": ["A valid string representing the resource path must be provided."], "postConditions": ["The returned object should be an instance of ImageSprite if the sprite is successfully loaded, or null if the resource cannot be found."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "launch()", "qualifiedName": "nl.tudelft.jpacman.Launcher.launch()", "kind": "method", "sourceText": "/**\r\n * Creates and starts a JPac-Man game.\r\n */\r\npublic void launch() {\r\n    this.makeGame();\r\n    nl.tudelft.jpacman.ui.PacManUiBuilder builder = new nl.tudelft.jpacman.ui.PacManUiBuilder().withDefaultButtons();\r\n    this.addSinglePlayerKeys(builder);\r\n    this.pacManUI = builder.build(this.getGame());\r\n    this.pacManUI.start();\r\n}", "docComment": "Creates and starts a JPac-Man game.\r\n", "metaSrc": "source code", "description": "Launches a single-player PacMan game by creating, configuring, and starting the UI.", "returns": "A new instance of nl.tudelft.jpacman.ui.PacManUI", "reason": "The method orchestrates the creation and execution of a PacMan game, integrating various components to provide an interactive gaming experience.", "howToUse": "Call `launch()` on an instance of `nl.tudelft.jpacman.Launcher` to start the game.", "howItWorks": "1. Creates a new single-player game using `makeGame()`. 2. Configures the UI with default buttons and key bindings using `PacManUiBuilder`. 3. Builds the PacMan UI for the game and starts it.", "assertions": {"preConditions": ["An instance of nl.tudelft.jpacman.Launcher is created."], "postConditions": ["A new instance of nl.tudelft.jpacman.ui.PacManUI is returned."]}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List).0", "labels": ["Variable"], "properties": {"simpleName": "text", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A list of strings representing the rows of the map."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.getHeight()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getHeight()", "qualifiedName": "nl.tudelft.jpacman.board.Board.getHeight()", "kind": "method", "sourceText": "/**\r\n * Returns the number of rows.\r\n *\r\n * @return The height of this board.\r\n */\r\npublic int getHeight() {\r\n    return this.board[0].length;\r\n}", "docComment": "Returns the number of rows.\r\n\r\n@return The height of this board.\r\n", "metaSrc": "source code", "description": "Returns the height of the board, which is the number of rows in the grid.", "returns": "The height of the board as an integer.", "reason": "This method provides a straightforward way to access the height of the game board, which is essential for determining the layout and boundaries of the game entities.", "howToUse": "To use this method, simply call it on an instance of the Board class. It will return the number of rows in the grid.", "howItWorks": "The method accesses the first row of the board array (`this.board[0]`) and returns its length, which represents the height of the board.", "preConditions": [], "postConditions": ["The returned value is an integer representing the height of the board."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeLevel()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "makeLevel()", "qualifiedName": "nl.tudelft.jpacman.Launcher.makeLevel()", "kind": "method", "sourceText": "/**\r\n * Creates a new level. By default this method will use the map parser to\r\n * parse the default board stored in the <code>board.txt</code> resource.\r\n *\r\n * @return A new level.\r\n */\r\npublic nl.tudelft.jpacman.level.Level makeLevel() {\r\n    try {\r\n        return this.getMapParser().parseMap(this.getLevelMap());\r\n    } catch (java.io.IOException e) {\r\n        throw new nl.tudelft.jpacman.PacmanConfigurationException(\"Unable to create level, name = \" + this.getLevelMap(), e);\r\n    }\r\n}", "docComment": "Creates a new level. By default this method will use the map parser to\r\nparse the default board stored in the <code>board.txt</code> resource.\r\n\r\n@return A new level.\r\n", "metaSrc": "source code", "description": "Parses a map file into a game level for Pacman.", "returns": "An instance of nl.tudelft.jpacman.level.Level representing the parsed game level.", "reason": "The method is responsible for loading and parsing the game level from a specified map file, which is essential for initializing the game environment.", "howToUse": "Call this method to create a new game level based on the provided map file name.", "howItWorks": "The method uses the MapParser to parse the map file into a Level object. It retrieves the necessary factories and passes them to the parser, which then reads the map file and constructs the level accordingly.", "assertions": {"preConditions": ["A valid map file name is provided.", "The MapParser is properly initialized with the required factories."], "postConditions": ["A Level object representing the parsed game level is returned."]}, "layer": "Service Layer"}}}, {"data": {"id": "double", "labels": ["Primitive"], "properties": {"simpleName": "double", "qualifiedName": "double", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pointCalculator", "labels": ["Variable"], "properties": {"sourceText": "private nl.tudelft.jpacman.points.PointCalculator pointCalculator;", "visibility": "private", "simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.pointCalculator", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.ORANGE", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Pokey, a.k.a. Clyde.\r\n */\r\nORANGE()", "visibility": "public", "simpleName": "ORANGE", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostColor.ORANGE", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSprite()", "qualifiedName": "nl.tudelft.jpacman.board.Square.getSprite()", "kind": "method", "sourceText": "/**\r\n * Returns the sprite of this square.\r\n *\r\n * @return The sprite of this square.\r\n */\r\npublic abstract nl.tudelft.jpacman.sprite.Sprite getSprite();", "docComment": "Returns the sprite of this square.\r\n\r\n@return The sprite of this square.\r\n", "metaSrc": "source code", "description": "Returns the sprite associated with the square.", "returns": "A Sprite object representing the visual representation of the square.", "reason": "The method provides a way to access and display the graphical representation of each square on the game board, which is essential for rendering the game's visual elements.", "howToUse": "To use this method, call it on an instance of Square. It will return the Sprite object that should be displayed for that particular square.", "howItWorks": "The method returns a reference to the sprite associated with the current square. This is typically done by accessing a field or property within the Square class that holds the sprite information.", "preConditions": ["An instance of Square exists.", "The square has been initialized and configured with a sprite."], "postConditions": ["A Sprite object is returned, representing the visual representation of the square on the game board."], "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square).0", "labels": ["Variable"], "properties": {"simpleName": "target", "qualifiedName": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The square to which the unit will occupy."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startSquares", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The squares from which players can start this game.\r\n */\r\nprivate final java.util.List<nl.tudelft.jpacman.board.Square> startSquares;", "visibility": "private", "simpleName": "startSquares", "qualifiedName": "nl.tudelft.jpacman.level.Level.startSquares", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.getWidth()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getWidth()", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.getWidth()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic int getWidth() {\r\n    return 0;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player object to be registered."}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(nl.tudelft.jpacman.sprite.Sprite)", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new wall square.\r\n *\r\n * @param sprite\r\n * \t\tThe background for the square.\r\n */\r\nWall(nl.tudelft.jpacman.sprite.Sprite sprite) {\r\n    super();\r\n    this.background = sprite;\r\n}", "docComment": "Creates a new wall square.\r\n\r\n@param sprite\r\n\t\tThe background for the square.\r\n", "metaSrc": "source code", "description": "Initializes a new Wall object by setting its background sprite.", "returns": "A newly created Wall instance with the specified background sprite.", "reason": "This method is part of the Domain Layer as it initializes a domain entity (Wall) and sets its properties based on input parameters.", "howToUse": "Create a new Wall object by passing a Sprite to the constructor. This will initialize the wall with the given background image.", "howItWorks": "The constructor calls the superclass constructor (`super()`) to initialize the Square base class, then assigns the provided sprite to the `background` field of the Wall instance.", "assertions": {"preConditions": ["A valid Sprite object is passed as an argument."], "postConditions": ["The Wall instance has been created with the specified background sprite."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).2", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The height of the grid."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "labels": ["Variable"], "properties": {"simpleName": "collider", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The collider type."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.getWidth()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getWidth()", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.getWidth()", "kind": "method", "sourceText": "/**\r\n * Returns the width of this sprite.\r\n *\r\n * @return The width in pixels.\r\n */\r\nint getWidth();", "docComment": "Returns the width of this sprite.\r\n\r\n@return The width in pixels.\r\n", "metaSrc": "source code", "description": "Returns the width of the sprite in pixels.", "returns": "The width of the sprite as an integer.", "reason": "This method provides a basic property of the sprite, which is essential for rendering and layout calculations.", "howToUse": "Call getWidth() on any instance of Sprite to retrieve its width in pixels.", "howItWorks": "The implementation retrieves the width from the internal state or configuration of the sprite object.", "preConditions": [], "postConditions": ["The returned value is an integer representing the width of the sprite in pixels."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "graphics", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The Graphics object used for drawing."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The width of the region to split."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "kind": "method", "sourceText": "/**\r\n * Creates a new {@link AnimatedSprite} from a base image.\r\n *\r\n * @param baseImage\r\n * \t\tThe base image to convert into an animation.\r\n * @param frames\r\n * \t\tThe amount of frames of the animation.\r\n * @param delay\r\n * \t\tThe delay between frames.\r\n * @param loop\r\n * \t\tWhether this sprite is a looping animation or not.\r\n * @return The animated sprite.\r\n */\r\npublic nl.tudelft.jpacman.sprite.AnimatedSprite createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite baseImage, int frames, int delay, boolean loop) {\r\n    assert baseImage != null;\r\n    assert frames > 0;\r\n    int frameWidth = baseImage.getWidth() / frames;\r\n    nl.tudelft.jpacman.sprite.Sprite[] animation = new nl.tudelft.jpacman.sprite.Sprite[frames];\r\n    for (int i = 0; i < frames; i++) {\r\n        animation[i] = baseImage.split(i * frameWidth, 0, frameWidth, baseImage.getHeight());\r\n    }\r\n    return new nl.tudelft.jpacman.sprite.AnimatedSprite(animation, delay, loop);\r\n}", "docComment": "Creates a new {@link AnimatedSprite} from a base image.\r\n\r\n@param baseImage\r\n\t\tThe base image to convert into an animation.\r\n@param frames\r\n\t\tThe amount of frames of the animation.\r\n@param delay\r\n\t\tThe delay between frames.\r\n@param loop\r\n\t\tWhether this sprite is a looping animation or not.\r\n@return The animated sprite.\r\n", "metaSrc": "source code", "description": "Creates an animated sprite by splitting the base image into multiple frames and returning an AnimatedSprite object.", "returns": "A new AnimatedSprite object representing the animated sprite.", "reason": "This method is part of the Domain Layer as it handles the creation of an animated sprite based on a base image and configuration parameters.", "howToUse": "Call this method with a base image, number of frames, delay, and loop flag to create an animated sprite.", "howItWorks": "The method splits the base image into multiple frames based on the number of frames specified. It then creates an AnimatedSprite object using these frames and the provided delay and loop settings.", "assertions": {"preConditions": ["baseImage is not null", "frames > 0"], "postConditions": ["Returns a new AnimatedSprite object"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).3", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The x-coordinate of the current position in the map file."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.dispose()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "dispose()", "qualifiedName": "nl.tudelft.jpacman.Launcher.dispose()", "kind": "method", "sourceText": "/**\r\n * Disposes of the UI. For more information see\r\n * {@link javax.swing.JFrame#dispose()}.\r\n *\r\n * Precondition: The game was launched first.\r\n */\r\npublic void dispose() {\r\n    assert this.pacManUI != null;\r\n    this.pacManUI.dispose();\r\n}", "docComment": "Disposes of the UI. For more information see\r\n{@link javax.swing.JFrame#dispose()}.\r\n\r\nPrecondition: The game was launched first.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int).0", "labels": ["Variable"], "properties": {"simpleName": "amountToLookAhead", "qualifiedName": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The number of squares to look ahead."}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator()", "kind": "constructor", "sourceText": "DefaultPointCalculator() {\r\n    super();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.addPoints(int).0", "labels": ["Variable"], "properties": {"simpleName": "points", "qualifiedName": "nl.tudelft.jpacman.level.Player.addPoints(int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The number of points to add."}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.stop()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "stop()", "qualifiedName": "nl.tudelft.jpacman.game.Game.stop()", "kind": "method", "sourceText": "/**\r\n * Pauses the game.\r\n */\r\npublic void stop() {\r\n    synchronized(this.progressLock) {\r\n        if (!this.isInProgress()) {\r\n            return;\r\n        }\r\n        this.inProgress = false;\r\n        this.getLevel().stop();\r\n    }\r\n}", "docComment": "Pauses the game.\r\n", "metaSrc": "source code", "description": "Stops the game by setting the in-progress flag to false and stopping the current level.", "returns": "", "reason": "The method is part of the Game class, which represents the main logic of the Pacman game. It stops the game when it's no longer in progress.", "howToUse": "Call `stop()` on an instance of the Game class to stop the game.", "howItWorks": "The method synchronizes access to the progressLock to ensure thread safety, checks if the game is in progress, sets the in-progress flag to false, and calls the stop() method on the current level.", "assertions": {"preConditions": ["Game instance exists"], "postConditions": ["Game is no longer in progress", "Level's progress is set to false"]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory).0", "labels": ["Variable"], "properties": {"simpleName": "playerFactory", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc", "labels": ["Container"], "properties": {"simpleName": "npc", "qualifiedName": "nl.tudelft.jpacman.npc", "kind": "package", "metaSrc": "source code", "description": "Manages navigation and pathfinding for ghosts in the Pac-Man game, providing utility to navigate on squares.", "layer": "Service Layer", "title": "Ghost Navigation", "keywords": ["ghost", "navigation", "pathfinding"]}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).2", "labels": ["Variable"], "properties": {"simpleName": "startPositions", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "A list to store starting positions for players."}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "labels": ["Variable"], "properties": {"simpleName": "ghost", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The ghost object that collided with the player."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The x-coordinate where to start rendering the square."}}}, {"data": {"id": "nl.tudelft.jpacman.board", "labels": ["Container"], "properties": {"simpleName": "board", "qualifiedName": "nl.tudelft.jpacman.board", "kind": "package", "metaSrc": "source code", "description": "Manages game board components, including squares and walls, for creating playable grids in the Pacman implementation.", "layer": "Domain Layer", "title": "Game Board Management", "keywords": ["game", "board", "components", "squares", "walls"]}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).1", "labels": ["Variable"], "properties": {"simpleName": "frames", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The number of frames for each animation."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).2", "labels": ["Variable"], "properties": {"simpleName": "width", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "qualifiedName": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new level for the board.\r\n *\r\n * @param board\r\n * \t\tThe board for the level.\r\n * @param ghosts\r\n * \t\tThe ghosts on the board.\r\n * @param startPositions\r\n * \t\tThe squares on which players start on this board.\r\n * @param collisionMap\r\n * \t\tThe collection of collisions that should be handled.\r\n */\r\npublic Level(nl.tudelft.jpacman.board.Board board, java.util.List<nl.tudelft.jpacman.npc.Ghost> ghosts, java.util.List<nl.tudelft.jpacman.board.Square> startPositions, nl.tudelft.jpacman.level.CollisionMap collisionMap) {\r\n    super();\r\n    assert board != null;\r\n    assert ghosts != null;\r\n    assert startPositions != null;\r\n    this.board = board;\r\n    this.inProgress = false;\r\n    this.npcs = new java.util.HashMap<nl.tudelft.jpacman.npc.Ghost, java.util.concurrent.ScheduledExecutorService>();\r\n    for (nl.tudelft.jpacman.npc.Ghost ghost : ghosts) {\r\n        this.npcs.put(ghost, null);\r\n    }\r\n    this.startSquares = startPositions;\r\n    this.startSquareIndex = 0;\r\n    this.players = new java.util.ArrayList<nl.tudelft.jpacman.level.Player>();\r\n    this.collisions = collisionMap;\r\n    this.observers = new java.util.HashSet<nl.tudelft.jpacman.level.Level.LevelObserver>();\r\n}", "docComment": "Creates a new level for the board.\r\n\r\n@param board\r\n\t\tThe board for the level.\r\n@param ghosts\r\n\t\tThe ghosts on the board.\r\n@param startPositions\r\n\t\tThe squares on which players start on this board.\r\n@param collisionMap\r\n\t\tThe collection of collisions that should be handled.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).5", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).5", "kind": "parameter", "parameterPosition": 5, "metaSrc": "source code", "description": "The height of the area to render the square."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).1", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startStopLock", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The lock that ensures starting and stopping can't interfere with each\r\n * other.\r\n */\r\nprivate final java.lang.Object startStopLock = new java.lang.Object();", "visibility": "private", "simpleName": "startStopLock", "qualifiedName": "nl.tudelft.jpacman.level.Level.startStopLock", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game).0", "labels": ["Variable"], "properties": {"simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "moveInterval", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The base interval in milliseconds for the ghost's movement."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.keyMappings", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Map of key events and their actions.\r\n */\r\nprivate final java.util.Map<java.lang.Integer, nl.tudelft.jpacman.ui.Action> keyMappings;", "visibility": "private", "simpleName": "keyMappings", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.keyMappings", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game).0", "labels": ["Variable"], "properties": {"simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The game instance to which the start button will be added."}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "labels": ["Variable"], "properties": {"simpleName": "collidee", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The type of the collidee unit."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "remainingPellets()", "qualifiedName": "nl.tudelft.jpacman.level.Level.remainingPellets()", "kind": "method", "sourceText": "/**\r\n * Counts the pellets remaining on the board.\r\n *\r\n * @return The amount of pellets remaining on the board.\r\n */\r\npublic int remainingPellets() {\r\n    nl.tudelft.jpacman.board.Board board = this.getBoard();\r\n    int pellets = 0;\r\n    for (int x = 0; x < board.getWidth(); x++) {\r\n        for (int y = 0; y < board.getHeight(); y++) {\r\n            for (nl.tudelft.jpacman.board.Unit unit : board.squareAt(x, y).getOccupants()) {\r\n                if (unit instanceof nl.tudelft.jpacman.level.Pellet) {\r\n                    pellets++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    assert pellets >= 0;\r\n    return pellets;\r\n}", "docComment": "Counts the pellets remaining on the board.\r\n\r\n@return The amount of pellets remaining on the board.\r\n", "metaSrc": "source code", "description": "Counts the number of pellets remaining on the game board.", "returns": "The total count of pellets on the board as an integer.", "reason": "This method is essential for maintaining the game state and providing feedback to the player about the remaining resources in the game.", "howToUse": "Call this method to get the current number of pellets left on the board.", "howItWorks": "The method iterates over each square on the board, checks if it contains any pellets, and increments a counter for each pellet found. The final count is returned.", "assertions": {"preConditions": ["The board object must be valid and not null."], "postConditions": ["The returned value must be an integer representing the number of pellets on the board."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "labels": ["Structure"], "properties": {"docComment": "Factory that creates ghosts.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "GhostFactory", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "kind": "class", "metaSrc": "source code", "description": "The GhostFactory class is responsible for creating instances of different ghost characters in the Pacman game using specified sprites. It acts as a service provider by providing methods to create specific types of ghosts based on their color and sprite configurations.", "layer": "Domain Layer", "roleStereotype": "Service Provider", "keywords": ["GhostFactory", "Pacman", "Ghosts", "SpriteProvider", "Blinky", "Clyde", "Inky", "Pinky"], "dependencyProfile": "transit"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(java.util.Map)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new \"Blinky\", a.k.a. \"Shadow\".\r\n *\r\n * @param spriteMap\r\n * \t\tThe sprites for this ghost.\r\n */\r\n// TODO Blinky should speed up when there are a few pellets left, but he\r\n// has no way to find out how many there are.\r\npublic Blinky(java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> spriteMap) {\r\n    super(spriteMap, nl.tudelft.jpacman.npc.ghost.Blinky.MOVE_INTERVAL, nl.tudelft.jpacman.npc.ghost.Blinky.INTERVAL_VARIATION);\r\n}", "docComment": "Creates a new \"Blinky\", a.k.a. \"Shadow\".\r\n\r\n@param spriteMap\r\n\t\tThe sprites for this ghost.\r\n", "metaSrc": "source code", "description": "Initializes a Blinky ghost with specified sprite map, move interval, and interval variation.", "returns": "A newly created Blinky ghost instance.", "reason": "This method initializes a new Ghost instance with specific configurations, which is part of the domain layer where business logic and object creation are handled.", "howToUse": "To use this method, provide a map of sprites for each direction and specify the move interval and interval variation. This setup will create a Blinky ghost with the given properties.", "howItWorks": "The method calls the superclass constructor with the provided sprite map, move interval, and interval variation. This initializes the Blinky ghost's attributes and behavior based on these parameters.", "assertions": {"preConditions": ["A valid Map of sprites for each direction is provided."], "postConditions": ["A new Blinky ghost instance is created with the specified properties."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI", "labels": ["Structure"], "properties": {"docComment": "The default JPacMan UI frame. The PacManUI consists of the following\r\nelements:\r\n\r\n<ul>\r\n<li>A score panel at the top, displaying the score of the player(s).\r\n<li>A board panel, displaying the current level, i.e. the board and all units\r\non it.\r\n<li>A button panel, containing all buttons provided upon creation.\r\n</ul>\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "PacManUI", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI", "kind": "class", "metaSrc": "source code", "description": "The PacManUI class is responsible for managing the user interface components and handling game updates in a JPacman game.", "layer": "Presentation Layer", "roleStereotype": "User Interfacer", "keywords": ["PacMan", "user interface", "game management", "score panel", "board panel"], "dependencyProfile": "transit"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "setAnimating(boolean)", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "kind": "method", "sourceText": "/**\r\n * Starts or stops the animation of this sprite.\r\n *\r\n * @param isAnimating\r\n * \t\t<code>true</code> to animate this sprite or <code>false</code>\r\n * \t\tto stop animating this sprite.\r\n */\r\npublic void setAnimating(boolean isAnimating) {\r\n    this.animating = isAnimating;\r\n}", "docComment": "Starts or stops the animation of this sprite.\r\n\r\n@param isAnimating\r\n\t\t<code>true</code> to animate this sprite or <code>false</code>\r\n\t\tto stop animating this sprite.\r\n", "metaSrc": "source code", "description": "Sets whether the animated sprite is currently animating.", "returns": "", "reason": "This method allows controlling the animation state of an animated sprite, which is a fundamental operation in managing visual effects and animations in game development.", "howToUse": "Call `setAnimating(true)` to start animating the sprite, or `setAnimating(false)` to stop it.", "howItWorks": "The method simply assigns the provided boolean value to the `animating` field of the class. This change triggers any internal logic that handles animation updates, such as starting or stopping animations based on this flag.", "preConditions": ["The method is called with a boolean value.", "The animated sprite instance exists and has been properly initialized."], "postConditions": ["The `animating` field of the animated sprite is updated to the provided boolean value.", "Any internal animation logic that depends on this state is triggered accordingly."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "labels": ["Structure"], "properties": {"docComment": "Helper class to keep track of the path.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Node", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "kind": "class", "metaSrc": "source code", "description": "The Navigation$Node class is responsible for managing navigation paths in the Pacman game, providing information about ghost positions and directions, and facilitating pathfinding.", "layer": "Service Layer", "roleStereotype": "Structurer", "keywords": ["navigation", "ghost", "pathfinding", "directions", "square"], "dependencyProfile": "hidden"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky", "labels": ["Structure"], "properties": {"docComment": "<p>\r\nAn implementation of the classic Pac-Man ghost Speedy.\r\n</p>\r\n<p>\r\nNickname: Pinky. Speedy gets his name for an unusual reason. Speedy appears\r\nto try to outsmart Pac-Man and crash into Pac-Man from the opposite\r\ndirection. The truth behind this is that when Speedy isn't patrolling the\r\ntop-left corner of the maze, he tries to attack Pac-Man by moving to where he\r\nis going to be (that is, a few spaces ahead of Pac-Man's current direction)\r\ninstead of right where he is, as Blinky does. It's difficult to use this to\r\nyour advantage, but it's possible. If Pinky is coming at you and you face a\r\ndifferent direction, even briefly, he may just turn away and attempt to cut\r\nyou off in the new direction while you return to your original direction. In\r\nthe original Japanese version, his name is Machibuse/Pinky.\r\n</p>\r\n<p>\r\n<b>AI:</b> When the ghosts are not patrolling their home corners, Pinky wants\r\nto go to the place that is four grid spaces ahead of Pac-Man in the direction\r\nthat Pac-Man is facing. If Pac-Man is facing down, Pinky wants to go to the\r\nlocation exactly four spaces below Pac-Man. Moving towards this place uses\r\nthe same logic that Blinky uses to find Pac-Man's exact location. Pinky is\r\naffected by a targeting bug if Pac-Man is facing up - when he moves or faces\r\nup, Pinky tries moving towards a point up, and left, four spaces.\r\n</p>\r\n<p>\r\n<i>Note: In the original arcade series, the ghosts' genders are unspecified\r\nand assumed to be male. In 1999, the USA division of Namco and Namco Hometech\r\ndeveloped the Pac-Man World series and declared Pinky to be female.</i>\r\n</p>\r\n<p>\r\nSource: http://strategywiki.org/wiki/Pac-Man/Getting_Started\r\n</p>\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Pinky", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Pinky", "kind": "class", "metaSrc": "source code", "description": "The Pinky class is responsible for managing the AI logic and movement of the 'Speedy' ghost NPC in the Pacman game. It calculates the shortest path to the nearest player and determines the next move based on their direction.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["Pacman", "Ghost", "AI Logic", "Movement", "Pathfinding"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game).0", "labels": ["Variable"], "properties": {"simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The game instance to initialize the board panel with."}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "defaultCollisions()", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "kind": "method", "sourceText": "/**\r\n * Creates the default collisions Player-Ghost and Player-Pellet.\r\n *\r\n * @return The collision map containing collisions for Player-Ghost and\r\nPlayer-Pellet.\r\n */\r\nprivate nl.tudelft.jpacman.level.CollisionInteractionMap defaultCollisions() {\r\n    nl.tudelft.jpacman.level.CollisionInteractionMap collisionMap = new nl.tudelft.jpacman.level.CollisionInteractionMap();\r\n    collisionMap.onCollision(nl.tudelft.jpacman.level.Player.class, nl.tudelft.jpacman.npc.Ghost.class, (nl.tudelft.jpacman.level.Player player,nl.tudelft.jpacman.npc.Ghost ghost) -> {\r\n        this.pointCalculator.collidedWithAGhost(player, ghost);\r\n        player.setAlive(false);\r\n        player.setKiller(ghost);\r\n    });\r\n    collisionMap.onCollision(nl.tudelft.jpacman.level.Player.class, nl.tudelft.jpacman.level.Pellet.class, (nl.tudelft.jpacman.level.Player player,nl.tudelft.jpacman.level.Pellet pellet) -> {\r\n        this.pointCalculator.consumedAPellet(player, pellet);\r\n        pellet.leaveSquare();\r\n    });\r\n    return collisionMap;\r\n}", "docComment": "Creates the default collisions Player-Ghost and Player-Pellet.\r\n\r\n@return The collision map containing collisions for Player-Ghost and\r\nPlayer-Pellet.\r\n", "metaSrc": "source code", "description": "Adds collision handlers for player-ghost and player-pellet interactions in the game.", "returns": "A CollisionInteractionMap containing collision handlers for player-ghost and player-pellet interactions.", "reason": "The method initializes a collision map that defines how players interact with ghosts and pellets, which is essential for the game's mechanics.", "howToUse": "Call this method to set up collision handling in the game. It should be called during the initialization of the level or when the game starts.", "howItWorks": "The method creates a new CollisionInteractionMap and adds two handlers: one for player-ghost collisions and another for player-pellet collisions. Each handler updates the player's state based on the collision type.", "assertions": {"preConditions": ["A CollisionInteractionMap is available to add collision handlers."], "postConditions": ["The CollisionInteractionMap contains two collision handlers for player-ghost and player-pellet interactions."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0", "labels": ["Variable"], "properties": {"simpleName": "spriteMap", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The sprites for every direction."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Caption for the default stop button.\r\n */\r\nprivate static final java.lang.String STOP_CAPTION = \"Stop\";", "visibility": "private", "simpleName": "STOP_CAPTION", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidedOn", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that collided with the pellet."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSprite()", "qualifiedName": "nl.tudelft.jpacman.level.Player.getSprite()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite getSprite() {\r\n    if (this.isAlive()) {\r\n        return this.sprites.get(this.getDirection());\r\n    }\r\n    return this.deathSprite;\r\n}", "docComment": "", "metaSrc": "source code", "description": "Returns the current sprite of the player based on their direction or death sprite if they are not alive.", "returns": "The current sprite of the player as a Sprite object.", "reason": "This method provides a way to display the player's visual representation in the game, which is essential for the user interface layer.", "howToUse": "Call this method to get the appropriate sprite for the player based on their current state (alive or dead).", "howItWorks": "The method checks if the player is alive. If so, it returns the sprite corresponding to the player's direction. If not, it returns the death sprite.", "preConditions": ["Player object exists and has valid methods 'isAlive()' and 'getDirection()'"], "postConditions": ["Returns a Sprite object representing the player's current state"], "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The direction to move the player."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String).0", "labels": ["Variable"], "properties": {"simpleName": "resource", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The path to the resource file containing the sprite."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "kind": "static method", "sourceText": "/**\r\n * Finds a subtype of Unit in a level.\r\n * This method is very useful for finding the ghosts in the parsed map.\r\n *\r\n * @param clazz\r\n * \t\tthe type to search for.\r\n * @param board\r\n * \t\tthe board to find the unit in.\r\n * @param <T>\r\n * \t\tthe return type, same as the type in clazz.\r\n * @return the first unit found of type clazz, or null.\r\n */\r\npublic static <T extends nl.tudelft.jpacman.board.Unit> T findUnitInBoard(java.lang.Class<T> clazz, nl.tudelft.jpacman.board.Board board) {\r\n    for (int y = 0; y < board.getHeight(); y++) {\r\n        for (int x = 0; x < board.getWidth(); x++) {\r\n            final T ghost = nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(clazz, board.squareAt(x, y));\r\n            if (ghost != null) {\r\n                return ghost;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}", "docComment": "Finds a subtype of Unit in a level.\r\n This method is very useful for finding the ghosts in the parsed map.\r\n\r\n@param clazz\r\n\t\tthe type to search for.\r\n@param board\r\n\t\tthe board to find the unit in.\r\n@param <T>\r\n\t\tthe return type, same as the type in clazz.\r\n@return the first unit found of type clazz, or null.\r\n", "metaSrc": "source code", "description": "Finds an instance of a specified unit class on the game board.", "returns": "A T instance representing the found unit, or null if no such unit is found.", "reason": "This method provides a utility function for searching for units of a specific type on a given board, which is useful in various navigation and game logic scenarios.", "howToUse": "To use this method, you need to provide the class of the unit you are looking for and the game board. It will return the first instance of that unit found on the board or null if no such unit exists.", "howItWorks": "The method iterates over each square on the board using nested loops. For each square, it calls the `findUnit` method to check if there is an occupant of the specified class. If a match is found, it returns that unit immediately. If no units are found after checking all squares, it returns null.", "assertions": {"preConditions": ["The provided board must not be null."], "postConditions": ["If a unit of the specified class is found on the board, it will be returned as an instance of type T. If no such unit is found, null will be returned.", "The method does not modify any state and returns immediately after finding the first matching unit."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).2", "labels": ["Variable"], "properties": {"simpleName": "traveller", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The unit performing the navigation."}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player object involved in the collision."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).1", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The y-coordinate to check."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "kind": "static method", "sourceText": "/**\r\n * Determines whether a square has an occupant of a certain type.\r\n *\r\n * @param type\r\n * \t\tThe type to search for.\r\n * @param square\r\n * \t\tThe square to search.\r\n * @param <T>\r\n * \t\tthe type of unit we searched for.\r\n * @return A unit of type T, iff such a unit occupies this square, or\r\n<code>null</code> of none does.\r\n */\r\n@java.lang.SuppressWarnings(\"unchecked\")\r\npublic static <T extends nl.tudelft.jpacman.board.Unit> T findUnit(java.lang.Class<T> type, nl.tudelft.jpacman.board.Square square) {\r\n    for (nl.tudelft.jpacman.board.Unit unit : square.getOccupants()) {\r\n        if (type.isInstance(unit)) {\r\n            assert unit.hasSquare();\r\n            return ((T) (unit));\r\n        }\r\n    }\r\n    return null;\r\n}", "docComment": "Determines whether a square has an occupant of a certain type.\r\n\r\n@param type\r\n\t\tThe type to search for.\r\n@param square\r\n\t\tThe square to search.\r\n@param <T>\r\n\t\tthe type of unit we searched for.\r\n@return A unit of type T, iff such a unit occupies this square, or\r\n<code>null</code> of none does.\r\n", "metaSrc": "source code", "description": "Finds an instance of a specified unit class on a given square in the game board.", "returns": "A T instance representing the found unit, or null if no such unit is found.", "reason": "This method provides a utility function to locate specific units within a game board, facilitating navigation and interaction logic in the Pacman game.", "howToUse": "Call this method with the desired unit class and square to find an instance of that unit on the specified square. Ensure that the square is not null before calling the method.", "howItWorks": "The method iterates over all units occupying the given square, checking if each unit's class matches the specified type. If a match is found, it returns the unit as an instance of the specified type. The method also ensures that the unit has a square assigned to it before returning it.", "assertions": {"preConditions": ["The square parameter must not be null."], "postConditions": ["If a matching unit is found, it will be returned as an instance of the specified type. If no matching unit is found, null will be returned."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "labels": ["Variable"], "properties": {"simpleName": "scoreFormatter", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).4", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code", "description": "The y-coordinate of the current position in the map file."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.square", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The square associated with this node.\r\n */\r\nprivate final nl.tudelft.jpacman.board.Square square;", "visibility": "private", "simpleName": "square", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.square", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory", "labels": ["Structure"], "properties": {"docComment": "Factory that provides Game objects.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "GameFactory", "qualifiedName": "nl.tudelft.jpacman.game.GameFactory", "kind": "class", "metaSrc": "source code", "description": "The GameFactory class is responsible for creating and managing game instances, including initializing players, levels, and point calculators to orchestrate a single-player PacMan game.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["Game Factory", "Single Player Game", "PacMan", "Level", "Point Calculator"], "dependencyProfile": "transit"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0", "labels": ["Variable"], "properties": {"simpleName": "ghostSprite", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The sprites for every direction."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The y-coordinate where to start rendering the square."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.nextMove()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "nextMove()", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.nextMove()", "kind": "method", "sourceText": "/**\r\n * Calculates the next move for this unit and returns the direction to move\r\n * in.\r\n * <p>\r\n * Precondition: The NPC occupies a square (hasSquare() holds).\r\n *\r\n * @return The direction to move in, or <code>null</code> if no move could\r\nbe devised.\r\n */\r\npublic nl.tudelft.jpacman.board.Direction nextMove() {\r\n    return this.nextAiMove().orElseGet(this::randomMove);\r\n}", "docComment": "Calculates the next move for this unit and returns the direction to move\r\nin.\r\n<p>\r\nPrecondition: The NPC occupies a square (hasSquare() holds).\r\n\r\n@return The direction to move in, or <code>null</code> if no move could\r\nbe devised.\r\n", "metaSrc": "source code", "description": "Returns an optional direction for the ghost to move next based on its AI strategy or a random move if AI is impossible.", "returns": "Optional<Direction>", "reason": "The method provides a fallback mechanism for ghosts that cannot make an AI move, ensuring game continuity and player experience.", "howToUse": "Call the nextMove() method on a Ghost instance to get its next movement direction.", "howItWorks": "The method first attempts to calculate an AI move using nextAiMove(). If this fails (returns an empty Optional), it defaults to choosing a random move using randomMove().", "preConditions": ["A valid Ghost instance is provided"], "postConditions": ["Returns an Optional containing the next movement direction or an empty Optional if no move can be determined"], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).3", "labels": ["Variable"], "properties": {"simpleName": "handler", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The handler that processes collisions between units of types C1 and C2."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "getDirection()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The direction for this node, or <code>null</code> if this\r\nnode is a root node.\r\n */\r\nprivate nl.tudelft.jpacman.board.Direction getDirection() {\r\n    return this.direction;\r\n}", "docComment": "\r\n@return The direction for this node, or <code>null</code> if this\r\nnode is a root node.\r\n", "metaSrc": "source code", "description": "Returns the current direction of a ghost in the Pacman game.", "returns": "The current direction of the ghost as an enum value from nl.tudelft.jpacman.board.Direction.", "reason": "This method provides access to the current movement direction of a ghost, which is essential for determining its path and interactions with other entities in the game.", "howToUse": "To use this method, simply call it on an instance of Navigation$Node representing a ghost. It will return the direction the ghost is currently facing.", "howItWorks": "The method directly returns the value stored in the 'direction' field of the current object, which holds the last known movement direction of the ghost.", "preConditions": [], "postConditions": ["The returned value is a valid enum value from nl.tudelft.jpacman.board.Direction representing the current direction of the ghost."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).2", "labels": ["Variable"], "properties": {"simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "currentSprite()", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The frame of the current index.\r\n */\r\nprivate nl.tudelft.jpacman.sprite.Sprite currentSprite() {\r\n    nl.tudelft.jpacman.sprite.Sprite result = nl.tudelft.jpacman.sprite.AnimatedSprite.END_OF_LOOP;\r\n    if (this.current < this.animationFrames.length) {\r\n        result = this.animationFrames[this.current];\r\n    }\r\n    assert result != null;\r\n    return result;\r\n}", "docComment": "\r\n@return The frame of the current index.\r\n", "metaSrc": "source code", "description": "Returns the current sprite in an animated sequence or the end of loop marker if all frames are shown.", "returns": "The current sprite or AnimatedSprite.END_OF_LOOP", "reason": "Manages the animation state and provides the current visual representation of the character.", "howToUse": "Call `currentSprite()` to get the current frame of an animated character.", "howItWorks": "Checks if there are more frames in the sequence. If so, returns the next frame; otherwise, returns the end of loop marker.", "assertions": {"preConditions": ["this.animationFrames is not null"], "postConditions": ["result is a valid sprite or AnimatedSprite.END_OF_LOOP"]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).3", "labels": ["Variable"], "properties": {"simpleName": "isAnimating", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "Initial state of the animation (true for playing, false for paused)."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "directionSprite(java.lang.String,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "kind": "method", "sourceText": "/**\r\n * Returns a new map with animations for all directions.\r\n *\r\n * @param resource\r\n * \t\tThe resource name of the sprite.\r\n * @param frames\r\n * \t\tThe number of frames in this sprite.\r\n * @return The animated sprite facing the given direction.\r\n */\r\nprivate java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> directionSprite(java.lang.String resource, int frames) {\r\n    java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> sprite = new java.util.HashMap<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite>();\r\n    nl.tudelft.jpacman.sprite.Sprite baseImage = this.loadSprite(resource);\r\n    for (int i = 0; i < nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS.length; i++) {\r\n        nl.tudelft.jpacman.sprite.Sprite directionSprite = baseImage.split(0, i * nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE, frames * nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE, nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE);\r\n        nl.tudelft.jpacman.sprite.AnimatedSprite animation = this.createAnimatedSprite(directionSprite, frames, nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY, true);\r\n        animation.setAnimating(true);\r\n        sprite.put(nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS[i], animation);\r\n    }\r\n    return sprite;\r\n}", "docComment": "Returns a new map with animations for all directions.\r\n\r\n@param resource\r\n\t\tThe resource name of the sprite.\r\n@param frames\r\n\t\tThe number of frames in this sprite.\r\n@return The animated sprite facing the given direction.\r\n", "metaSrc": "source code", "description": "Creates animated sprites for each direction based on a base image and splits it into frames.", "returns": "A map from directions to animated sprites.", "reason": "This method is part of the domain layer as it handles the creation and management of animated sprite objects based on a base image.", "howToUse": "Call this method with the path to the sprite resource and the number of frames for each animation. It will return a map of directions to their corresponding animated sprites.", "howItWorks": "The method creates an empty map to store the animated sprites. It loads the base image from the specified resource, splits it into multiple frames based on the given number of frames, creates an animated sprite for each frame, and adds them to the map with their respective directions.", "assertions": {"preConditions": ["The input resource path is valid and points to a file containing a sprite image.", "The input frames value is greater than zero."], "postConditions": ["A non-empty map of animated sprites is returned, where each key is a direction and the corresponding value is an animated sprite object."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getPlayerFactory()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return A new factory using the sprites from {@link #getSpriteStore()}.\r\n */\r\nprotected nl.tudelft.jpacman.level.PlayerFactory getPlayerFactory() {\r\n    return new nl.tudelft.jpacman.level.PlayerFactory(this.getSpriteStore());\r\n}", "docComment": "\r\n@return A new factory using the sprites from {@link #getSpriteStore()}.\r\n", "metaSrc": "source code", "description": "Returns a PlayerFactory instance using the current SpriteStore.", "returns": "nl.tudelft.jpacman.level.PlayerFactory", "reason": "The method provides a factory for creating players, which is part of the domain layer where game logic and entities are defined.", "howToUse": "Call this method to obtain a PlayerFactory instance that can be used to create player objects in the game.", "howItWorks": "The method creates a new PlayerFactory by passing the current SpriteStore to its constructor. The SpriteStore is responsible for managing PacMan and ghost sprites, which are essential components of the game's visual representation.", "assertions": {"preConditions": [], "postConditions": []}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.MOVE_INTERVAL", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The base movement interval.\r\n */\r\nprivate static final int MOVE_INTERVAL = 200;", "visibility": "private", "simpleName": "MOVE_INTERVAL", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Pinky.MOVE_INTERVAL", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).0", "labels": ["Variable"], "properties": {"simpleName": "caption", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).5", "labels": ["Variable"], "properties": {"simpleName": "c", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).5", "kind": "parameter", "parameterPosition": 5, "metaSrc": "source code", "description": "The character representing the type of square at the current position in the map file."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor).0", "labels": ["Variable"], "properties": {"simpleName": "color", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The color of the ghost."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.start()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "start()", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI.start()", "kind": "method", "sourceText": "/**\r\n * Starts the \"engine\", the thread that redraws the interface at set\r\n * intervals.\r\n */\r\npublic void start() {\r\n    this.setVisible(true);\r\n    java.util.concurrent.ScheduledExecutorService service = java.util.concurrent.Executors.newSingleThreadScheduledExecutor();\r\n    service.scheduleAtFixedRate(this::nextFrame, 0, nl.tudelft.jpacman.ui.PacManUI.FRAME_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS);\r\n}", "docComment": "Starts the \"engine\", the thread that redraws the interface at set\r\nintervals.\r\n", "metaSrc": "source code", "description": "Starts the PacMan game by setting visibility to true and scheduling frame updates at regular intervals.", "returns": "", "reason": "The method initializes the UI, sets it visible, and schedules periodic updates to render the game state.", "howToUse": "Call `start()` on an instance of `PacManUI` to begin the game.", "howItWorks": "The method creates a single-threaded scheduled executor service to run the nextFrame() method at regular intervals defined by FRAME_INTERVAL in milliseconds.", "assertions": {"preConditions": ["An instance of PacManUI is created and initialized."], "postConditions": ["The UI is set visible, and frame updates are scheduled."]}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall", "labels": ["Structure"], "properties": {"docComment": "A wall is a square that is inaccessible to anyone.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Wall", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Wall", "kind": "class", "metaSrc": "source code", "description": "The Wall class is responsible for representing walls in the Pacman game, providing methods to get its sprite and check accessibility.", "layer": "Domain Layer", "roleStereotype": "Structurer", "keywords": ["Wall", "Pacman", "Game", "Square", "Sprite"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "nextAiMove()", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "kind": "method", "sourceText": "/**\r\n * Tries to calculate a move based on the behaviour of the npc.\r\n *\r\n * @return an optional containing the move or empty if the current state of the game\r\nmakes the ai move impossible\r\n */\r\npublic abstract java.util.Optional<nl.tudelft.jpacman.board.Direction> nextAiMove();", "docComment": "Tries to calculate a move based on the behaviour of the npc.\r\n\r\n@return an optional containing the move or empty if the current state of the game\r\nmakes the ai move impossible\r\n", "metaSrc": "source code", "description": "Returns an optional direction for the ghost to move next based on its AI strategy.", "returns": "Optional<Direction>", "reason": "The method provides a way for ghosts in the Pacman game to make decisions about their movement, which is essential for the game's AI behavior.", "howToUse": "Call this method from within a ghost class to determine its next move. The returned Optional will contain a Direction if there is a valid move available, or be empty if no move can be made.", "howItWorks": "The method uses an AI strategy implemented by the subclass to decide on the next direction for the ghost. This could involve checking for nearby Pacman, avoiding walls, and considering other ghosts' positions.", "preConditions": ["A valid instance of a Ghost class is provided.", "The game board is initialized and populated with all necessary entities."], "postConditions": ["An Optional<Direction> is returned indicating the next move or absence thereof.", "The ghost's position on the board may change based on its chosen direction."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).0", "labels": ["Variable"], "properties": {"simpleName": "map", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A map containing classes as keys and objects as values."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(int,nl.tudelft.jpacman.sprite.Sprite)", "qualifiedName": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new pellet.\r\n *\r\n * @param points\r\n * \t\tThe point value of this pellet.\r\n * @param sprite\r\n * \t\tThe sprite of this pellet.\r\n */\r\npublic Pellet(int points, nl.tudelft.jpacman.sprite.Sprite sprite) {\r\n    super();\r\n    this.image = sprite;\r\n    this.value = points;\r\n}", "docComment": "Creates a new pellet.\r\n\r\n@param points\r\n\t\tThe point value of this pellet.\r\n@param sprite\r\n\t\tThe sprite of this pellet.\r\n", "metaSrc": "source code", "description": "Initializes a Pellet with a specified sprite and points value.", "returns": "A newly created Pellet instance.", "reason": "This method is part of the Domain Layer as it initializes a domain entity (Pellet) with specific attributes and behaviors.", "howToUse": "Create a Pellet by providing its points value and an appropriate sprite.", "howItWorks": "The constructor sets up the Pellet's image and value based on the provided parameters.", "assertions": {"preConditions": ["points must be a non-negative integer", "sprite must not be null"], "postConditions": ["Pellet instance is created with the specified points and sprite", "Pellet's image attribute is set to the provided sprite"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "kind": "method", "sourceText": "/**\r\n * Provide formatter for the score.\r\n *\r\n * @param scoreFormatter\r\n * \t\tThe score formatter to be used.\r\n * @return The builder.\r\n */\r\npublic nl.tudelft.jpacman.ui.PacManUiBuilder withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel.ScoreFormatter scoreFormatter) {\r\n    this.scoreFormatter = scoreFormatter;\r\n    return this;\r\n}", "docComment": "Provide formatter for the score.\r\n\r\n@param scoreFormatter\r\n\t\tThe score formatter to be used.\r\n@return The builder.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.INTERVAL_VARIATION", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The variation in intervals, this makes the ghosts look more dynamic and\r\n * less predictable.\r\n */\r\nprivate static final int INTERVAL_VARIATION = 50;", "visibility": "private", "simpleName": "INTERVAL_VARIATION", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Blinky.INTERVAL_VARIATION", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener", "labels": ["Structure"], "properties": {"docComment": "A key listener based on a set of keyCode-action pairs.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "PacKeyListener", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for handling user input in the Pacman game by mapping key presses to specific actions and triggering those actions accordingly.", "layer": "Presentation Layer", "roleStereotype": "Controller", "keywords": ["KeyListener", "Pacman", "Game Input", "Action Mapping"], "dependencyProfile": "hidden"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "kind": "method", "sourceText": "/**\r\n * Adds the collision interaction..\r\n *\r\n * @param collider\r\n * \t\tThe collider type.\r\n * @param collidee\r\n * \t\tThe collidee type.\r\n * @param handler\r\n * \t\tThe handler that handles the collision.\r\n */\r\nprivate void addHandler(java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> collider, java.lang.Class<? extends nl.tudelft.jpacman.board.Unit> collidee, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<? extends java.lang.Object, ? extends java.lang.Object> handler) {\r\n    if (!this.handlers.containsKey(collider)) {\r\n        this.handlers.put(collider, new java.util.HashMap<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<? extends java.lang.Object, ? extends java.lang.Object>>());\r\n    }\r\n    java.util.Map<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<? extends java.lang.Object, ? extends java.lang.Object>> map = this.handlers.get(collider);\r\n    map.put(collidee, handler);\r\n}", "docComment": "Adds the collision interaction..\r\n\r\n@param collider\r\n\t\tThe collider type.\r\n@param collidee\r\n\t\tThe collidee type.\r\n@param handler\r\n\t\tThe handler that handles the collision.\r\n", "metaSrc": "source code", "description": "Adds a collision handler for a specific pair of units in the game.", "returns": "void", "reason": "This method is part of the domain layer as it manages game logic and handles collisions between different entities in the game.", "howToUse": "To use this method, you need to provide the classes representing the colliding units and a collision handler. The collision handler will be used when these two units collide.", "howItWorks": "The method first checks if there is already a map for the collider class in the handlers map. If not, it creates one. Then, it adds the collision handler to the map for the specified collidee class.", "assertions": {"preConditions": ["collider and collidee are valid classes that extend nl.tudelft.jpacman.board.Unit", "handler is a valid CollisionHandler instance"], "postConditions": ["The collision handler is added to the handlers map for the specified collider class."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.getSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getSprite()", "qualifiedName": "nl.tudelft.jpacman.level.Pellet.getSprite()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite getSprite() {\r\n    return this.image;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.stop()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "stop()", "qualifiedName": "nl.tudelft.jpacman.level.Level.stop()", "kind": "method", "sourceText": "/**\r\n * Stops or pauses this level, no longer allowing any movement on the board\r\n * and stopping all NPCs.\r\n */\r\npublic void stop() {\r\n    synchronized(this.startStopLock) {\r\n        if (!this.isInProgress()) {\r\n            return;\r\n        }\r\n        this.stopNPCs();\r\n        this.inProgress = false;\r\n    }\r\n}", "docComment": "Stops or pauses this level, no longer allowing any movement on the board\r\nand stopping all NPCs.\r\n", "metaSrc": "source code", "description": "Stops all NPCs in progress and sets the level's progress to false.", "returns": "", "reason": "The method manages the game state by stopping NPC movements and updating the level's status.", "howToUse": "Call `stop()` on an instance of `Level` to stop all NPCs and mark the level as not in progress.", "howItWorks": "Synchronizes access to the startStopLock, checks if the level is in progress, stops NPC movements, sets inProgress to false, and releases the lock.", "assertions": {"preConditions": ["The method is called on a valid Level instance.", "The level is currently in progress."], "postConditions": ["All NPCs are stopped.", "The level's progress is set to false."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculatorLoader()", "kind": "constructor", "sourceText": "PointCalculatorLoader() {\r\n    super();\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "labels": ["Variable"], "properties": {"simpleName": "scoreFormatter", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The formatter to use for displaying scores."}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite).0", "labels": ["Variable"], "properties": {"simpleName": "sprite", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The background sprite for the ground."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getWallSprite()", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The sprite for the wall.\r\n */\r\npublic nl.tudelft.jpacman.sprite.Sprite getWallSprite() {\r\n    return this.loadSprite(\"/sprite/wall.png\");\r\n}", "docComment": "\r\n@return The sprite for the wall.\r\n", "metaSrc": "source code", "description": "Loads a wall sprite from a resource file and returns it as an ImageSprite.", "returns": "A new ImageSprite object representing the loaded wall sprite.", "reason": "The method provides a convenient way to load a specific sprite for use in the game, ensuring that the sprite is cached if it doesn't already exist.", "howToUse": "Call `getWallSprite()` to retrieve the wall sprite. This method assumes all sprites are provided and will throw a RuntimeException if an exception occurs during loading.", "howItWorks": "The method uses the `loadSprite` method from the superclass, which loads a sprite from a resource file and caches it if necessary. The returned object is then cast to an ImageSprite.", "preConditions": ["The method assumes that all sprites are provided.", "The method will throw a RuntimeException if an exception occurs during loading."], "postConditions": ["A new ImageSprite object representing the loaded wall sprite is returned."], "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.getValue()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getValue()", "qualifiedName": "nl.tudelft.jpacman.level.Pellet.getValue()", "kind": "method", "sourceText": "/**\r\n * Returns the point value of this pellet.\r\n *\r\n * @return The point value of this pellet.\r\n */\r\npublic int getValue() {\r\n    return this.value;\r\n}", "docComment": "Returns the point value of this pellet.\r\n\r\n@return The point value of this pellet.\r\n", "metaSrc": "source code", "description": "Returns the value associated with the Pellet.", "returns": "The integer value of the Pellet.", "reason": "This method provides a straightforward access to the internal state of the Pellet object, which is essential for game logic and scoring in Pacman.", "howToUse": "Call `getValue()` on an instance of `Pellet` to retrieve its value.", "howItWorks": "The method simply returns the value stored in the `value` field of the Pellet class.", "preConditions": [], "postConditions": [], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "kind": "static method", "sourceText": "/**\r\n * Calculates the shortest path. This is done by BFS. This search ensures\r\n * the traveller is allowed to occupy the squares on the way, or returns the\r\n * shortest path to the square regardless of terrain if no traveller is\r\n * specified.\r\n *\r\n * @param from\r\n * \t\tThe starting square.\r\n * @param to\r\n * \t\tThe destination.\r\n * @param traveller\r\n * \t\tThe traveller attempting to reach the destination. If\r\n * \t\ttraveller is set to <code>null</code>, this method will ignore\r\n * \t\tterrain and find the shortest path whether it can actually be\r\n * \t\treached or not.\r\n * @return The shortest path to the destination or <code>null</code> if no\r\nsuch path could be found. When the destination is the current\r\nsquare, an empty list is returned.\r\n */\r\npublic static java.util.List<nl.tudelft.jpacman.board.Direction> shortestPath(nl.tudelft.jpacman.board.Square from, nl.tudelft.jpacman.board.Square to, nl.tudelft.jpacman.board.Unit traveller) {\r\n    if (from.equals(to)) {\r\n        return new java.util.ArrayList<nl.tudelft.jpacman.board.Direction>();\r\n    }\r\n    java.util.List<nl.tudelft.jpacman.npc.ghost.Navigation.Node> targets = new java.util.ArrayList<nl.tudelft.jpacman.npc.ghost.Navigation.Node>();\r\n    java.util.Set<nl.tudelft.jpacman.board.Square> visited = new java.util.HashSet<nl.tudelft.jpacman.board.Square>();\r\n    targets.add(new nl.tudelft.jpacman.npc.ghost.Navigation.Node(null, from, null));\r\n    while (!targets.isEmpty()) {\r\n        nl.tudelft.jpacman.npc.ghost.Navigation.Node node = targets.remove(0);\r\n        nl.tudelft.jpacman.board.Square square = node.getSquare();\r\n        if (square.equals(to)) {\r\n            return node.getPath();\r\n        }\r\n        visited.add(square);\r\n        nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(traveller, targets, visited, node, square);\r\n    } \r\n    return null;\r\n}", "docComment": "Calculates the shortest path. This is done by BFS. This search ensures\r\nthe traveller is allowed to occupy the squares on the way, or returns the\r\nshortest path to the square regardless of terrain if no traveller is\r\nspecified.\r\n\r\n@param from\r\n\t\tThe starting square.\r\n@param to\r\n\t\tThe destination.\r\n@param traveller\r\n\t\tThe traveller attempting to reach the destination. If\r\n\t\ttraveller is set to <code>null</code>, this method will ignore\r\n\t\tterrain and find the shortest path whether it can actually be\r\n\t\treached or not.\r\n@return The shortest path to the destination or <code>null</code> if no\r\nsuch path could be found. When the destination is the current\r\nsquare, an empty list is returned.\r\n", "metaSrc": "source code", "description": "Finds the shortest path from one square to another on the game board for a given unit.", "returns": "A list of directions representing the shortest path from 'from' to 'to'.", "reason": "This method implements a breadth-first search algorithm to find the shortest path on the game board.", "howToUse": "Call this method with the starting and target squares, along with the unit performing the navigation. It will return the list of directions needed to reach the target square.", "howItWorks": "The method uses a queue to explore all possible paths from the start square. It keeps track of visited squares to avoid cycles and adds new targets for each square that has not been visited yet. The path is reconstructed by backtracking from the target square to the starting square.", "assertions": {"preConditions": ["The 'from' and 'to' squares must be valid on the game board."], "postConditions": ["The returned list of directions should lead from 'from' to 'to'.", "If no path exists, the method returns null."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).1", "labels": ["Variable"], "properties": {"simpleName": "square", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The x-coordinate of the top-left corner of the sub-image."}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException", "labels": ["Structure"], "properties": {"docComment": "Exception that is thrown when JPacman cannot be properly loaded\r\nfrom its resources.\r\n\r\n@author Arie van Deursen, 2014\r\n", "simpleName": "PacmanConfigurationException", "qualifiedName": "nl.tudelft.jpacman.PacmanConfigurationException", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for handling configuration-related exceptions in the Pacman game implementation. It provides two constructors to create a configuration exception with either a direct message or a message along with a root cause.", "layer": "Domain Layer", "roleStereotype": "Service Provider", "keywords": ["configuration", "exception", "Pacman", "Java"]}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.getWidth()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getWidth()", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.getWidth()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic int getWidth() {\r\n    return this.image.getWidth(null);\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_DEATH_FRAMES", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The amount of frames in the pacman dying animation.\r\n */\r\nprivate static final int PACMAN_DEATH_FRAMES = 11;", "visibility": "private", "simpleName": "PACMAN_DEATH_FRAMES", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_DEATH_FRAMES", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0", "labels": ["Variable"], "properties": {"simpleName": "buttons", "qualifiedName": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A map of button captions to corresponding action objects."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.sprites", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The sprite store containing the Pac-Man sprites.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.PacManSprites sprites;", "visibility": "private", "simpleName": "sprites", "qualifiedName": "nl.tudelft.jpacman.level.PlayerFactory.sprites", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player who has moved."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player that will die."}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "labels": ["Variable"], "properties": {"simpleName": "direction", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createClyde()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "kind": "method", "sourceText": "/**\r\n * Creates a new Clyde / Pokey, the orange Ghost.\r\n *\r\n * @see Clyde\r\n * @return A new Clyde.\r\n */\r\npublic nl.tudelft.jpacman.npc.Ghost createClyde() {\r\n    return new nl.tudelft.jpacman.npc.ghost.Clyde(this.sprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor.ORANGE));\r\n}", "docComment": "Creates a new Clyde / Pokey, the orange Ghost.\r\n\r\n@see Clyde\r\n@return A new Clyde.\r\n", "metaSrc": "source code", "description": "Creates an instance of Clyde, a specific ghost character in the Pacman game.", "returns": "An instance of Clyde, a specific ghost character in the Pacman game.", "reason": "The method creates an instance of Clyde by providing its sprite based on the specified color.", "howToUse": "Call this method to create a new Clyde object. It requires the sprites for all directions of Clyde.", "howItWorks": "The method retrieves the animated ghost sprite for Clyde's orange color and uses it to create a new Clyde instance.", "preConditions": ["The method expects an instance of GhostColor.ORANGE."], "postConditions": ["A new Clyde object is created with the specified sprite."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame", "labels": ["Structure"], "properties": {"docComment": "A game with one player and a single level.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "SinglePlayerGame", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame", "kind": "class", "metaSrc": "source code", "description": "The SinglePlayerGame class is responsible for managing a single-player game instance, including initializing the player, level, and point calculator, and providing methods to access the current level and players.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["single-player", "game management", "player", "level", "point calculator"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0", "labels": ["Variable"], "properties": {"simpleName": "spriteMap", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A map of directions to their corresponding sprite objects."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.defaultButtons", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * <code>true</code> iff this UI has the default buttons.\r\n */\r\nprivate boolean defaultButtons;", "visibility": "private", "simpleName": "defaultButtons", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.defaultButtons", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "parseMap(java.io.InputStream)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "kind": "method", "sourceText": "/**\r\n * Parses the provided input stream as a character stream and passes it\r\n * result to {@link #parseMap(List)}.\r\n *\r\n * @param source\r\n * \t\tThe input stream that will be read.\r\n * @return The parsed level as represented by the text on the input stream.\r\n * @throws IOException\r\n * \t\twhen the source could not be read.\r\n */\r\npublic nl.tudelft.jpacman.level.Level parseMap(java.io.InputStream source) throws java.io.IOException {\r\n    try (java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(source, \"UTF-8\"))) {\r\n        java.util.List<java.lang.String> lines = new java.util.ArrayList<java.lang.String>();\r\n        while (reader.ready()) {\r\n            lines.add(reader.readLine());\r\n        } \r\n        return this.parseMap(lines);\r\n    }\r\n}", "docComment": "Parses the provided input stream as a character stream and passes it\r\nresult to {@link #parseMap(List)}.\r\n\r\n@param source\r\n\t\tThe input stream that will be read.\r\n@return The parsed level as represented by the text on the input stream.\r\n@throws IOException\r\n\t\twhen the source could not be read.\r\n", "metaSrc": "source code", "description": "Parses a text representation of a map into an actual game board for Pacman.", "returns": "An instance of nl.tudelft.jpacman.level.Level", "reason": "The method reads a text file containing the layout of the game board and converts it into a format that can be used by the game logic.", "howToUse": "Call this method with an InputStream representing the map file. The method will parse the file and return a Level object representing the game board.", "howItWorks": "The method reads the input stream, splits it into lines, and stores them in a list. It then calls another method to parse the list of strings into a level object.", "assertions": {"preConditions": ["An InputStream is provided"], "postConditions": ["A Level object representing the game board is returned"]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "setKiller(nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Sets the cause of death.\r\n *\r\n * @param killer\r\n * \t\tis set if collision with ghost happens.\r\n */\r\npublic void setKiller(nl.tudelft.jpacman.board.Unit killer) {\r\n    this.killer = killer;\r\n}", "docComment": "Sets the cause of death.\r\n\r\n@param killer\r\n\t\tis set if collision with ghost happens.\r\n", "metaSrc": "source code", "description": "Sets the killer unit for the player in the game.", "returns": "", "reason": "This method is part of the Domain Layer, where business logic and domain data are handled. It sets a reference to another Unit object which represents the player's killer in the game.", "howToUse": "Call this method with an instance of nl.tudelft.jpacman.board.Unit as the argument to set the killer for the player.", "howItWorks": "The method assigns the provided Unit object to the private field 'killer' of the Player class. This allows the game logic to determine if the player has been killed by another unit.", "assertions": {"preConditions": ["A valid nl.tudelft.jpacman.board.Unit object is passed as an argument."], "postConditions": ["The 'killer' field of the Player class is updated with the provided Unit object."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap()", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap()", "kind": "constructor", "sourceText": "/**\r\n * Creates a new, empty collision map.\r\n */\r\npublic CollisionInteractionMap() {\r\n    super();\r\n    this.handlers = new java.util.HashMap<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, java.util.Map<java.lang.Class<? extends nl.tudelft.jpacman.board.Unit>, nl.tudelft.jpacman.level.CollisionInteractionMap.CollisionHandler<? extends java.lang.Object, ? extends java.lang.Object>>>();\r\n}", "docComment": "Creates a new, empty collision map.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createInky()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "kind": "method", "sourceText": "/**\r\n * Creates a new Inky / Bashful, the cyan Ghost.\r\n *\r\n * @see Inky\r\n * @return A new Inky.\r\n */\r\npublic nl.tudelft.jpacman.npc.Ghost createInky() {\r\n    return new nl.tudelft.jpacman.npc.ghost.Inky(this.sprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor.CYAN));\r\n}", "docComment": "Creates a new Inky / Bashful, the cyan Ghost.\r\n\r\n@see Inky\r\n@return A new Inky.\r\n", "metaSrc": "source code", "description": "Creates an Inky ghost using its sprite based on the specified color.", "returns": "An instance of nl.tudelft.jpacman.npc.Ghost representing the Inky ghost.", "reason": "The method is part of the Domain Layer as it creates a domain entity (Ghost) based on configuration data.", "howToUse": "Call this method with the desired GhostColor to get an Inky ghost instance.", "howItWorks": "The method retrieves animated sprites for the specified color and uses them to create an Inky ghost object.", "preConditions": ["The GhostColor must be valid."], "postConditions": ["An Inky ghost object is returned with the appropriate sprite configuration."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getBoardFactory()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return A new board factory using the sprite store from\r\n{@link #getSpriteStore()}.\r\n */\r\nprotected nl.tudelft.jpacman.board.BoardFactory getBoardFactory() {\r\n    return new nl.tudelft.jpacman.board.BoardFactory(this.getSpriteStore());\r\n}", "docComment": "\r\n@return A new board factory using the sprite store from\r\n{@link #getSpriteStore()}.\r\n", "metaSrc": "source code", "description": "Returns a new instance of BoardFactory using the current SpriteStore.", "returns": "nl.tudelft.jpacman.board.BoardFactory", "reason": "The method provides a way to create a board factory based on the current sprite store, which is essential for initializing game boards in Pacman.", "howToUse": "Call this method from within the Launcher class to obtain a BoardFactory instance.", "howItWorks": "The method creates a new BoardFactory object by passing the current SpriteStore to its constructor. This setup ensures that all necessary resources and configurations are available for creating game boards.", "assertions": {"preConditions": ["A valid SpriteStore instance is available in the Launcher class."], "postConditions": ["A new BoardFactory instance is returned, ready to be used for creating game boards."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).1", "labels": ["Variable"], "properties": {"simpleName": "sprite", "qualifiedName": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The visual representation of the pellet."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "mover", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that is moving or colliding."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction", "labels": ["Structure"], "properties": {"docComment": "An enumeration of possible directions on a two-dimensional square grid.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Direction", "qualifiedName": "nl.tudelft.jpacman.board.Direction", "kind": "enum", "metaSrc": "source code", "description": "The enum `Direction` in the Pacman implementation is responsible for managing movement directions and their associated deltas, providing methods to retrieve these details and determine opposite directions.", "layer": "Domain Layer", "roleStereotype": "Service Provider", "keywords": ["direction", "movement", "enum", "delta", "opposite"], "dependencyProfile": "inbound"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code", "description": "The height of the target sprite."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "loadSprite(java.lang.String)", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "kind": "method", "sourceText": "/**\r\n * Loads a sprite from a resource on the class path.\r\n * Sprites are loaded once, and then stored in the store\r\n * so that they can be efficiently retrieved.\r\n *\r\n * @param resource\r\n * \t\tThe resource path.\r\n * @return The sprite for the resource.\r\n * @throws IOException\r\n * \t\tWhen the resource could not be loaded.\r\n */\r\npublic nl.tudelft.jpacman.sprite.Sprite loadSprite(java.lang.String resource) throws java.io.IOException {\r\n    nl.tudelft.jpacman.sprite.Sprite result = this.spriteMap.get(resource);\r\n    if (result == null) {\r\n        result = this.loadSpriteFromResource(resource);\r\n        this.spriteMap.put(resource, result);\r\n    }\r\n    return result;\r\n}", "docComment": "Loads a sprite from a resource on the class path.\r\nSprites are loaded once, and then stored in the store\r\nso that they can be efficiently retrieved.\r\n\r\n@param resource\r\n\t\tThe resource path.\r\n@return The sprite for the resource.\r\n@throws IOException\r\n\t\tWhen the resource could not be loaded.\r\n", "metaSrc": "source code", "description": "Loads a sprite from a resource file if it doesn't exist in the cache, otherwise retrieves it from the cache.", "returns": "A new ImageSprite object representing the loaded sprite.", "reason": "This method provides a caching mechanism for sprites, reducing the number of times resources are loaded from disk and improving performance.", "howToUse": "Call this method with the path to a resource file to load or retrieve a sprite. The method will return an ImageSprite object representing the loaded sprite.", "howItWorks": "The method first checks if the sprite is already in the cache using the `spriteMap`. If it is, the cached sprite is returned. If not, the method calls `loadSpriteFromResource` to load the sprite from a file and then adds it to the cache before returning it.", "assertions": {"preConditions": ["The resource path must be valid."], "postConditions": ["The method returns an ImageSprite object representing the loaded sprite."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Caption for the default start button.\r\n */\r\nprivate static final java.lang.String START_CAPTION = \"Start\";", "visibility": "private", "simpleName": "START_CAPTION", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.pointCalculator", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The algorithm used to calculate the points that\r\n * they player gets whenever some action happens.\r\n */\r\nprivate nl.tudelft.jpacman.points.PointCalculator pointCalculator;", "visibility": "private", "simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.game.Game.pointCalculator", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).1", "labels": ["Variable"], "properties": {"simpleName": "targets", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "A list to store the new targets."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGame()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getGame()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getGame()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The game object this launcher will start when {@link #launch()}\r\nis called.\r\n */\r\npublic nl.tudelft.jpacman.game.Game getGame() {\r\n    return this.game;\r\n}", "docComment": "\r\n@return The game object this launcher will start when {@link #launch()}\r\nis called.\r\n", "metaSrc": "source code", "description": "Returns the current game instance.", "returns": "The Game object representing the current state of the Pacman game.", "reason": "This method provides access to the current game state, allowing for interaction with the game's components and logic.", "howToUse": "To use this method, simply call it on an instance of Launcher. It will return the current game instance which can be used to interact with the game's entities and perform actions like starting a new game or pausing the current one.", "howItWorks": "The method directly returns the `game` field of the Launcher class, which is assumed to hold the current Game object. This is a straightforward implementation that does not involve any complex logic or external dependencies.", "assertions": {"preConditions": [], "postConditions": []}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.MOVE_INTERVAL", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The base movement interval.\r\n */\r\nprivate static final int MOVE_INTERVAL = 250;", "visibility": "private", "simpleName": "MOVE_INTERVAL", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Blinky.MOVE_INTERVAL", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.WEST", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * West, or left.\r\n */\r\nWEST(-1, 0)", "visibility": "public", "simpleName": "WEST", "qualifiedName": "nl.tudelft.jpacman.board.Direction.WEST", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(nl.tudelft.jpacman.sprite.Sprite)", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new ground square.\r\n *\r\n * @param sprite\r\n * \t\tThe background for the square.\r\n */\r\nGround(nl.tudelft.jpacman.sprite.Sprite sprite) {\r\n    super();\r\n    this.background = sprite;\r\n}", "docComment": "Creates a new ground square.\r\n\r\n@param sprite\r\n\t\tThe background for the square.\r\n", "metaSrc": "source code", "description": "Initializes a new Ground object by setting its background sprite.", "returns": "A newly created Ground instance with the specified background sprite.", "reason": "This method is part of the Domain Layer as it initializes a domain object (Ground) based on user input or configuration, which is essential for game logic and rendering.", "howToUse": "Create a new Ground object by passing a Sprite to its constructor. This will be used in the board factory to create ground tiles with specific visual representations.", "howItWorks": "The method initializes a new Square object (which is a superclass of Ground) and sets its background sprite. This setup allows for easy integration into the game's board structure, where each square can have a unique visual representation.", "assertions": {"preConditions": ["A valid Sprite object must be provided."], "postConditions": ["The new Ground object is created with the specified background sprite and initialized as a Square."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidee", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that is being collided with."}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(java.util.Map)", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new random ghost.\r\n *\r\n * @param ghostSprite\r\n * \t\tThe sprite for the ghost.\r\n */\r\nRandomGhost(java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> ghostSprite) {\r\n    super(ghostSprite, ((int) (nl.tudelft.jpacman.level.LevelFactory.RandomGhost.DELAY)), 0);\r\n}", "docComment": "Creates a new random ghost.\r\n\r\n@param ghostSprite\r\n\t\tThe sprite for the ghost.\r\n", "metaSrc": "source code", "description": "Initializes a new RandomGhost instance with specified sprite map, move interval, and interval variation.", "returns": "A newly created RandomGhost instance.", "reason": "This method initializes a new Ghost instance with the provided sprite map and default move interval and variation values.", "howToUse": "Create an instance of RandomGhost by passing a Map containing sprites for each direction to the constructor.", "howItWorks": "The constructor calls the superclass constructor with the provided ghostSprite, a default move interval (DELAY), and zero as the interval variation.", "preConditions": ["A valid Map<Direction, Sprite> is provided."], "postConditions": ["A new RandomGhost instance is created with the specified sprite map and default values for move interval and interval variation."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square()", "labels": ["Constructor"], "properties": {"visibility": "protected", "simpleName": "<init>()", "qualifiedName": "nl.tudelft.jpacman.board.Square()", "kind": "constructor", "sourceText": "/**\r\n * Creates a new, empty square.\r\n */\r\nprotected Square() {\r\n    super();\r\n    this.occupants = new java.util.ArrayList<nl.tudelft.jpacman.board.Unit>();\r\n    this.neighbours = new java.util.EnumMap<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.board.Square>(nl.tudelft.jpacman.board.Direction.class);\r\n    assert this.invariant();\r\n}", "docComment": "Creates a new, empty square.\r\n", "metaSrc": "source code", "description": "Initializes a new Square object, setting up its occupants and neighbours lists.", "returns": "A newly created Square instance.", "reason": "This method is responsible for initializing the basic state of a square in the Pacman game, preparing it to be part of the board.", "howToUse": "Call this constructor when creating a new Square object. It initializes an empty list of occupants and neighbours.", "howItWorks": "The constructor calls super() to initialize the parent class, then creates two lists: one for units occupying the square and another for its neighboring squares. Finally, it asserts that the object's invariant is maintained.", "assertions": {"preConditions": [], "postConditions": ["The Square instance has been initialized with an empty list of occupants and neighbours."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground", "labels": ["Structure"], "properties": {"docComment": "A ground square is a square that is accessible to anyone.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Ground", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Ground", "kind": "class", "metaSrc": "source code", "description": "The Ground class is responsible for managing the visual representation and accessibility of game squares in the Pacman game. It initializes a square with a background sprite, which determines its appearance on the board. The class also provides methods to check if a unit can access the ground.", "layer": "Domain Layer", "roleStereotype": "Structurer", "keywords": ["Ground", "Square", "Sprite", "Accessibility"], "dependencyProfile": "hidden"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).1", "labels": ["Variable"], "properties": {"simpleName": "action", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel", "labels": ["Container", "Structure"], "properties": {"docComment": "A panel consisting of a column for each player, with the numbered players on\r\ntop and their respective scores underneath.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "ScorePanel", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel", "kind": "class", "metaSrc": "source code", "description": "The ScorePanel class is responsible for displaying and updating scores in the Pacman game, handling player death status, and providing a customizable score display format.", "layer": "Presentation Layer", "roleStereotype": "User Interfacer", "keywords": ["score panel", "Pacman game", "score display", "player death", "score formatter"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.deltaX", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The delta x (width difference) to an element in the direction in a grid\r\n * with 0,0 (x,y) as its top-left element.\r\n */\r\nprivate final int deltaX;", "visibility": "private", "simpleName": "deltaX", "qualifiedName": "nl.tudelft.jpacman.board.Direction.deltaX", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "labels": ["Variable"], "properties": {"simpleName": "collider", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The type of the collider unit."}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "labels": ["Structure"], "properties": {"docComment": "An symmetrical copy of a collision hander.\r\n\r\n@author Michael de Jong\r\n@param <C1>\r\n\t\tThe collider type.\r\n@param <C2>\r\n\t\tThe collidee type.\r\n", "simpleName": "InverseCollisionHandler", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "kind": "class", "metaSrc": "source code", "description": "This class is responsible for handling collisions in reverse order, providing a way to handle collisions between two units in reverse order.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["collision", "handler", "reverse", "handleCollision"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "labels": ["Structure"], "properties": {"docComment": "Implementation of an NPC that wanders around randomly.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "RandomGhost", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "kind": "class", "metaSrc": "source code", "description": "This class is responsible for creating and managing random ghosts in the Pacman game. It initializes a new Ghost instance with specified sprite map, move interval, and interval variation.", "layer": "Domain Layer", "roleStereotype": "Service Provider", "keywords": ["RandomGhost", "Pacman", "Ghosts", "SpriteMap", "MoveInterval", "IntervalVariation"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "newDirection", "qualifiedName": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The new direction to set for the unit."}}}, {"data": {"id": "java.lang.String", "labels": ["Structure"], "properties": {"simpleName": "String", "qualifiedName": "java.lang.String", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int).1", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.board.Board.squareAt(int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The y-coordinate of the square to retrieve."}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "labels": ["Structure"], "properties": {"docComment": "An extensible default interaction map for collisions caused by the player.\r\n\r\nThe implementation makes use of the interactionmap, and as such can be easily\r\nand declaratively extended when new types of units (ghosts, players, ...) are\r\nadded.\r\n\r\n@author Arie van Deursen\r\n@author Jeroen Roosen\r\n", "simpleName": "DefaultPlayerInteractionMap", "qualifiedName": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for managing player interactions in the game, including handling collisions between players and ghosts, as well as updating player points based on pellet consumption.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["collision", "interaction", "player", "ghost", "pellet", "pointCalculator"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "keyPressed(java.awt.event.KeyEvent)", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void keyPressed(java.awt.event.KeyEvent event) {\r\n    assert event != null;\r\n    nl.tudelft.jpacman.ui.Action action = this.mappings.get(event.getKeyCode());\r\n    if (action != null) {\r\n        action.doAction();\r\n    }\r\n}", "docComment": "", "metaSrc": "source code", "description": "Processes key presses to trigger game actions in Pacman.", "returns": "", "reason": "This method is part of the user interface layer as it handles user input and triggers game actions based on the pressed keys.", "howToUse": "Call this method when a key is pressed in the Pacman game. It will execute the corresponding action defined for that key.", "howItWorks": "The method retrieves the action associated with the pressed key from a mapping, checks if it exists, and then calls the doAction() method on that action to perform the desired game operation.", "assertions": {"preConditions": ["event is not null"], "postConditions": []}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader", "labels": ["Structure"], "properties": {"docComment": "The responsibility of this loader is to obtain the appropriate points calculator.\r\nBy default the {@link DefaultPointCalculator} is returned.\r\n", "simpleName": "PointCalculatorLoader", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculatorLoader", "kind": "class", "metaSrc": "source code", "description": "The PointCalculatorLoader class is responsible for managing the loading and instantiation of point calculators in a Pacman game implementation. It handles configuration settings, dynamically loads classes, and provides a service to retrieve the class name for a point calculator.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["point calculator", "loader", "dynamic loading", "service layer"], "dependencyProfile": "inbound"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.deltaY", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The delta y (height difference) to an element in the direction in a grid\r\n * with 0,0 (x,y) as its top-left element.\r\n */\r\nprivate final int deltaY;", "visibility": "private", "simpleName": "deltaY", "qualifiedName": "nl.tudelft.jpacman.board.Direction.deltaY", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "run()", "qualifiedName": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void run() {\r\n    nl.tudelft.jpacman.board.Direction nextMove = this.npc.nextMove();\r\n    if (nextMove != null) {\r\n        this.move(this.npc, nextMove);\r\n    }\r\n    long interval = this.npc.getInterval();\r\n    this.service.schedule(this, interval, java.util.concurrent.TimeUnit.MILLISECONDS);\r\n}", "docComment": "", "metaSrc": "source code", "description": "Runs an NPC's move task by determining its next move and scheduling it to repeat at a specified interval.", "returns": "", "reason": "This method is part of the Service Layer as it orchestrates the movement of NPCs in the game, which is a core functionality of the application.", "howToUse": "Call this method to start the NPC's move task. It will determine the next move for the NPC and schedule it to repeat at the specified interval.", "howItWorks": "The method first retrieves the next move for the NPC using the `nextMove()` method. If a valid move is determined, it moves the NPC in that direction using the `move()` method. Then, it schedules itself to run again after the specified interval using the `schedule()` method.", "assertions": {"preConditions": ["The NPC must be initialized and have a square occupied."], "postConditions": ["The NPC should move in the determined direction if possible."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "occupy(nl.tudelft.jpacman.board.Square)", "qualifiedName": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "kind": "method", "sourceText": "/**\r\n * Occupies the target square iff this unit is allowed to as decided by\r\n * {@link Square#isAccessibleTo(Unit)}.\r\n *\r\n * @param target\r\n * \t\tThe square to occupy.\r\n */\r\npublic void occupy(nl.tudelft.jpacman.board.Square target) {\r\n    assert target != null;\r\n    if (this.square != null) {\r\n        this.square.remove(this);\r\n    }\r\n    this.square = target;\r\n    target.put(this);\r\n    assert this.invariant();\r\n}", "docComment": "Occupies the target square iff this unit is allowed to as decided by\r\n{@link Square#isAccessibleTo(Unit)}.\r\n\r\n@param target\r\n\t\tThe square to occupy.\r\n", "metaSrc": "source code", "description": "Adds an occupant to a square and updates the unit's state.", "returns": "", "reason": "This method manages the occupancy of a square by updating the unit's state and ensuring consistency.", "howToUse": "Call this method with a valid Square object to add an occupant to that square.", "howItWorks": "The method first checks if the current square is not null, then removes the unit from its current square (if any), updates the unit's square reference, adds the unit to the new square, and finally verifies the invariant of the unit's state.", "assertions": {"preConditions": ["target != null"], "postConditions": ["this.square == target", "this.invariant() == true"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.getInterval()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getInterval()", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.getInterval()", "kind": "method", "sourceText": "/**\r\n * The time that should be taken between moves.\r\n *\r\n * @return The suggested delay between moves in milliseconds.\r\n */\r\npublic long getInterval() {\r\n    return this.moveInterval + new java.util.Random().nextInt(this.intervalVariation);\r\n}", "docComment": "The time that should be taken between moves.\r\n\r\n@return The suggested delay between moves in milliseconds.\r\n", "metaSrc": "source code", "description": "Returns the interval for ghost movement, which is the sum of moveInterval and a random number between 0 (inclusive) and intervalVariation (exclusive).", "returns": "A long value representing the interval for ghost movement.", "reason": "The method provides a dynamic interval for ghost movement to ensure they do not all move at the same time, adding an element of unpredictability and making the game more challenging.", "howToUse": "Call this method to get the current interval for ghost movement. It is typically used in the logic that determines when ghosts should change direction or move.", "howItWorks": "The method calculates the interval by adding the moveInterval (a fixed value) to a random number generated using java.util.Random().nextInt(this.intervalVariation). This ensures that each ghost has a slightly different movement pattern, making the game more dynamic and engaging.", "preConditions": ["moveInterval is a valid long value", "intervalVariation is a positive integer"], "postConditions": ["The returned interval is a long value between moveInterval (inclusive) and moveInterval + intervalVariation (exclusive)."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.board", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The board of this level.\r\n */\r\nprivate final nl.tudelft.jpacman.board.Board board;", "visibility": "private", "simpleName": "board", "qualifiedName": "nl.tudelft.jpacman.level.Level.board", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.value", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The point value of this pellet.\r\n */\r\nprivate final int value;", "visibility": "private", "simpleName": "value", "qualifiedName": "nl.tudelft.jpacman.level.Pellet.value", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.getHeight()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getHeight()", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.getHeight()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic int getHeight() {\r\n    return 0;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.pacManUI", "labels": ["Variable"], "properties": {"sourceText": "private nl.tudelft.jpacman.ui.PacManUI pacManUI;", "visibility": "private", "simpleName": "pacManUI", "qualifiedName": "nl.tudelft.jpacman.Launcher.pacManUI", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int).0", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.board.Board.squareAt(int,int).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The x-coordinate of the square to retrieve."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).2", "labels": ["Variable"], "properties": {"simpleName": "loop", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "Whether or not this sprite should be looping."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder).0", "labels": ["Variable"], "properties": {"simpleName": "builder", "qualifiedName": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The builder object used to configure the PacMan UI."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "private nl.tudelft.jpacman.ui.Action moveTowardsDirection(nl.tudelft.jpacman.board.Direction direction) {\r\n    return () -> {\r\n        assert this.game != null;\r\n        this.getGame().move(this.getSinglePlayer(this.getGame()), direction);\r\n    };\r\n}", "docComment": "", "metaSrc": "source code", "description": "Returns an action that moves the single player in the game towards the specified direction.", "returns": "A lambda expression that represents an action to move the player.", "reason": "This method provides a way to encapsulate the logic for moving a player in the game, allowing it to be executed asynchronously or triggered by user input.", "howToUse": "Call this method with the desired direction to create an action that can be executed later.", "howItWorks": "The method creates a lambda expression that checks if the game is not null and then moves the single player in the specified direction using the `move` method of the game.", "assertions": {"preConditions": ["this.game != null"], "postConditions": []}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).4", "labels": ["Variable"], "properties": {"simpleName": "square", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code", "description": "The square from which to start adding targets."}}}, {"data": {"id": "nl", "labels": ["Container"], "properties": {"simpleName": "nl", "qualifiedName": "nl", "kind": "package", "metaSrc": "source code", "description": "Manages game-related operations, including parsing maps, creating levels, and handling player movements.", "layer": "Service Layer", "title": "Game Management Layer", "keywords": ["game", "operations", "map", "level", "player"]}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.scoreFormatter", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The way to format the score information.\r\n */\r\nprivate nl.tudelft.jpacman.ui.ScorePanel.ScoreFormatter scoreFormatter = nl.tudelft.jpacman.ui.ScorePanel.DEFAULT_SCORE_FORMATTER;", "visibility": "private", "simpleName": "scoreFormatter", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel.scoreFormatter", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "randomMove()", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "kind": "method", "sourceText": "/**\r\n * Determines a possible move in a random direction.\r\n *\r\n * @return A direction in which the ghost can move, or <code>null</code> if\r\nthe ghost is shut in by inaccessible squares.\r\n */\r\nprotected nl.tudelft.jpacman.board.Direction randomMove() {\r\n    nl.tudelft.jpacman.board.Square square = this.getSquare();\r\n    java.util.List<nl.tudelft.jpacman.board.Direction> directions = new java.util.ArrayList<nl.tudelft.jpacman.board.Direction>();\r\n    for (nl.tudelft.jpacman.board.Direction direction : nl.tudelft.jpacman.board.Direction.values()) {\r\n        if (square.getSquareAt(direction).isAccessibleTo(this)) {\r\n            directions.add(direction);\r\n        }\r\n    }\r\n    if (directions.isEmpty()) {\r\n        return null;\r\n    }\r\n    int i = new java.util.Random().nextInt(directions.size());\r\n    return directions.get(i);\r\n}", "docComment": "Determines a possible move in a random direction.\r\n\r\n@return A direction in which the ghost can move, or <code>null</code> if\r\nthe ghost is shut in by inaccessible squares.\r\n", "metaSrc": "source code", "description": "Returns a random accessible direction for a ghost to move on the board.", "returns": "A Direction object representing the chosen random accessible direction.", "reason": "The method provides a way for ghosts to navigate the game board by choosing a random direction that allows them to access an adjacent square.", "howToUse": "Call the method on a Ghost instance to get a random accessible direction.", "howItWorks": "The method iterates over all possible directions, checks if each direction leads to an accessible square for the ghost, and returns a random one from the list of accessible directions. If no accessible directions are found, it returns null.", "assertions": {"preConditions": ["A Ghost instance is provided"], "postConditions": ["A Direction object is returned or null if no accessible direction exists"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.current", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The index of the current frame.\r\n */\r\nprivate int current;", "visibility": "private", "simpleName": "current", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.current", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap", "labels": ["Structure"], "properties": {"docComment": "A table containing all (relevant) collisions between different types of\r\nunits.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "CollisionMap", "qualifiedName": "nl.tudelft.jpacman.level.CollisionMap", "kind": "interface", "metaSrc": "source code", "description": "Handles collisions between units in the game board, defining how two units should interact when they collide.", "layer": "Domain Layer", "roleStereotype": "Service Provider", "keywords": ["collision", "unit", "game logic"], "dependencyProfile": "hidden"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "collider", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that initiates the collision."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.serialVersionUID", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Default serialisation ID.\r\n */\r\nprivate static final long serialVersionUID = 1L;", "visibility": "private", "simpleName": "serialVersionUID", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel.serialVersionUID", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.BACKGROUND_COLOR", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The background colour of the board.\r\n */\r\nprivate static final java.awt.Color BACKGROUND_COLOR = java.awt.Color.BLACK;", "visibility": "private", "simpleName": "BACKGROUND_COLOR", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.BACKGROUND_COLOR", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(nl.tudelft.jpacman.game.Game)", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new board panel that will display the provided game.\r\n *\r\n * @param game\r\n * \t\tThe game to display.\r\n */\r\nBoardPanel(nl.tudelft.jpacman.game.Game game) {\r\n    super();\r\n    assert game != null;\r\n    this.game = game;\r\n    nl.tudelft.jpacman.board.Board board = game.getLevel().getBoard();\r\n    int w = board.getWidth() * nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE;\r\n    int h = board.getHeight() * nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE;\r\n    java.awt.Dimension size = new java.awt.Dimension(w, h);\r\n    this.setMinimumSize(size);\r\n    this.setPreferredSize(size);\r\n}", "docComment": "Creates a new board panel that will display the provided game.\r\n\r\n@param game\r\n\t\tThe game to display.\r\n", "metaSrc": "source code", "description": "Initializes the board panel for displaying the Pacman game based on the current level's board configuration.", "returns": "A new BoardPanel instance initialized with the given game.", "reason": "This method is responsible for setting up the initial state of the Pacman game's display, including the board size and minimum/preferred dimensions.", "howToUse": "Create a Game instance and pass it to the BoardPanel constructor to initialize the panel.", "howItWorks": "The method retrieves the current level's board from the game, calculates its width and height in pixels, and sets the panel's size accordingly. It then configures the minimum and preferred sizes of the panel.", "assertions": {"preConditions": ["game is not null"], "postConditions": ["this.game is set to game", "panel size is calculated based on board dimensions", "minimum and preferred sizes are set for the panel"]}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createBoard(nl.tudelft.jpacman.board.Square[][])", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "kind": "method", "sourceText": "/**\r\n * Creates a new board from a grid of cells and connects it.\r\n *\r\n * @param grid\r\n * \t\tThe square grid of cells, in which grid[x][y] corresponds to\r\n * \t\tthe square at position x,y.\r\n * @return A new board, wrapping a grid of connected cells.\r\n */\r\npublic nl.tudelft.jpacman.board.Board createBoard(nl.tudelft.jpacman.board.Square[][] grid) {\r\n    assert grid != null;\r\n    nl.tudelft.jpacman.board.Board board = new nl.tudelft.jpacman.board.Board(grid);\r\n    int width = board.getWidth();\r\n    int height = board.getHeight();\r\n    for (int x = 0; x < width; x++) {\r\n        for (int y = 0; y < height; y++) {\r\n            nl.tudelft.jpacman.board.Square square = grid[x][y];\r\n            for (nl.tudelft.jpacman.board.Direction dir : nl.tudelft.jpacman.board.Direction.values()) {\r\n                int dirX = ((width + x) + dir.getDeltaX()) % width;\r\n                int dirY = ((height + y) + dir.getDeltaY()) % height;\r\n                nl.tudelft.jpacman.board.Square neighbour = grid[dirX][dirY];\r\n                square.link(neighbour, dir);\r\n            }\r\n        }\r\n    }\r\n    return board;\r\n}", "docComment": "Creates a new board from a grid of cells and connects it.\r\n\r\n@param grid\r\n\t\tThe square grid of cells, in which grid[x][y] corresponds to\r\n\t\tthe square at position x,y.\r\n@return A new board, wrapping a grid of connected cells.\r\n", "metaSrc": "source code", "description": "Creates a board by linking each square to its neighbors in all directions, wrapping around the edges.", "returns": "A new Board instance with linked squares.", "reason": "This method initializes a board by connecting each square to its neighbors, ensuring that movement wraps around the edges of the board.", "howToUse": "Call this method with a 2D array representing the board's layout. The grid should contain instances of Square.", "howItWorks": "The method iterates over each cell in the grid and links it to its neighbors in all four cardinal directions (up, down, left, right). It uses modulo arithmetic to handle wrapping around the edges of the board.", "assertions": {"preConditions": ["grid is not null"], "postConditions": ["Each square in the grid has its neighbors linked correctly."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "squareAt(int,int)", "qualifiedName": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "kind": "method", "sourceText": "/**\r\n * Returns the square at the given <code>x,y</code> position.\r\n *\r\n * Precondition: The <code>(x, y)</code> coordinates are within the\r\n * width and height of the board.\r\n *\r\n * @param x\r\n * \t\tThe <code>x</code> position (column) of the requested square.\r\n * @param y\r\n * \t\tThe <code>y</code> position (row) of the requested square.\r\n * @return The square at the given <code>x,y</code> position (never null).\r\n */\r\npublic nl.tudelft.jpacman.board.Square squareAt(int x, int y) {\r\n    assert this.withinBorders(x, y);\r\n    nl.tudelft.jpacman.board.Square result = this.board[x][y];\r\n    assert result != null : \"Follows from invariant.\";\r\n    return result;\r\n}", "docComment": "Returns the square at the given <code>x,y</code> position.\r\n\r\nPrecondition: The <code>(x, y)</code> coordinates are within the\r\nwidth and height of the board.\r\n\r\n@param x\r\n\t\tThe <code>x</code> position (column) of the requested square.\r\n@param y\r\n\t\tThe <code>y</code> position (row) of the requested square.\r\n@return The square at the given <code>x,y</code> position (never null).\r\n", "metaSrc": "source code", "description": "Returns the square at the specified coordinates on the board, asserting that the coordinates are within bounds.", "returns": "A Square object representing the square at the specified coordinates.", "reason": "This method provides a safe way to access squares on the board, ensuring that the coordinates are within valid bounds before attempting to retrieve the square.", "howToUse": "Call this method with the desired x and y coordinates to get the corresponding Square object. Ensure that the coordinates are within the board's boundaries.", "howItWorks": "The method first checks if the given coordinates are within the board's borders using the `withinBorders` method. If they are, it retrieves the square at those coordinates from the `board` array and returns it. The method also includes assertions to ensure that the retrieved square is not null.", "assertions": {"preConditions": ["The x and y coordinates must be within the bounds of the board."], "postConditions": ["The returned Square object must not be null if the coordinates are valid."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.service", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The service executing the task.\r\n */\r\nprivate final java.util.concurrent.ScheduledExecutorService service;", "visibility": "private", "simpleName": "service", "qualifiedName": "nl.tudelft.jpacman.level.Level$NpcMoveTask.service", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite", "labels": ["Structure"], "properties": {"docComment": "Empty Sprite which does not contain any data. When this sprite is drawn,\r\nnothing happens.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "EmptySprite", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite", "kind": "class", "metaSrc": "source code", "description": "The EmptySprite class is responsible for representing an empty space in the game grid, providing basic drawing functionality and dimensions.", "layer": "Domain Layer", "roleStereotype": "Information Holder", "keywords": ["empty", "space", "grid", "drawing", "dimensions"]}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).0", "labels": ["Variable"], "properties": {"simpleName": "message", "qualifiedName": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).0", "labels": ["Variable"], "properties": {"simpleName": "baseImage", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The base image to be split into frames."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "squaresAheadOf(int)", "qualifiedName": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "kind": "method", "sourceText": "/**\r\n * A utility method for implementing the ghost AI.\r\n *\r\n * @param amountToLookAhead\r\n * \t\tthe amount of squares to follow this units direction in.\r\n * @return The square amountToLookAhead spaces in front of this unit.\r\n */\r\npublic nl.tudelft.jpacman.board.Square squaresAheadOf(int amountToLookAhead) {\r\n    nl.tudelft.jpacman.board.Direction targetDirection = this.getDirection();\r\n    nl.tudelft.jpacman.board.Square destination = this.getSquare();\r\n    for (int i = 0; i < amountToLookAhead; i++) {\r\n        destination = destination.getSquareAt(targetDirection);\r\n    }\r\n    return destination;\r\n}", "docComment": "A utility method for implementing the ghost AI.\r\n\r\n@param amountToLookAhead\r\n\t\tthe amount of squares to follow this units direction in.\r\n@return The square amountToLookAhead spaces in front of this unit.\r\n", "metaSrc": "source code", "description": "Returns the square that is 'amountToLookAhead' steps ahead in the current direction from the unit's current position.", "returns": "The Square object representing the square that is 'amountToLookAhead' steps ahead in the current direction from the unit's current position.", "reason": "This method provides a way to determine the location of a unit on the board based on its current direction and distance.", "howToUse": "Call this method with an integer value representing the number of squares you want to look ahead. The method will return the square at that position.", "howItWorks": "The method starts by getting the current direction of the unit and the square it is currently on. It then iterates 'amountToLookAhead' times, moving one step in the current direction each time, until it reaches the desired destination square.", "preConditions": ["The unit must have a valid square assigned to it."], "postConditions": ["The returned square is the one that is 'amountToLookAhead' steps ahead of the unit's current position in the specified direction."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0", "labels": ["Variable"], "properties": {"simpleName": "spriteMap", "qualifiedName": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A map of directions to sprites for the player."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "labels": ["Constructor"], "properties": {"visibility": "default", "simpleName": "<init>(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "qualifiedName": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new task.\r\n *\r\n * @param service\r\n * \t\tThe service that executes the task.\r\n * @param npc\r\n * \t\tThe NPC to move.\r\n */\r\nNpcMoveTask(java.util.concurrent.ScheduledExecutorService service, nl.tudelft.jpacman.npc.Ghost npc) {\r\n    super();\r\n    this.service = service;\r\n    this.npc = npc;\r\n}", "docComment": "Creates a new task.\r\n\r\n@param service\r\n\t\tThe service that executes the task.\r\n@param npc\r\n\t\tThe NPC to move.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "draw(java.awt.Graphics,int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void draw(java.awt.Graphics graphics, int x, int y, int width, int height) {\r\n    graphics.drawImage(this.image, x, y, x + width, y + height, 0, 0, this.image.getWidth(null), this.image.getHeight(null), null);\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map).0", "labels": ["Variable"], "properties": {"simpleName": "keyMappings", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.sprite.PacManSprites)", "qualifiedName": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new player factory.\r\n *\r\n * @param spriteStore\r\n * \t\tThe sprite store containing the Pac-Man sprites.\r\n */\r\npublic PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites spriteStore) {\r\n    super();\r\n    this.sprites = spriteStore;\r\n}", "docComment": "Creates a new player factory.\r\n\r\n@param spriteStore\r\n\t\tThe sprite store containing the Pac-Man sprites.\r\n", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).3", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).3", "kind": "parameter", "parameterPosition": 3, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.pointCalculator", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The way to calculate points upon collisions.\r\n */\r\nprivate final nl.tudelft.jpacman.points.PointCalculator pointCalculator;", "visibility": "private", "simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.pointCalculator", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "x", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The x-coordinate where the sprite should be drawn."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square", "labels": ["Structure"], "properties": {"docComment": "A square on a {@link Board}, which can (or cannot, depending on the type) be\r\noccupied by units.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Square", "qualifiedName": "nl.tudelft.jpacman.board.Square", "kind": "abstract class", "metaSrc": "source code", "description": "The abstract class manages a collection of units and their relationships, providing methods to add, remove, and retrieve occupants, as well as link neighbors.", "layer": "Domain Layer", "roleStereotype": "Structurer", "keywords": ["collection", "units", "relationships", "add", "remove", "retrieve"], "dependencyProfile": "inbound"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator).0", "labels": ["Variable"], "properties": {"simpleName": "pointCalculator", "qualifiedName": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The point calculator used to determine the points for different actions in the game."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).0", "labels": ["Variable"], "properties": {"simpleName": "unit", "qualifiedName": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit to be moved."}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][]).0", "labels": ["Variable"], "properties": {"simpleName": "map", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][]).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "A 2D array representing the game map with characters indicating different types of squares."}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator", "labels": ["Structure"], "properties": {"docComment": "A simple, minimalistic point calculator just\r\nadding points for each pellet consumed.\r\n", "simpleName": "DefaultPointCalculator", "qualifiedName": "nl.tudelft.jpacman.points.DefaultPointCalculator", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for calculating and updating points in the game based on player actions such as consuming pellets and colliding with ghosts.", "layer": "Service Layer", "roleStereotype": "Service Provider", "keywords": ["point calculator", "game logic", "player score"], "dependencyProfile": "outbound"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.hasSquare()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "hasSquare()", "qualifiedName": "nl.tudelft.jpacman.board.Unit.hasSquare()", "kind": "method", "sourceText": "/**\r\n * Returns whether this unit is currently on  a square.\r\n *\r\n * @return True iff the unit is occupying a square at the moment.\r\n */\r\npublic boolean hasSquare() {\r\n    return this.square != null;\r\n}", "docComment": "Returns whether this unit is currently on  a square.\r\n\r\n@return True iff the unit is occupying a square at the moment.\r\n", "metaSrc": "source code", "description": "Checks if the unit is located on a square in the game board.", "returns": "Boolean indicating whether the unit has a square assigned to it.", "reason": "The method provides a simple way to determine if an entity (unit) is positioned within the game board, which is crucial for collision detection and other gameplay mechanics.", "howToUse": "Call `hasSquare()` on an instance of `Unit` to check if it has been assigned a square in the game board.", "howItWorks": "The method checks if the `square` field of the unit is not null. If it's not null, the unit is considered to be on a square; otherwise, it is not.", "preConditions": ["An instance of `Unit` exists.", "The `square` field has been initialized."], "postConditions": ["Returns true if the unit is on a square, false otherwise."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).0", "labels": ["Variable"], "properties": {"simpleName": "map", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The map data as a 2D array of characters."}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "labels": ["Variable"], "properties": {"simpleName": "spriteStore", "qualifiedName": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.SQUARES_AHEAD", "labels": ["Variable"], "properties": {"sourceText": "private static final int SQUARES_AHEAD = 4;", "visibility": "private", "simpleName": "SQUARES_AHEAD", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Pinky.SQUARES_AHEAD", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new animating sprite that will change frames every interval.\r\n *\r\n * @param frames\r\n * \t\tThe frames of this animation.\r\n * @param delay\r\n * \t\tThe delay between frames.\r\n * @param loop\r\n * \t\tWhether or not this sprite should be looping.\r\n * @param isAnimating\r\n * \t\tWhether or not this sprite is animating from the start.\r\n */\r\npublic AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[] frames, int delay, boolean loop, boolean isAnimating) {\r\n    super();\r\n    assert frames.length > 0;\r\n    this.animationFrames = frames.clone();\r\n    this.animationDelay = delay;\r\n    this.looping = loop;\r\n    this.animating = isAnimating;\r\n    this.current = 0;\r\n    this.lastUpdate = java.lang.System.currentTimeMillis();\r\n}", "docComment": "Creates a new animating sprite that will change frames every interval.\r\n\r\n@param frames\r\n\t\tThe frames of this animation.\r\n@param delay\r\n\t\tThe delay between frames.\r\n@param loop\r\n\t\tWhether or not this sprite should be looping.\r\n@param isAnimating\r\n\t\tWhether or not this sprite is animating from the start.\r\n", "metaSrc": "source code", "description": "Initializes an animated sprite with specified frames, delay, looping behavior, and animation state.", "returns": "The newly created AnimatedSprite instance.", "reason": "This method initializes an animated sprite with its frames, delay, looping behavior, and initial animation state. It is part of the Domain Layer as it handles the creation and configuration of domain objects.", "howToUse": "Create a new AnimatedSprite by providing an array of Sprite instances, a delay in milliseconds, whether to loop the animation, and the initial animation state (true for playing, false for paused).", "howItWorks": "The method initializes the sprite with the provided frames, sets the delay between frames, determines if the animation should loop, and sets the initial animation state. It also initializes the current frame index and the last update time.", "assertions": {"preConditions": ["frames.length > 0", "delay >= 0"], "postConditions": ["this.animationFrames == frames.clone()", "this.animationDelay == delay", "this.looping == loop", "this.animating == isAnimating", "this.current == 0", "this.lastUpdate > 0"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.npc", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The NPC to move.\r\n */\r\nprivate final nl.tudelft.jpacman.npc.Ghost npc;", "visibility": "private", "simpleName": "npc", "qualifiedName": "nl.tudelft.jpacman.level.Level$NpcMoveTask.npc", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "byte", "labels": ["Primitive"], "properties": {"simpleName": "byte", "qualifiedName": "byte", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player consuming a pellet."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).1", "labels": ["Variable"], "properties": {"simpleName": "parent", "qualifiedName": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The parent JFrame that will receive focus after a button is clicked."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "split(int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "kind": "method", "sourceText": "/**\r\n * Returns a portion of this sprite as a new Sprite.\r\n *\r\n * @param x\r\n * \t\tThe x start coordinate.\r\n * @param y\r\n * \t\tThe y start coordinate.\r\n * @param width\r\n * \t\tThe width of the target sprite.\r\n * @param height\r\n * \t\tThe height of the target sprite.\r\n * @return A new sprite of width x height, or a new {@link EmptySprite} if\r\nthe region was not in the current sprite.\r\n */\r\nnl.tudelft.jpacman.sprite.Sprite split(int x, int y, int width, int height);", "docComment": "Returns a portion of this sprite as a new Sprite.\r\n\r\n@param x\r\n\t\tThe x start coordinate.\r\n@param y\r\n\t\tThe y start coordinate.\r\n@param width\r\n\t\tThe width of the target sprite.\r\n@param height\r\n\t\tThe height of the target sprite.\r\n@return A new sprite of width x height, or a new {@link EmptySprite} if\r\nthe region was not in the current sprite.\r\n", "metaSrc": "source code", "description": "Splits the sprite into multiple smaller sprites based on given coordinates and dimensions.", "returns": "A new Sprite object representing the smaller sprite.", "reason": "This method is part of the domain layer as it deals with the creation and manipulation of game sprites, which are fundamental components of the Pacman game's logic.", "howToUse": "To use this method, call it on a Sprite instance, passing in the desired coordinates and dimensions for the region to split. The method will return a new Sprite object representing the smaller sprite.", "howItWorks": "The method creates a new Sprite object by extracting a portion of the original sprite's image based on the provided coordinates and dimensions. It then returns this new Sprite object.", "preConditions": ["The input values (x, y, width, height) must be valid integers representing the region to split."], "postConditions": ["A new Sprite object is created and returned, which represents a smaller portion of the original sprite's image."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "labels": ["Variable"], "properties": {"simpleName": "handler", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "kind": "parameter", "parameterPosition": 2, "metaSrc": "source code", "description": "The handler that handles the collision."}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.background", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The background for this square.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.Sprite background;", "visibility": "private", "simpleName": "background", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Ground.background", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.MOVE_INTERVAL", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The base movement interval.\r\n */\r\nprivate static final int MOVE_INTERVAL = 250;", "visibility": "private", "simpleName": "MOVE_INTERVAL", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky.MOVE_INTERVAL", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "labels": ["Variable"], "properties": {"simpleName": "square", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The square on which to search for units."}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "labels": ["Variable"], "properties": {"simpleName": "pellet", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The pellet that was consumed by the player."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "to", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The target square."}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).0", "labels": ["Variable"], "properties": {"simpleName": "keyCode", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The keycode to be mapped."}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.getWidth()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getWidth()", "qualifiedName": "nl.tudelft.jpacman.board.Board.getWidth()", "kind": "method", "sourceText": "/**\r\n * Returns the number of columns.\r\n *\r\n * @return The width of this board.\r\n */\r\npublic int getWidth() {\r\n    return this.board.length;\r\n}", "docComment": "Returns the number of columns.\r\n\r\n@return The width of this board.\r\n", "metaSrc": "source code", "description": "Returns the width of the board in terms of number of cells.", "returns": "The integer value representing the width of the board.", "reason": "This method provides a straightforward way to access the width of the game board, which is essential for determining the layout and placement of elements within the game.", "howToUse": "To use this method, simply call it on an instance of the `Board` class. It will return the number of cells along the x-axis of the board.", "howItWorks": "The method accesses the `board` array, which is a two-dimensional array representing the game grid. The length of this array gives the width of the board, as each element in the outer array represents a row and each element within a row represents a cell.", "preConditions": ["An instance of the `Board` class exists.", "The `board` array has been initialized with appropriate dimensions."], "postConditions": ["The method returns an integer value representing the width of the board.", "No side effects are introduced by this method call."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel", "labels": ["Structure"], "properties": {"docComment": "A panel containing a button for every registered action.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "ButtonPanel", "qualifiedName": "nl.tudelft.jpacman.ui.ButtonPanel", "kind": "class", "metaSrc": "source code", "description": "Manages the user interface for a Pacman game by creating buttons that perform actions and focus the parent JFrame.", "layer": "Presentation Layer", "roleStereotype": "User Interfacer", "keywords": ["button panel", "Pacman game", "user interface", "buttons", "actions", "focus"], "dependencyProfile": "hidden"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.alive", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * <code>true</code> iff this player is alive.\r\n */\r\nprivate boolean alive;", "visibility": "private", "simpleName": "alive", "qualifiedName": "nl.tudelft.jpacman.level.Player.alive", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getGroundSprite()", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The sprite for the ground.\r\n */\r\npublic nl.tudelft.jpacman.sprite.Sprite getGroundSprite() {\r\n    return this.loadSprite(\"/sprite/floor.png\");\r\n}", "docComment": "\r\n@return The sprite for the ground.\r\n", "metaSrc": "source code", "description": "Loads a floor sprite from a resource file and returns it as an ImageSprite.", "returns": "A new ImageSprite representing the loaded floor sprite.", "reason": "The method provides a simple way to load a sprite for use in the game, which is part of the domain layer where sprites are defined and managed.", "howToUse": "Call `getGroundSprite()` to retrieve the floor sprite.", "howItWorks": "The method uses the `loadSprite` method from the superclass to load the 'floor.png' resource file. The loaded image is then returned as an ImageSprite object.", "preConditions": [], "postConditions": ["A new ImageSprite representing the floor sprite is returned."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "labels": ["Variable"], "properties": {"simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The main game instance."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "registerPlayer(nl.tudelft.jpacman.level.Player)", "qualifiedName": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "kind": "method", "sourceText": "/**\r\n * Registers a player on this level, assigning him to a starting position. A\r\n * player can only be registered once, registering a player again will have\r\n * no effect.\r\n *\r\n * @param player\r\n * \t\tThe player to register.\r\n */\r\npublic void registerPlayer(nl.tudelft.jpacman.level.Player player) {\r\n    assert player != null;\r\n    assert !this.startSquares.isEmpty();\r\n    if (this.players.contains(player)) {\r\n        return;\r\n    }\r\n    this.players.add(player);\r\n    nl.tudelft.jpacman.board.Square square = this.startSquares.get(this.startSquareIndex);\r\n    player.occupy(square);\r\n    this.startSquareIndex++;\r\n    this.startSquareIndex %= this.startSquares.size();\r\n}", "docComment": "Registers a player on this level, assigning him to a starting position. A\r\nplayer can only be registered once, registering a player again will have\r\nno effect.\r\n\r\n@param player\r\n\t\tThe player to register.\r\n", "metaSrc": "source code", "description": "Registers a player on the level, assigns them to a starting square and updates their state.", "returns": "", "reason": "This method manages the registration of players on a level, ensuring they are assigned to starting squares and their states are updated accordingly.", "howToUse": "Call this method with a valid Player object to register them on the current level. Ensure that the player is not null and that there are available start squares before calling this method.", "howItWorks": "The method first checks if the player is already registered, returning early if so. It then assigns the player to the next starting square in the list, updating their state by occupying the square. The index of the next starting square is incremented and wrapped around using modulo arithmetic.", "assertions": {"preConditions": ["player != null", "!this.startSquares.isEmpty()"], "postConditions": ["this.players.contains(player)", "player.isOccupied() == true"]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "labels": ["Constructor"], "properties": {"visibility": "public", "simpleName": "<init>(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new UI for a JPacman game.\r\n *\r\n * @param game\r\n * \t\tThe game to play.\r\n * @param buttons\r\n * \t\tThe map of caption-to-action entries that will appear as\r\n * \t\tbuttons on the interface.\r\n * @param keyMappings\r\n * \t\tThe map of keyCode-to-action entries that will be added as key\r\n * \t\tlisteners to the interface.\r\n * @param scoreFormatter\r\n * \t\tThe formatter used to display the current score.\r\n */\r\npublic PacManUI(final nl.tudelft.jpacman.game.Game game, final java.util.Map<java.lang.String, nl.tudelft.jpacman.ui.Action> buttons, final java.util.Map<java.lang.Integer, nl.tudelft.jpacman.ui.Action> keyMappings, nl.tudelft.jpacman.ui.ScorePanel.ScoreFormatter scoreFormatter) {\r\n    super(\"JPacman\");\r\n    assert game != null;\r\n    assert buttons != null;\r\n    assert keyMappings != null;\r\n    this.setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\r\n    nl.tudelft.jpacman.ui.PacKeyListener keys = new nl.tudelft.jpacman.ui.PacKeyListener(keyMappings);\r\n    this.addKeyListener(keys);\r\n    javax.swing.JPanel buttonPanel = new nl.tudelft.jpacman.ui.ButtonPanel(buttons, this);\r\n    this.scorePanel = new nl.tudelft.jpacman.ui.ScorePanel(game.getPlayers());\r\n    if (scoreFormatter != null) {\r\n        this.scorePanel.setScoreFormatter(scoreFormatter);\r\n    }\r\n    this.boardPanel = new nl.tudelft.jpacman.ui.BoardPanel(game);\r\n    java.awt.Container contentPanel = this.getContentPane();\r\n    contentPanel.setLayout(new java.awt.BorderLayout());\r\n    contentPanel.add(buttonPanel, java.awt.BorderLayout.SOUTH);\r\n    contentPanel.add(this.scorePanel, java.awt.BorderLayout.NORTH);\r\n    contentPanel.add(this.boardPanel, java.awt.BorderLayout.CENTER);\r\n    this.pack();\r\n}", "docComment": "Creates a new UI for a JPacman game.\r\n\r\n@param game\r\n\t\tThe game to play.\r\n@param buttons\r\n\t\tThe map of caption-to-action entries that will appear as\r\n\t\tbuttons on the interface.\r\n@param keyMappings\r\n\t\tThe map of keyCode-to-action entries that will be added as key\r\n\t\tlisteners to the interface.\r\n@param scoreFormatter\r\n\t\tThe formatter used to display the current score.\r\n", "metaSrc": "source code", "description": "Initializes the PacMan user interface by setting up game components and listeners.", "returns": "The initialized PacManUI instance.", "reason": "This method is responsible for setting up the user interface components and listeners, which are essential for interacting with the game.", "howToUse": "Create an instance of PacManUI by passing the necessary parameters: a Game object, button mappings, key mappings, and an optional score formatter.", "howItWorks": "The method initializes the window, adds key listeners, creates panels for buttons, scores, and the game board, sets up layouts, and packs the components to display the user interface.", "assertions": {"preConditions": ["game is not null", "buttons is not null", "keyMappings is not null"], "postConditions": ["PacManUI instance is created with all necessary components and listeners set up."]}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).4", "labels": ["Variable"], "properties": {"simpleName": "height", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).4", "kind": "parameter", "parameterPosition": 4, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "keyTyped(java.awt.event.KeyEvent)", "qualifiedName": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void keyTyped(java.awt.event.KeyEvent event) {\r\n    // do nothing\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic boolean isAccessibleTo(nl.tudelft.jpacman.board.Unit unit) {\r\n    return true;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.opposite()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "opposite()", "qualifiedName": "nl.tudelft.jpacman.board.Direction.opposite()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return The direction that is opposite to this direction.\r\n */\r\npublic nl.tudelft.jpacman.board.Direction opposite() {\r\n    switch (this) {\r\n        case NORTH :\r\n            return nl.tudelft.jpacman.board.Direction.SOUTH;\r\n        case SOUTH :\r\n            return nl.tudelft.jpacman.board.Direction.NORTH;\r\n        case WEST :\r\n            return nl.tudelft.jpacman.board.Direction.EAST;\r\n        case EAST :\r\n            return nl.tudelft.jpacman.board.Direction.WEST;\r\n        default :\r\n            throw new java.lang.IllegalStateException(\"Received an unknown enum value.\");\r\n    }\r\n}", "docComment": "\r\n@return The direction that is opposite to this direction.\r\n", "metaSrc": "source code", "description": "Returns the opposite direction to the current direction in the Pacman game.", "returns": "The opposite Direction enum value.", "reason": "This method provides a convenient way to determine the opposing movement direction for Pacman, which is essential for navigation and collision detection.", "howToUse": "Call `opposite()` on an instance of `Direction` to get its opposite.", "howItWorks": "The switch statement checks the current direction and returns the corresponding opposite direction. If an unknown enum value is received, it throws an IllegalStateException.", "preConditions": ["A valid Direction enum value is provided as input."], "postConditions": ["Returns the opposite Direction enum value.", "Throws an IllegalStateException if an invalid enum value is provided."], "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "from", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The starting square."}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "unit", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "labels": ["Operation"], "properties": {"visibility": "default", "simpleName": "createGhost()", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "kind": "method", "sourceText": "/**\r\n * Creates a new ghost.\r\n *\r\n * @return The new ghost.\r\n */\r\nnl.tudelft.jpacman.npc.Ghost createGhost() {\r\n    this.ghostIndex++;\r\n    this.ghostIndex %= nl.tudelft.jpacman.level.LevelFactory.GHOSTS;\r\n    switch (this.ghostIndex) {\r\n        case nl.tudelft.jpacman.level.LevelFactory.BLINKY :\r\n            return this.ghostFact.createBlinky();\r\n        case nl.tudelft.jpacman.level.LevelFactory.INKY :\r\n            return this.ghostFact.createInky();\r\n        case nl.tudelft.jpacman.level.LevelFactory.PINKY :\r\n            return this.ghostFact.createPinky();\r\n        case nl.tudelft.jpacman.level.LevelFactory.CLYDE :\r\n            return this.ghostFact.createClyde();\r\n        default :\r\n            return new nl.tudelft.jpacman.level.LevelFactory.RandomGhost(this.sprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor.RED));\r\n    }\r\n}", "docComment": "Creates a new ghost.\r\n\r\n@return The new ghost.\r\n", "metaSrc": "source code", "description": "Creates a new ghost based on an index, cycling through predefined ghosts and using random ones if the index is out of range.", "returns": "An instance of nl.tudelft.jpacman.npc.Ghost representing the created ghost.", "reason": "The method manages the creation of different ghost types in a Pacman game, providing flexibility through indexing and fallback to random ghosts when necessary.", "howToUse": "Call this method to get a new ghost instance. It will cycle through predefined ghosts (Blinky, Inky, Pinky, Clyde) based on an index, or return a random ghost if the index is out of range.", "howItWorks": "The method uses a switch statement to determine which ghost to create based on the current `ghostIndex`. If the index is within the valid range for predefined ghosts, it calls the corresponding factory method. Otherwise, it creates a new RandomGhost using the sprite for the red ghost.", "assertions": {"preConditions": ["The `ghostFact` field must be initialized and functional.", "The `sprites` field must have a valid `getGhostSprite` method that returns animated sprites for ghosts."], "postConditions": ["The returned object is an instance of nl.tudelft.jpacman.npc.Ghost."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "/**\r\n * Handles this collision by flipping the collider and collidee, making\r\n * it compatible with the initial collision.\r\n */\r\n@java.lang.Override\r\npublic void handleCollision(C1 collider, C2 collidee) {\r\n    this.handler.handleCollision(collidee, collider);\r\n}", "docComment": "Handles this collision by flipping the collider and collidee, making\r\nit compatible with the initial collision.\r\n", "metaSrc": "source code", "description": "Reverses the order of collision handling by swapping the collider and collidee in the collision handler.", "returns": "", "reason": "This method provides a way to handle collisions in reverse order, which can be useful for certain game mechanics or debugging purposes.", "howToUse": "Call this method when you want to handle the collision between two units in reverse order.", "howItWorks": "The method swaps the collider and collidee parameters before calling the handler's handleCollision method.", "preConditions": ["Both collider and collidee are valid Unit objects."], "postConditions": ["The handler is called with collidee as the collider and collider as the collidee."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).1", "labels": ["Variable"], "properties": {"simpleName": "npc", "qualifiedName": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createPacMan()", "qualifiedName": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "kind": "method", "sourceText": "/**\r\n * Creates a new player with the classic Pac-Man sprites.\r\n *\r\n * @return A new player.\r\n */\r\npublic nl.tudelft.jpacman.level.Player createPacMan() {\r\n    return new nl.tudelft.jpacman.level.Player(this.getSprites().getPacmanSprites(), this.getSprites().getPacManDeathAnimation());\r\n}", "docComment": "Creates a new player with the classic Pac-Man sprites.\r\n\r\n@return A new player.\r\n", "metaSrc": "source code", "description": "Creates a new PacMan player instance using specified sprites and death animation.", "returns": "A new Player instance representing PacMan.", "reason": "The method is part of the Service Layer as it orchestrates the creation of a game entity (PacMan) based on predefined resources.", "howToUse": "Call this method from within a game level factory to instantiate a PacMan player.", "howItWorks": "The method retrieves sprites and death animation from the Sprites instance, then uses these resources to create a new Player object.", "assertions": {"preConditions": ["A valid Sprites instance is available.", "PacMan sprites are correctly defined in the Sprites instance."], "postConditions": ["A PacMan player instance is created with the specified sprites and death animation."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic boolean isAccessibleTo(nl.tudelft.jpacman.board.Unit unit) {\r\n    return false;\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.getPlayers()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "getPlayers()", "qualifiedName": "nl.tudelft.jpacman.game.SinglePlayerGame.getPlayers()", "kind": "method", "sourceText": "@java.lang.Override\r\npublic java.util.List<nl.tudelft.jpacman.level.Player> getPlayers() {\r\n    return com.google.common.collect.ImmutableList.of(this.player);\r\n}", "docComment": "", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).0", "labels": ["Variable"], "properties": {"simpleName": "levelFactory", "qualifiedName": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationFrames", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The animation itself, in frames.\r\n */\r\nprivate final nl.tudelft.jpacman.sprite.Sprite[] animationFrames;", "visibility": "private", "simpleName": "animationFrames", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationFrames", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List).0", "labels": ["Variable"], "properties": {"simpleName": "players", "qualifiedName": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).1", "labels": ["Variable"], "properties": {"simpleName": "y", "qualifiedName": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The y-coordinate of the top-left corner of the sub-image."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost", "labels": ["Structure"], "properties": {"docComment": "A non-player unit.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "Ghost", "qualifiedName": "nl.tudelft.jpacman.npc.Ghost", "kind": "abstract class", "metaSrc": "source code", "description": "The abstract class `nl.tudelft.jpacman.npc.Ghost` is responsible for managing the behavior and appearance of ghosts in a Pacman game. It provides methods to initialize, calculate movement intervals, retrieve sprites, determine AI moves, and choose random directions. The class acts as a service provider by handling requests related to ghost movement and behavior.", "layer": "Domain Layer", "roleStereotype": "Service Provider", "keywords": ["Ghost", "Pacman", "AI", "Movement", "Sprite"], "dependencyProfile": "transit"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "labels": ["Variable"], "properties": {"simpleName": "spriteStore", "qualifiedName": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "kind": "method", "sourceText": "/**\r\n * Method called whevener a player makes a successful move.\r\n * It can be used to update the player's points accordingly.\r\n *\r\n * @param player\r\n * \t\tThe player making a move.\r\n * @param direction\r\n * \t\tThe direction of the move.\r\n */\r\nvoid pacmanMoved(nl.tudelft.jpacman.level.Player player, nl.tudelft.jpacman.board.Direction direction);", "docComment": "Method called whevener a player makes a successful move.\r\nIt can be used to update the player's points accordingly.\r\n\r\n@param player\r\n\t\tThe player making a move.\r\n@param direction\r\n\t\tThe direction of the move.\r\n", "metaSrc": "source code", "description": "Calculates points for a player based on their movement in the game.", "returns": "void", "reason": "This method is part of the service layer as it orchestrates the calculation of points based on a player's movement, which is a core business operation.", "howToUse": "Call this method whenever a player moves in the game. Provide the player object and the direction they moved to calculate their new score.", "howItWorks": "The method uses the `player`'s current position and the `direction` of movement to determine if the player has eaten a pellet or collected a power-up, then updates the player's score accordingly.", "preConditions": ["A valid `Player` object is provided."], "postConditions": ["The player's score is updated based on their movement."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.occupants", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The units occupying this square, in order of appearance.\r\n */\r\nprivate final java.util.List<nl.tudelft.jpacman.board.Unit> occupants;", "visibility": "private", "simpleName": "occupants", "qualifiedName": "nl.tudelft.jpacman.board.Square.occupants", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).1", "labels": ["Variable"], "properties": {"simpleName": "ghosts", "qualifiedName": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "restart()", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "kind": "method", "sourceText": "/**\r\n * (Re)starts the current animation.\r\n */\r\npublic void restart() {\r\n    this.current = 0;\r\n    this.lastUpdate = java.lang.System.currentTimeMillis();\r\n    this.setAnimating(true);\r\n}", "docComment": "(Re)starts the current animation.\r\n", "metaSrc": "source code", "description": "Resets the animated sprite to its initial state by setting current frame to 0, last update time to current system time, and starting animation.", "returns": "", "reason": "The method resets the animated sprite's state to its initial conditions, preparing it for a new animation cycle.", "howToUse": "Call `restart()` on an instance of `AnimatedSprite` to reset its animation.", "howItWorks": "Sets current frame to 0, updates last update time to current system time, and calls `setAnimating(true)` to start the animation.", "assertions": {"preConditions": ["The animated sprite is in a valid state before calling `restart()`."], "postConditions": ["The animated sprite's current frame is set to 0.", "The last update time is updated to the current system time.", "The animation is started."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "split(int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic nl.tudelft.jpacman.sprite.Sprite split(int x, int y, int width, int height) {\r\n    this.update();\r\n    return this.currentSprite().split(x, y, width, height);\r\n}", "docComment": "", "metaSrc": "source code", "description": "Splits the current animated sprite into a smaller sprite based on given coordinates and dimensions.", "returns": "A new Sprite object representing the smaller sprite.", "reason": "This method provides a way to extract a portion of an animated sprite, which is useful for creating sub-sprites or handling specific regions within the main sprite.", "howToUse": "Call this method on an instance of AnimatedSprite with the desired coordinates and dimensions to split the current sprite into a smaller one.", "howItWorks": "The method first updates the animation state of the sprite using `update()`, then calls the `split()` method on the current sprite, passing the provided coordinates and dimensions.", "preConditions": ["An instance of AnimatedSprite is available.", "The coordinates and dimensions are within the bounds of the current sprite."], "postConditions": ["A new Sprite object representing the smaller portion of the original sprite is returned.", "If the region specified by the coordinates and dimensions is not within the current sprite, an EmptySprite may be returned instead."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "labels": ["Constructor"], "properties": {"visibility": "protected", "simpleName": "<init>(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "qualifiedName": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "kind": "constructor", "sourceText": "/**\r\n * Creates a new player with a score of 0 points.\r\n *\r\n * @param spriteMap\r\n * \t\tA map containing a sprite for this player for every direction.\r\n * @param deathAnimation\r\n * \t\tThe sprite to be shown when this player dies.\r\n */\r\nprotected Player(java.util.Map<nl.tudelft.jpacman.board.Direction, nl.tudelft.jpacman.sprite.Sprite> spriteMap, nl.tudelft.jpacman.sprite.AnimatedSprite deathAnimation) {\r\n    super();\r\n    this.score = 0;\r\n    this.alive = true;\r\n    this.sprites = spriteMap;\r\n    this.deathSprite = deathAnimation;\r\n    this.deathSprite.setAnimating(false);\r\n}", "docComment": "Creates a new player with a score of 0 points.\r\n\r\n@param spriteMap\r\n\t\tA map containing a sprite for this player for every direction.\r\n@param deathAnimation\r\n\t\tThe sprite to be shown when this player dies.\r\n", "metaSrc": "source code", "description": "Initializes a player with a sprite map and death animation, setting up their initial state.", "returns": "A newly created Player instance.", "reason": "This method initializes a new player object with its sprite map and death animation, setting up the player's initial state for gameplay.", "howToUse": "Create a new Player instance by providing a sprite map and a death animation. This setup is essential for the game to function correctly.", "howItWorks": "The method initializes the player's score, sets their alive status to true, assigns the provided sprite map and death animation, and stops the death animation from animating initially.", "assertions": {"preConditions": ["A valid Map<Direction, Sprite> is provided for the spriteMap.", "A valid AnimatedSprite is provided for the deathAnimation."], "postConditions": ["The player's score is set to 0.", "The player is marked as alive.", "The player's sprites are initialized with the provided sprite map.", "The player's death animation is set and stopped initially."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.buttons", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Map of buttons and their actions.\r\n */\r\nprivate final java.util.Map<java.lang.String, nl.tudelft.jpacman.ui.Action> buttons;", "visibility": "private", "simpleName": "buttons", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.buttons", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).1", "labels": ["Variable"], "properties": {"simpleName": "cause", "qualifiedName": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code"}}}, {"data": {"id": "short", "labels": ["Primitive"], "properties": {"simpleName": "short", "qualifiedName": "short", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder", "labels": ["Structure"], "properties": {"docComment": "Builder for the JPac-Man UI.\r\n\r\n@author Jeroen Roosen\r\n", "simpleName": "PacManUiBuilder", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder", "kind": "class", "metaSrc": "source code", "description": "The class is responsible for building and configuring the user interface (UI) for a Pac-Man game, including adding buttons and key mappings to control the game's flow.", "layer": "Presentation Layer", "roleStereotype": "Controller", "keywords": ["Pac-Man", "Game UI", "Button Management", "Key Mapping"], "dependencyProfile": "inbound"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game).0", "labels": ["Variable"], "properties": {"simpleName": "game", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The game to build the UI for."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "nextAiMove()", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "kind": "method", "sourceText": "/**\r\n * {@inheritDoc }\r\n *\r\n * <p>\r\n * Clyde has two basic AIs, one for when he's far from Pac-Man, and one for\r\n * when he is near to Pac-Man.\r\n * When Clyde is far away from Pac-Man (beyond eight grid spaces),\r\n * Clyde behaves very much like Blinky, trying to move to Pac-Man's exact\r\n * location. However, when Clyde gets within eight grid spaces of Pac-Man,\r\n * he automatically changes his behavior and runs away\r\n * </p>\r\n */\r\n@java.lang.Override\r\npublic java.util.Optional<nl.tudelft.jpacman.board.Direction> nextAiMove() {\r\n    assert this.hasSquare();\r\n    nl.tudelft.jpacman.board.Unit nearest = nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(nl.tudelft.jpacman.level.Player.class, this.getSquare());\r\n    if (nearest == null) {\r\n        return java.util.Optional.empty();\r\n    }\r\n    assert nearest.hasSquare();\r\n    nl.tudelft.jpacman.board.Square target = nearest.getSquare();\r\n    java.util.List<nl.tudelft.jpacman.board.Direction> path = nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(this.getSquare(), target, this);\r\n    if ((path != null) && (!path.isEmpty())) {\r\n        nl.tudelft.jpacman.board.Direction direction = path.get(0);\r\n        if (path.size() <= nl.tudelft.jpacman.npc.ghost.Clyde.SHYNESS) {\r\n            return java.util.Optional.of(direction.opposite());\r\n        }\r\n        return java.util.Optional.of(direction);\r\n    }\r\n    return java.util.Optional.empty();\r\n}", "docComment": "{@inheritDoc }\r\n\r\n<p>\r\nClyde has two basic AIs, one for when he's far from Pac-Man, and one for\r\nwhen he is near to Pac-Man. \r\nWhen Clyde is far away from Pac-Man (beyond eight grid spaces),\r\nClyde behaves very much like Blinky, trying to move to Pac-Man's exact\r\nlocation. However, when Clyde gets within eight grid spaces of Pac-Man,\r\nhe automatically changes his behavior and runs away\r\n</p>\r\n", "metaSrc": "source code", "description": "Determines Clyde's next move based on the nearest player and calculates the shortest path, considering shyness.", "returns": "java.util.Optional<nl.tudelft.jpacman.board.Direction>", "reason": "This method implements Clyde's AI behavior in the Pacman game, determining its next move based on the nearest player and calculating the shortest path while considering shyness.", "howToUse": "Call this method on an instance of Clyde to get the next direction it should move.", "howItWorks": "The method first finds the nearest player using the `findNearest` method. It then calculates the shortest path from Clyde's current square to the player's square using the `shortestPath` method. If the path is not null and not empty, it selects the first direction in the path. If the path size is less than or equal to Clyde's shyness level, it returns the opposite direction; otherwise, it returns the original direction.", "assertions": {"preConditions": ["this.hasSquare()", "nearest != null"], "postConditions": ["The returned Optional contains a Direction if a valid path exists and Clyde's shyness level is not exceeded."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).1", "labels": ["Variable"], "properties": {"simpleName": "frames", "qualifiedName": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The number of frames in the animation."}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "labels": ["Variable"], "properties": {"simpleName": "observer", "qualifiedName": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "parseMap(java.util.List)", "qualifiedName": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "kind": "method", "sourceText": "/**\r\n * Parses the list of strings into a 2-dimensional character array and\r\n * passes it on to {@link #parseMap(char[][])}.\r\n *\r\n * @param text\r\n * \t\tThe plain text, with every entry in the list being a equally\r\n * \t\tsized row of squares on the board and the first element being\r\n * \t\tthe top row.\r\n * @return The level as represented by the text.\r\n * @throws PacmanConfigurationException\r\n * \t\tIf text lines are not properly formatted.\r\n */\r\npublic nl.tudelft.jpacman.level.Level parseMap(java.util.List<java.lang.String> text) {\r\n    this.checkMapFormat(text);\r\n    int height = text.size();\r\n    int width = text.get(0).length();\r\n    char[][] map = new char[width][height];\r\n    for (int x = 0; x < width; x++) {\r\n        for (int y = 0; y < height; y++) {\r\n            map[x][y] = text.get(y).charAt(x);\r\n        }\r\n    }\r\n    return this.parseMap(map);\r\n}", "docComment": "Parses the list of strings into a 2-dimensional character array and\r\npasses it on to {@link #parseMap(char[][])}.\r\n\r\n@param text\r\n\t\tThe plain text, with every entry in the list being a equally\r\n\t\tsized row of squares on the board and the first element being\r\n\t\tthe top row.\r\n@return The level as represented by the text.\r\n@throws PacmanConfigurationException\r\n\t\tIf text lines are not properly formatted.\r\n", "metaSrc": "source code", "description": "Parses a text representation of a map into an actual game board for Pacman, initializing ghosts and start positions.", "returns": "An instance of nl.tudelft.jpacman.level.Level.", "reason": "The method parses a text representation of a map into an actual game board, initializing ghosts and start positions. It checks the format of the input text before parsing it.", "howToUse": "Call this method with a list of strings representing the rows of the map to parse it into a level.", "howItWorks": "The method first checks if the input text is valid for parsing as a map using the `checkMapFormat` method. It then creates a 2D array `map` where each element represents a square in the game board. The method iterates over each row and column of the input text, assigning the corresponding character to the `map` array. Finally, it calls the `parseMap` method with the `map` array as an argument to parse the map into a level.", "preConditions": ["The input text must be a valid representation of a map for Pacman."], "postConditions": ["The returned level object represents the parsed game board."], "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "labels": ["Variable"], "properties": {"simpleName": "ghost", "qualifiedName": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The ghost causing the player to die."}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "labels": ["Variable"], "properties": {"simpleName": "player", "qualifiedName": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The player who consumed the pellet."}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "labels": ["Operation"], "properties": {"visibility": "protected", "simpleName": "getLevelFactory()", "qualifiedName": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "kind": "method", "sourceText": "/**\r\n *\r\n * @return A new factory using the sprites from {@link #getSpriteStore()}\r\nand the ghosts from {@link #getGhostFactory()}.\r\n */\r\nprotected nl.tudelft.jpacman.level.LevelFactory getLevelFactory() {\r\n    return new nl.tudelft.jpacman.level.LevelFactory(this.getSpriteStore(), this.getGhostFactory(), this.loadPointCalculator());\r\n}", "docComment": "\r\n@return A new factory using the sprites from {@link #getSpriteStore()}\r\nand the ghosts from {@link #getGhostFactory()}.\r\n", "metaSrc": "source code", "description": "Returns a LevelFactory instance initialized with the current SpriteStore, GhostFactory, and PointCalculator.", "returns": "A new LevelFactory instance", "reason": "The method is part of the Service Layer as it orchestrates the creation of a LevelFactory which is used to generate game levels in the Pacman game.", "howToUse": "Call this method from within another class that needs to create a LevelFactory for use in generating game levels.", "howItWorks": "The method creates a new instance of LevelFactory by passing the current SpriteStore, GhostFactory, and PointCalculator as arguments. These are used to initialize the factory which will be responsible for creating different types of game entities such as ghosts and points.", "assertions": {"preConditions": ["The SpriteStore, GhostFactory, and PointCalculator must be properly initialized before calling this method."], "postConditions": ["A new LevelFactory instance is returned."]}, "layer": "Service Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.animating", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * Whether this sprite is currently animating or not.\r\n */\r\nprivate boolean animating;", "visibility": "private", "simpleName": "animating", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.animating", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "withDefaultButtons()", "qualifiedName": "nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "kind": "method", "sourceText": "/**\r\n * Adds a start and stop button to the UI. The actual actions for these\r\n * buttons will be added upon building the UI.\r\n *\r\n * @return The builder.\r\n */\r\npublic nl.tudelft.jpacman.ui.PacManUiBuilder withDefaultButtons() {\r\n    this.defaultButtons = true;\r\n    this.buttons.put(nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION, null);\r\n    this.buttons.put(nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION, null);\r\n    return this;\r\n}", "docComment": "Adds a start and stop button to the UI. The actual actions for these\r\nbuttons will be added upon building the UI.\r\n\r\n@return The builder.\r\n", "metaSrc": "source code", "description": "Sets default buttons for the PacMan UI builder.", "returns": "The updated PacManUiBuilder instance.", "reason": "This method configures the default buttons for the PacMan user interface, providing a simple way to set up basic controls without additional configuration.", "howToUse": "Call this method on an instance of PacManUiBuilder to enable default start and stop buttons in the UI.", "howItWorks": "The method sets two entries in the 'buttons' map: one for the start button with a null value, and another for the stop button also with a null value. It then returns the updated builder instance.", "assertions": {"preConditions": ["An instance of PacManUiBuilder is created."], "postConditions": ["The 'defaultButtons' flag is set to true.", "Two entries are added to the 'buttons' map."]}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "labels": ["Variable"], "properties": {"simpleName": "collidee", "qualifiedName": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The unit that is being collided with."}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "qualifiedName": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "kind": "method", "sourceText": "/**\r\n * Creates a new level from the provided data.\r\n *\r\n * @param board\r\n * \t\tThe board with all ghosts and pellets occupying their squares.\r\n * @param ghosts\r\n * \t\tA list of all ghosts on the board.\r\n * @param startPositions\r\n * \t\tA list of squares from which players may start the game.\r\n * @return A new level for the board.\r\n */\r\npublic nl.tudelft.jpacman.level.Level createLevel(nl.tudelft.jpacman.board.Board board, java.util.List<nl.tudelft.jpacman.npc.Ghost> ghosts, java.util.List<nl.tudelft.jpacman.board.Square> startPositions) {\r\n    // We'll adopt the simple collision map for now.\r\n    nl.tudelft.jpacman.level.CollisionMap collisionMap = new nl.tudelft.jpacman.level.PlayerCollisions(this.pointCalculator);\r\n    return new nl.tudelft.jpacman.level.Level(board, ghosts, startPositions, collisionMap);\r\n}", "docComment": "Creates a new level from the provided data.\r\n\r\n@param board\r\n\t\tThe board with all ghosts and pellets occupying their squares.\r\n@param ghosts\r\n\t\tA list of all ghosts on the board.\r\n@param startPositions\r\n\t\tA list of squares from which players may start the game.\r\n@return A new level for the board.\r\n", "metaSrc": "source code", "description": "Creates a new level for the Pacman game by initializing a collision map and returning a Level instance.", "returns": "An instance of nl.tudelft.jpacman.level.Level.", "reason": "This method is part of the Domain Layer as it handles the creation of a game level, which involves initializing game components like the board, ghosts, and player positions.", "howToUse": "To use this method, you need to provide a Board instance, a list of Ghost instances, and a list of Square instances representing starting positions. The method will return a Level object that can be used to start playing the game.", "howItWorks": "The method creates a new CollisionMap using the PointCalculator from the current level factory. It then uses this collision map along with the provided board, ghosts, and start positions to create a new Level instance.", "assertions": {"preConditions": ["The provided Board instance must be valid and not null.", "The List of Ghost instances must contain at least one ghost.", "The List of Square instances must contain at least two elements (one for the player's starting position and another for a non-ghost square)."], "postConditions": ["The returned Level instance should have all the provided components initialized correctly."]}, "layer": "Domain Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "labels": ["Operation"], "properties": {"visibility": "private", "simpleName": "render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "qualifiedName": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "kind": "method", "sourceText": "/**\r\n * Renders the board on the given graphics context to the given dimensions.\r\n *\r\n * @param board\r\n * \t\tThe board to render.\r\n * @param graphics\r\n * \t\tThe graphics context to draw on.\r\n * @param window\r\n * \t\tThe dimensions to scale the rendered board to.\r\n */\r\nprivate void render(nl.tudelft.jpacman.board.Board board, java.awt.Graphics graphics, java.awt.Dimension window) {\r\n    int cellW = window.width / board.getWidth();\r\n    int cellH = window.height / board.getHeight();\r\n    graphics.setColor(nl.tudelft.jpacman.ui.BoardPanel.BACKGROUND_COLOR);\r\n    graphics.fillRect(0, 0, window.width, window.height);\r\n    for (int y = 0; y < board.getHeight(); y++) {\r\n        for (int x = 0; x < board.getWidth(); x++) {\r\n            int cellX = x * cellW;\r\n            int cellY = y * cellH;\r\n            nl.tudelft.jpacman.board.Square square = board.squareAt(x, y);\r\n            this.render(square, graphics, cellX, cellY, cellW, cellH);\r\n        }\r\n    }\r\n}", "docComment": "Renders the board on the given graphics context to the given dimensions.\r\n\r\n@param board\r\n\t\tThe board to render.\r\n@param graphics\r\n\t\tThe graphics context to draw on.\r\n@param window\r\n\t\tThe dimensions to scale the rendered board to.\r\n", "metaSrc": "source code", "description": "Renders the Pacman game board by drawing each square and its contents.", "returns": "void", "reason": "This method is responsible for rendering the game board, which is a core functionality of the Pacman game.", "howToUse": "Call this method with the current state of the game board and the graphics context to draw on. The window size should be set appropriately to match the dimensions of the board.", "howItWorks": "The method calculates the cell width and height based on the window size and the board dimensions. It then fills the background color, iterates over each square on the board, and calls the `render` method for each square to draw its sprite and units.", "assertions": {"preConditions": ["The board is not null", "The graphics context is not null", "The window size is valid"], "postConditions": ["The board is rendered on the graphics context within the specified window dimensions"]}, "layer": "Presentation Layer"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).1", "labels": ["Variable"], "properties": {"simpleName": "start", "qualifiedName": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).1", "kind": "parameter", "parameterPosition": 1, "metaSrc": "source code", "description": "The starting square from which to begin following the path."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS", "labels": ["Variable"], "properties": {"sourceText": "/**\r\n * The sprite files are vertically stacked series for each direction, this\r\n * array denotes the order.\r\n */\r\nprivate static final nl.tudelft.jpacman.board.Direction[] DIRECTIONS = new nl.tudelft.jpacman.board.Direction[]{ nl.tudelft.jpacman.board.Direction.NORTH, nl.tudelft.jpacman.board.Direction.EAST, nl.tudelft.jpacman.board.Direction.SOUTH, nl.tudelft.jpacman.board.Direction.WEST };", "visibility": "private", "simpleName": "DIRECTIONS", "qualifiedName": "nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS", "kind": "field", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit).0", "labels": ["Variable"], "properties": {"simpleName": "killer", "qualifiedName": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit).0", "kind": "parameter", "parameterPosition": 0, "metaSrc": "source code", "description": "The unit that will be set as the killer."}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "labels": ["Operation"], "properties": {"visibility": "public", "simpleName": "draw(java.awt.Graphics,int,int,int,int)", "qualifiedName": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "kind": "method", "sourceText": "@java.lang.Override\r\npublic void draw(java.awt.Graphics graphics, int x, int y, int width, int height) {\r\n    this.update();\r\n    this.currentSprite().draw(graphics, x, y, width, height);\r\n}", "docComment": "", "metaSrc": "source code", "description": "Updates the animation state and draws the current sprite on the given graphics context at specified coordinates and dimensions.", "returns": "void", "reason": "This method is part of the Presentation Layer as it manages the user interface by updating and drawing the animated sprite.", "howToUse": "Call this method with a Graphics object, x, y, width, and height to update and draw the current sprite on the screen.", "howItWorks": "The method first updates the animation state using the `update()` method. Then, it draws the current sprite using the `draw(java.awt.Graphics,int,int,int,int)` method of the current sprite.", "preConditions": ["A Graphics object is provided to draw the sprite.", "Valid integer values are provided for x, y, width, and height."], "postConditions": ["The animation state is updated based on the current system time.", "The current sprite is drawn on the specified graphics context at the given coordinates and dimensions."], "layer": "Presentation Layer"}}}], "edges": [{"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)-returnType-nl.tudelft.jpacman.npc.ghost.Inky", "source": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Inky", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int)-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)-returnType-boolean", "source": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.getSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall.getSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List)-returnType-nl.tudelft.jpacman.ui.ScorePanel", "source": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List)", "target": "nl.tudelft.jpacman.ui.ScorePanel", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)-returnType-nl.tudelft.jpacman.board.BoardFactory$Wall", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.getDeltaY()-returnType-int", "source": "nl.tudelft.jpacman.board.Direction.getDeltaY()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)-returnType-nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.getSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.npc.Ghost.getSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.getPlayers()-returnType-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.game.SinglePlayerGame.getPlayers()", "target": "nl.tudelft.jpacman.level.Player", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGame()-returnType-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.Launcher.getGame()", "target": "nl.tudelft.jpacman.game.Game", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)-returnType-nl.tudelft.jpacman.level.LevelFactory", "source": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.LevelFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()-returnType-boolean", "source": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()-returnType-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)-returnType-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.getHeight()-returnType-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.getHeight()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getSquare()-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Unit.getSquare()", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)-returnType-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.Game", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.getWidth()-returnType-int", "source": "nl.tudelft.jpacman.sprite.Sprite.getWidth()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)-returnType-java.lang.String", "source": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "target": "java.lang.String", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)-returnType-nl.tudelft.jpacman.game.GameFactory", "source": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)", "target": "nl.tudelft.jpacman.game.GameFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.getLevel()-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.game.SinglePlayerGame.getLevel()", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-returnType-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getMapParser()-returnType-nl.tudelft.jpacman.level.MapParser", "source": "nl.tudelft.jpacman.Launcher.getMapParser()", "target": "nl.tudelft.jpacman.level.MapParser", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)-returnType-boolean", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getDirection()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Unit.getDirection()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)-returnType-nl.tudelft.jpacman.board.BoardFactory", "source": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "target": "nl.tudelft.jpacman.board.BoardFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGhostFactory()-returnType-nl.tudelft.jpacman.npc.ghost.GhostFactory", "source": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)-returnType-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)-returnType-nl.tudelft.jpacman.level.PlayerFactory", "source": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "target": "nl.tudelft.jpacman.level.PlayerFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()-returnType-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)-returnType-boolean", "source": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.getSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.level.Pellet.getSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.getPlayerFactory()-returnType-nl.tudelft.jpacman.level.PlayerFactory", "source": "nl.tudelft.jpacman.game.GameFactory.getPlayerFactory()", "target": "nl.tudelft.jpacman.level.PlayerFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)-returnType-nl.tudelft.jpacman.Launcher", "source": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)", "target": "nl.tudelft.jpacman.Launcher", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)-returnType-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getBoardFactory()-returnType-nl.tudelft.jpacman.board.BoardFactory", "source": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "target": "nl.tudelft.jpacman.board.BoardFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)-returnType-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)-returnType-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.getWidth()-returnType-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.getWidth()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)-returnType-nl.tudelft.jpacman.ui.PacKeyListener", "source": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)", "target": "nl.tudelft.jpacman.ui.PacKeyListener", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.loadPointCalculator()-returnType-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.getBoardCreator()-returnType-nl.tudelft.jpacman.board.BoardFactory", "source": "nl.tudelft.jpacman.level.MapParser.getBoardCreator()", "target": "nl.tudelft.jpacman.board.BoardFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)-returnType-nl.tudelft.jpacman.ui.PacManUI", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.PacManUI", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-returnType-nl.tudelft.jpacman.level.CollisionInteractionMap", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-returnType-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite()-returnType-nl.tudelft.jpacman.sprite.EmptySprite", "source": "nl.tudelft.jpacman.sprite.EmptySprite()", "target": "nl.tudelft.jpacman.sprite.EmptySprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getScore()-returnType-int", "source": "nl.tudelft.jpacman.level.Player.getScore()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-returnType-nl.tudelft.jpacman.ui.PacManUI", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacManUI", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-returnType-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.opposite()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Direction.opposite()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()-returnType-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "target": "nl.tudelft.jpacman.level.Player", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getKiller()-returnType-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.Player.getKiller()", "target": "nl.tudelft.jpacman.board.Unit", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder()-returnType-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder()", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.getValue()-returnType-int", "source": "nl.tudelft.jpacman.level.Pellet.getValue()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.invariant()-returnType-boolean", "source": "nl.tudelft.jpacman.board.Unit.invariant()", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-returnType-nl.tudelft.jpacman.game.SinglePlayerGame", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.SinglePlayerGame", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)-returnType-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)-returnType-nl.tudelft.jpacman.level.Level$NpcMoveTask", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)-returnType-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.ui.Action", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap()-returnType-nl.tudelft.jpacman.level.CollisionInteractionMap", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap()", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.nextAiMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)-returnType-nl.tudelft.jpacman.level.PlayerCollisions", "source": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.PlayerCollisions", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-returnType-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Board", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.Square.getSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)-returnType-nl.tudelft.jpacman.board.BoardFactory$Ground", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)-returnType-nl.tudelft.jpacman.ui.BoardPanel", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.BoardPanel", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()-returnType-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getPlayerFactory()-returnType-nl.tudelft.jpacman.level.PlayerFactory", "source": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "target": "nl.tudelft.jpacman.level.PlayerFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore()-returnType-nl.tudelft.jpacman.sprite.SpriteStore", "source": "nl.tudelft.jpacman.sprite.SpriteStore()", "target": "nl.tudelft.jpacman.sprite.SpriteStore", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.getHeight()-returnType-int", "source": "nl.tudelft.jpacman.sprite.Sprite.getHeight()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()-returnType-java.lang.String", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "target": "java.lang.String", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)-returnType-boolean", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-returnType-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.Game", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)-returnType-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int)-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Direction(int,int)", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)-returnType-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.level.Player", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor()-returnType-nl.tudelft.jpacman.npc.ghost.GhostColor", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor()", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)-returnType-boolean", "source": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)-returnType-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.getLevel()-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.game.Game.getLevel()", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader()-returnType-nl.tudelft.jpacman.points.PointCalculatorLoader", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader()", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSpriteStore()-returnType-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.getDeltaX()-returnType-int", "source": "nl.tudelft.jpacman.board.Direction.getDeltaX()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.getPlayers()-returnType-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.game.Game.getPlayers()", "target": "nl.tudelft.jpacman.level.Player", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createPellet()-returnType-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "target": "nl.tudelft.jpacman.level.Pellet", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createWall()-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()-returnType-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.getHeight()-returnType-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.getHeight()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.getHeight()-returnType-int", "source": "nl.tudelft.jpacman.board.Board.getHeight()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites()-returnType-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.sprite.PacManSprites()", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)-returnType-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.getSprites()-returnType-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelMap()-returnType-java.lang.String", "source": "nl.tudelft.jpacman.Launcher.getLevelMap()", "target": "java.lang.String", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)-returnType-nl.tudelft.jpacman.npc.ghost.Clyde", "source": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Clyde", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()-returnType-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)-returnType-nl.tudelft.jpacman.level.MapParser", "source": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "target": "nl.tudelft.jpacman.level.MapParser", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.isAlive()-returnType-boolean", "source": "nl.tudelft.jpacman.level.Player.isAlive()", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher()-returnType-nl.tudelft.jpacman.Launcher", "source": "nl.tudelft.jpacman.Launcher()", "target": "nl.tudelft.jpacman.Launcher", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGameFactory()-returnType-nl.tudelft.jpacman.game.GameFactory", "source": "nl.tudelft.jpacman.Launcher.getGameFactory()", "target": "nl.tudelft.jpacman.game.GameFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator()-returnType-nl.tudelft.jpacman.points.DefaultPointCalculator", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator()", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)-returnType-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "target": "nl.tudelft.jpacman.level.Player", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getParent()-returnType-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getParent()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.getWidth()-returnType-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.getWidth()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.invariant()-returnType-boolean", "source": "nl.tudelft.jpacman.board.Board.invariant()", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.level.Player.getSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.nextAiMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.nextAiMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit()-returnType-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.Unit()", "target": "nl.tudelft.jpacman.board.Unit", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeLevel()-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.Launcher.makeLevel()", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.nextMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.Ghost.nextMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)-returnType-nl.tudelft.jpacman.npc.ghost.GhostFactory", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.getSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground.getSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelFactory()-returnType-nl.tudelft.jpacman.level.LevelFactory", "source": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "target": "nl.tudelft.jpacman.level.LevelFactory", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)-returnType-nl.tudelft.jpacman.ui.ButtonPanel", "source": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "target": "nl.tudelft.jpacman.ui.ButtonPanel", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-returnType-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()-returnType-int", "source": "nl.tudelft.jpacman.level.Level.remainingPellets()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square()-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Square()", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getOccupants()-returnType-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.Square.getOccupants()", "target": "nl.tudelft.jpacman.board.Unit", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation()-returnType-nl.tudelft.jpacman.npc.ghost.Navigation", "source": "nl.tudelft.jpacman.npc.ghost.Navigation()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)-returnType-nl.tudelft.jpacman.npc.ghost.Blinky", "source": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Blinky", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()-returnType-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)-returnType-nl.tudelft.jpacman.npc.ghost.Pinky", "source": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Pinky", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)-returnType-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.level.Pellet", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)-returnType-nl.tudelft.jpacman.sprite.ImageSprite", "source": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)", "target": "nl.tudelft.jpacman.sprite.ImageSprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)-returnType-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Unit", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.isInProgress()-returnType-boolean", "source": "nl.tudelft.jpacman.game.Game.isInProgress()", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeGame()-returnType-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.Launcher.makeGame()", "target": "nl.tudelft.jpacman.game.Game", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()-returnType-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createGround()-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])-returnType-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Board", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)-returnType-boolean", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.randomMove()-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.isInProgress()-returnType-boolean", "source": "nl.tudelft.jpacman.level.Level.isInProgress()", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.getBoard()-returnType-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.level.Level.getBoard()", "target": "nl.tudelft.jpacman.board.Board", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()-returnType-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()-returnType-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.Unit.getSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-returnType-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.board.Direction", "label": "returnType", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.getInterval()-returnType-long", "source": "nl.tudelft.jpacman.npc.Ghost.getInterval()", "target": "long", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.getWidth()-returnType-int", "source": "nl.tudelft.jpacman.board.Board.getWidth()", "target": "int", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)-returnType-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)-returnType-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "target": "nl.tudelft.jpacman.level.Level", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()-returnType-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.hasSquare()-returnType-boolean", "source": "nl.tudelft.jpacman.board.Unit.hasSquare()", "target": "boolean", "label": "returnType", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall-hasScript-nl.tudelft.jpacman.board.BoardFactory$Wall.getSprite()", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall.getSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener-hasScript-nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)", "source": "nl.tudelft.jpacman.ui.PacKeyListener", "target": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory-hasScript-nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory-hasScript-nl.tudelft.jpacman.board.BoardFactory.createGround()", "source": "nl.tudelft.jpacman.board.BoardFactory", "target": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory-hasScript-nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "source": "nl.tudelft.jpacman.level.PlayerFactory", "target": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor-hasScript-nl.tudelft.jpacman.npc.ghost.GhostColor()", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.isInProgress()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.isInProgress()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator-hasScript-nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "source": "nl.tudelft.jpacman.points.PointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground-hasScript-nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player.getSprite()", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.getSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getGhostFactory()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.getLevel()", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.getLevel()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasScript-nl.tudelft.jpacman.sprite.ImageSprite.getWidth()", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite.getWidth()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player.getScore()", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.getScore()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.getBoard()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.getBoard()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator-hasScript-nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.points.PointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground-hasScript-nl.tudelft.jpacman.board.BoardFactory$Ground.getSprite()", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground.getSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall-hasScript-nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.getDirection()", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.getDirection()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet-hasScript-nl.tudelft.jpacman.level.Pellet.getValue()", "source": "nl.tudelft.jpacman.level.Pellet", "target": "nl.tudelft.jpacman.level.Pellet.getValue()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board-hasScript-nl.tudelft.jpacman.board.Board.getWidth()", "source": "nl.tudelft.jpacman.board.Board", "target": "nl.tudelft.jpacman.board.Board.getWidth()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.levelWon()", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.levelWon()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getMapParser()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getMapParser()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky-hasScript-nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "source": "nl.tudelft.jpacman.npc.ghost.Inky", "target": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasScript-nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap-hasScript-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite-hasScript-nl.tudelft.jpacman.sprite.EmptySprite.getWidth()", "source": "nl.tudelft.jpacman.sprite.EmptySprite", "target": "nl.tudelft.jpacman.sprite.EmptySprite.getWidth()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator-hasScript-nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.points.PointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.makeLevel()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.makeLevel()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasScript-nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$LevelObserver-hasScript-nl.tudelft.jpacman.level.Level$LevelObserver.levelWon()", "source": "nl.tudelft.jpacman.level.Level$LevelObserver", "target": "nl.tudelft.jpacman.level.Level$LevelObserver.levelWon()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.levelLost()", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.levelLost()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator-hasScript-nl.tudelft.jpacman.points.DefaultPointCalculator()", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasScript-nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getParent()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getParent()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder()", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore-hasScript-nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "source": "nl.tudelft.jpacman.sprite.SpriteStore", "target": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI-hasScript-nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "source": "nl.tudelft.jpacman.ui.PacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.start()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.start()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasScript-nl.tudelft.jpacman.npc.Ghost.getSprite()", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.getSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getLevelMap()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getLevelMap()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasScript-nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasScript-nl.tudelft.jpacman.board.Direction.opposite()", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.opposite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite-hasScript-nl.tudelft.jpacman.sprite.EmptySprite()", "source": "nl.tudelft.jpacman.sprite.EmptySprite", "target": "nl.tudelft.jpacman.sprite.EmptySprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator-hasScript-nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory-hasScript-nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore-hasScript-nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.SpriteStore", "target": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.stopNPCs()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.stopNPCs()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-hasScript-nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory-hasScript-nl.tudelft.jpacman.game.GameFactory.getPlayerFactory()", "source": "nl.tudelft.jpacman.game.GameFactory", "target": "nl.tudelft.jpacman.game.GameFactory.getPlayerFactory()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel-hasScript-nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "source": "nl.tudelft.jpacman.ui.ButtonPanel", "target": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask-hasScript-nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory-hasScript-nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)", "source": "nl.tudelft.jpacman.game.GameFactory", "target": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory-hasScript-nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory-hasScript-nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "source": "nl.tudelft.jpacman.board.BoardFactory", "target": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasScript-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.getOccupants()", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.getOccupants()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory-hasScript-nl.tudelft.jpacman.board.BoardFactory.createWall()", "source": "nl.tudelft.jpacman.board.BoardFactory", "target": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasScript-nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI-hasScript-nl.tudelft.jpacman.ui.PacManUI.start()", "source": "nl.tudelft.jpacman.ui.PacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI.start()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI-hasScript-nl.tudelft.jpacman.ui.PacManUI.nextFrame()", "source": "nl.tudelft.jpacman.ui.PacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI.nextFrame()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.getSprite()", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.getSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getSpriteStore()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap-hasScript-nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.CollisionMap", "target": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasScript-nl.tudelft.jpacman.level.LevelFactory.createPellet()", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.stop()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.stop()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player.addPoints(int)", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.addPoints(int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite-hasScript-nl.tudelft.jpacman.sprite.Sprite.getHeight()", "source": "nl.tudelft.jpacman.sprite.Sprite", "target": "nl.tudelft.jpacman.sprite.Sprite.getHeight()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board-hasScript-nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "source": "nl.tudelft.jpacman.board.Board", "target": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener-hasScript-nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent)", "source": "nl.tudelft.jpacman.ui.PacKeyListener", "target": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky-hasScript-nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Inky", "target": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board-hasScript-nl.tudelft.jpacman.board.Board.getHeight()", "source": "nl.tudelft.jpacman.board.Board", "target": "nl.tudelft.jpacman.board.Board.getHeight()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.invariant()", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.invariant()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator-hasScript-nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory-hasScript-nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasScript-nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.start()", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.start()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasScript-nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame-hasScript-nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.game.SinglePlayerGame", "target": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasScript-nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasScript-nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit()", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory-hasScript-nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "source": "nl.tudelft.jpacman.level.PlayerFactory", "target": "nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasScript-nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasScript-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory-hasScript-nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.game.GameFactory", "target": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasScript-nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter-hasScript-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "source": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite-hasScript-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.Sprite", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square()", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.getSprite()", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.getSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getGame()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getGame()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame-hasScript-nl.tudelft.jpacman.game.SinglePlayerGame.getPlayers()", "source": "nl.tudelft.jpacman.game.SinglePlayerGame", "target": "nl.tudelft.jpacman.game.SinglePlayerGame.getPlayers()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader-hasScript-nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getBoardFactory()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasScript-nl.tudelft.jpacman.npc.Ghost.nextMove()", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.nextMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator-hasScript-nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.getBoardCreator()", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.getBoardCreator()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasScript-nl.tudelft.jpacman.board.Direction.getDeltaY()", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.getDeltaY()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall-hasScript-nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky-hasScript-nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "source": "nl.tudelft.jpacman.npc.ghost.Pinky", "target": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader-hasScript-nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky-hasScript-nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "source": "nl.tudelft.jpacman.npc.ghost.Blinky", "target": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost-hasScript-nl.tudelft.jpacman.level.LevelFactory$RandomGhost.nextAiMove()", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.nextAiMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getLevelFactory()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap()", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde-hasScript-nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "source": "nl.tudelft.jpacman.npc.ghost.Clyde", "target": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasScript-nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener-hasScript-nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent)", "source": "nl.tudelft.jpacman.ui.PacKeyListener", "target": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet-hasScript-nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "source": "nl.tudelft.jpacman.level.Pellet", "target": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board-hasScript-nl.tudelft.jpacman.board.Board.invariant()", "source": "nl.tudelft.jpacman.board.Board", "target": "nl.tudelft.jpacman.board.Board.invariant()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.launch()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.launch()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost-hasScript-nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler-hasScript-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky-hasScript-nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "source": "nl.tudelft.jpacman.npc.ghost.Inky", "target": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player.setAlive(boolean)", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite-hasScript-nl.tudelft.jpacman.sprite.Sprite.getWidth()", "source": "nl.tudelft.jpacman.sprite.Sprite", "target": "nl.tudelft.jpacman.sprite.Sprite.getWidth()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener-hasScript-nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)", "source": "nl.tudelft.jpacman.ui.PacKeyListener", "target": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore-hasScript-nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.SpriteStore", "target": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-hasScript-nl.tudelft.jpacman.ui.ScorePanel.refresh()", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel.refresh()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasScript-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite-hasScript-nl.tudelft.jpacman.sprite.EmptySprite.getHeight()", "source": "nl.tudelft.jpacman.sprite.EmptySprite", "target": "nl.tudelft.jpacman.sprite.EmptySprite.getHeight()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasScript-nl.tudelft.jpacman.npc.Ghost.randomMove()", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.makeGame()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.makeGame()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.updateObservers()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.updateObservers()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasScript-nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet-hasScript-nl.tudelft.jpacman.level.Pellet.getSprite()", "source": "nl.tudelft.jpacman.level.Pellet", "target": "nl.tudelft.jpacman.level.Pellet.getSprite()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasScript-nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground-hasScript-nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.stop()", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.stop()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.Action-hasScript-nl.tudelft.jpacman.ui.Action.doAction()", "source": "nl.tudelft.jpacman.ui.Action", "target": "nl.tudelft.jpacman.ui.Action.doAction()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite-hasScript-nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.EmptySprite", "target": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasScript-nl.tudelft.jpacman.sprite.ImageSprite.getHeight()", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite.getHeight()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException-hasScript-nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)", "source": "nl.tudelft.jpacman.PacmanConfigurationException", "target": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getGameFactory()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getGameFactory()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader-hasScript-nl.tudelft.jpacman.points.PointCalculatorLoader()", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.loadPointCalculator()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame-hasScript-nl.tudelft.jpacman.game.SinglePlayerGame.getLevel()", "source": "nl.tudelft.jpacman.game.SinglePlayerGame", "target": "nl.tudelft.jpacman.game.SinglePlayerGame.getLevel()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.getPlayers()", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.getPlayers()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky-hasScript-nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "source": "nl.tudelft.jpacman.npc.ghost.Blinky", "target": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasScript-nl.tudelft.jpacman.level.LevelFactory.createGhost()", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player.getKiller()", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.getKiller()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader-hasScript-nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky-hasScript-nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "source": "nl.tudelft.jpacman.npc.ghost.Pinky", "target": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation", "target": "nl.tudelft.jpacman.npc.ghost.Navigation()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasScript-nl.tudelft.jpacman.level.Player.isAlive()", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.isAlive()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite-hasScript-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.Sprite", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.getPlayerFactory()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasScript-nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasScript-nl.tudelft.jpacman.board.Direction.getDeltaX()", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.getDeltaX()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.remainingPellets()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.remainingPellets()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasScript-nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore-hasScript-nl.tudelft.jpacman.sprite.SpriteStore()", "source": "nl.tudelft.jpacman.sprite.SpriteStore", "target": "nl.tudelft.jpacman.sprite.SpriteStore()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory-hasScript-nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasScript-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory-hasScript-nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "source": "nl.tudelft.jpacman.board.BoardFactory", "target": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasScript-nl.tudelft.jpacman.sprite.PacManSprites()", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap-hasScript-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasScript-nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-hasScript-nl.tudelft.jpacman.ui.ScorePanel(java.util.List)", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasScript-nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasScript-nl.tudelft.jpacman.npc.Ghost.getInterval()", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.getInterval()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory-hasScript-nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "source": "nl.tudelft.jpacman.level.PlayerFactory", "target": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasScript-nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board-hasScript-nl.tudelft.jpacman.board.Board.squareAt(int,int)", "source": "nl.tudelft.jpacman.board.Board", "target": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasScript-nl.tudelft.jpacman.Launcher.dispose()", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.dispose()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board-hasScript-nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "source": "nl.tudelft.jpacman.board.Board", "target": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask-hasScript-nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasScript-nl.tudelft.jpacman.board.Unit.leaveSquare()", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException-hasScript-nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)", "source": "nl.tudelft.jpacman.PacmanConfigurationException", "target": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasScript-nl.tudelft.jpacman.game.Game.isInProgress()", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.isInProgress()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap-hasScript-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasScript-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasScript-nl.tudelft.jpacman.level.Level.startNPCs()", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.startNPCs()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite-hasScript-nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.EmptySprite", "target": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasScript-nl.tudelft.jpacman.board.Direction(int,int)", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction(int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde-hasScript-nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "source": "nl.tudelft.jpacman.npc.ghost.Clyde", "target": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$LevelObserver-hasScript-nl.tudelft.jpacman.level.Level$LevelObserver.levelLost()", "source": "nl.tudelft.jpacman.level.Level$LevelObserver", "target": "nl.tudelft.jpacman.level.Level$LevelObserver.levelLost()", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasScript-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "label": "hasScript", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)-hasParameter-nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0", "source": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).2", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).1", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)-hasParameter-nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "target": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)-hasParameter-nl.tudelft.jpacman.board.Board.withinBorders(int,int).0", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "target": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).0", "source": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).0", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).2", "source": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).0", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).1", "source": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).1", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)-hasParameter-nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory).0", "source": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory)", "target": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-hasParameter-nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).3", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).4", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).0", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int)-hasParameter-nl.tudelft.jpacman.board.Board.squareAt(int,int).1", "source": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "target": "nl.tudelft.jpacman.board.Board.squareAt(int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).5", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).5", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).1", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).0", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)-hasParameter-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player).0", "source": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-hasParameter-nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).0", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).1", "source": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).5", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).5", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-hasParameter-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).1", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).1", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).0", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-hasParameter-nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).1", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)-hasParameter-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).2", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square).0", "source": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game).0", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image).0", "source": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image)", "target": "nl.tudelft.jpacman.sprite.ImageSprite(java.awt.Image).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List).0", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).1", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)-hasParameter-nl.tudelft.jpacman.board.Board.withinBorders(int,int).1", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "target": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game).0", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)-hasParameter-nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game).0", "source": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square).0", "source": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).2", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).0", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)-hasParameter-nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "source": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "target": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).3", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).4", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).1", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).2", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)-hasParameter-nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream).0", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)-hasParameter-nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int)-hasParameter-nl.tudelft.jpacman.board.Board.squareAt(int,int).0", "source": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "target": "nl.tudelft.jpacman.board.Board.squareAt(int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)-hasParameter-nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String).0", "source": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)-hasParameter-nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent).0", "source": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)", "target": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-hasParameter-nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).3", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).1", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver)-hasParameter-nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "source": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "target": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).1", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean).0", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)-hasParameter-nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0", "source": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "target": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-hasParameter-nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "source": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])-hasParameter-nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][]).0", "source": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][]).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "source": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-hasParameter-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).2", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)-hasParameter-nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).3", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "target": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics).0", "source": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "target": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).4", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator).0", "source": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).0", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List)-hasParameter-nl.tudelft.jpacman.ui.ScorePanel(java.util.List).0", "source": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List)", "target": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)-hasParameter-nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-hasParameter-nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).2", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-hasParameter-nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).0", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).2", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setAlive(boolean)-hasParameter-nl.tudelft.jpacman.level.Player.setAlive(boolean).0", "source": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "target": "nl.tudelft.jpacman.level.Player.setAlive(boolean).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)-hasParameter-nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player).0", "source": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "target": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)-hasParameter-nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String).0", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).0", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).3", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).0", "source": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).2", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).3", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "source": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)-hasParameter-nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).0", "source": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)", "target": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)-hasParameter-nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).1", "source": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).2", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-hasParameter-nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "source": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).2", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).1", "source": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-hasParameter-nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][]).0", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][]).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).0", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)-hasParameter-nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).1", "source": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "target": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)-hasParameter-nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder).0", "source": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "target": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent)-hasParameter-nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent).0", "source": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent)", "target": "nl.tudelft.jpacman.ui.PacKeyListener.keyReleased(java.awt.event.KeyEvent).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).0", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)-hasParameter-nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite).0", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-hasParameter-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).4", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)-hasParameter-nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).1", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "target": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])-hasParameter-nl.tudelft.jpacman.Launcher.main(java.lang.String[]).0", "source": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "target": "nl.tudelft.jpacman.Launcher.main(java.lang.String[]).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-hasParameter-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).3", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)-hasParameter-nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).2", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "target": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)-hasParameter-nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite).0", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)-hasParameter-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).1", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).4", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)-hasParameter-nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).0", "source": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "target": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator).0", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).2", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-hasParameter-nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).1", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game).0", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).3", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game).0", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-hasParameter-nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int)-hasParameter-nl.tudelft.jpacman.board.Direction(int,int).0", "source": "nl.tudelft.jpacman.board.Direction(int,int)", "target": "nl.tudelft.jpacman.board.Direction(int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).3", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)-hasParameter-nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).1", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "target": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)-hasParameter-nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor).0", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "source": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).1", "source": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).1", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)-hasParameter-nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).0", "source": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).1", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator).0", "source": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)-hasParameter-nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).1", "source": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)-hasParameter-nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).1", "source": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable)", "target": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-hasParameter-nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).2", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)-hasParameter-nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String).0", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)-hasParameter-nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0", "source": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)-hasParameter-nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String).0", "source": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String)", "target": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).4", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)-hasParameter-nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "source": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "target": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)-hasParameter-nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0", "source": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).4", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)-hasParameter-nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map).0", "source": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map)", "target": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).3", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).3", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-hasParameter-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).2", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.addPoints(int)-hasParameter-nl.tudelft.jpacman.level.Player.addPoints(int).0", "source": "nl.tudelft.jpacman.level.Player.addPoints(int)", "target": "nl.tudelft.jpacman.level.Player.addPoints(int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-hasParameter-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).5", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).5", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)-hasParameter-nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).0", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap)", "target": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)-hasParameter-nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).0", "source": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).1", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).2", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)-hasParameter-nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String).0", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-hasParameter-nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).1", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)-hasParameter-nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).0", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List).0", "source": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).0", "source": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)-hasParameter-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).1", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-hasParameter-nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).0", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)-hasParameter-nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).1", "source": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory)", "target": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).1", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-hasParameter-nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "source": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-hasParameter-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).0", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).1", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).0", "source": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)-hasParameter-nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String).0", "source": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String)", "target": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent)-hasParameter-nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent).0", "source": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent)", "target": "nl.tudelft.jpacman.ui.PacKeyListener.keyTyped(java.awt.event.KeyEvent).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)-hasParameter-nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "source": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites)", "target": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)-hasParameter-nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0", "source": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "target": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])-hasParameter-nl.tudelft.jpacman.level.MapParser.parseMap(char[][]).0", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][]).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int)-hasParameter-nl.tudelft.jpacman.board.Direction(int,int).1", "source": "nl.tudelft.jpacman.board.Direction(int,int)", "target": "nl.tudelft.jpacman.board.Direction(int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)-hasParameter-nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class).0", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)-hasParameter-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).2", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).2", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).1", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-hasParameter-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).4", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).4", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)-hasParameter-nl.tudelft.jpacman.board.Unit.squaresAheadOf(int).0", "source": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "target": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).0", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)-hasParameter-nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).0", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-hasParameter-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)-hasParameter-nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).1", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).1", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-hasParameter-nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "label": "hasParameter", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.deltaX-type-int", "source": "nl.tudelft.jpacman.board.Direction.deltaX", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0-type-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "target": "nl.tudelft.jpacman.level.Level", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).1-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).1", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.players-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.Level.players", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).0-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).0", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.board-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Board.board", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.lastUpdate-type-long", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.lastUpdate", "target": "long", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.EAST-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Direction.EAST", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).3-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).3", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).1-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action).1", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.SQUARES_AHEAD-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.SQUARES_AHEAD", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).2-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).2", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.levelMap-type-java.lang.String", "source": "nl.tudelft.jpacman.Launcher.levelMap", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.PINKY-type-int", "source": "nl.tudelft.jpacman.level.LevelFactory.PINKY", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2-type-boolean", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE-type-int", "source": "nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.PELLET_VALUE-type-int", "source": "nl.tudelft.jpacman.level.LevelFactory.PELLET_VALUE", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.sprites-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.level.Player.sprites", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.image-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.level.Pellet.image", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).2-type-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).2", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).1-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).1", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).4-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).4", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationFrames-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationFrames", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet.value-type-int", "source": "nl.tudelft.jpacman.level.Pellet.value", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.ui.ScorePanel(java.util.List).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.npc-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask.npc", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.SPRITE_STORE-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.Launcher.SPRITE_STORE", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).1-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).1-type-int", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).3-type-boolean", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).3", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1-type-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "target": "nl.tudelft.jpacman.level.Pellet", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).2-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).2", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).4-type-int", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).4", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List).0-type-java.lang.String", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).2-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).2", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).0-type-int", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int).1-type-int", "source": "nl.tudelft.jpacman.board.Direction(int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.boardPanel-type-nl.tudelft.jpacman.ui.BoardPanel", "source": "nl.tudelft.jpacman.ui.PacManUI.boardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).1-type-int", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handler-type-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handler", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.direction-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Unit.direction", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_DEATH_FRAMES-type-int", "source": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_DEATH_FRAMES", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.addPoints(int).0-type-int", "source": "nl.tudelft.jpacman.level.Player.addPoints(int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int).0-type-int", "source": "nl.tudelft.jpacman.board.Board.squareAt(int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).1-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).1", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1-type-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).1", "target": "nl.tudelft.jpacman.level.Level", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.GHOSTS-type-int", "source": "nl.tudelft.jpacman.level.LevelFactory.GHOSTS", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.ORANGE-type-nl.tudelft.jpacman.npc.ghost.GhostColor", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor.ORANGE", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String).0-type-java.lang.String", "source": "nl.tudelft.jpacman.Launcher.withMapFile(java.lang.String).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String).0-type-java.lang.String", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.occupants-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.Square.occupants", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game).0-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game).0", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.DEFAULT_MAP-type-java.lang.String", "source": "nl.tudelft.jpacman.Launcher.DEFAULT_MAP", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.SHYNESS-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.SHYNESS", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.level-type-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.game.SinglePlayerGame.level", "target": "nl.tudelft.jpacman.level.Level", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).0-type-java.lang.String", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.RED-type-nl.tudelft.jpacman.npc.ghost.GhostColor", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor.RED", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator).0-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator).0", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.DEFAULT_SCORE_FORMATTER-type-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui.ScorePanel.DEFAULT_SCORE_FORMATTER", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.mappings-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacKeyListener.mappings", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0-type-nl.tudelft.jpacman.level.Level$LevelObserver", "source": "nl.tudelft.jpacman.level.Level.removeObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "target": "nl.tudelft.jpacman.level.Level$LevelObserver", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game).0-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game).0", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).0-type-char", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).0", "target": "char", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).1-type-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).1", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.MOVE_INTERVAL-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Inky.MOVE_INTERVAL", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).2-type-int", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pointCalculator-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.level.PlayerCollisions.pointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).1-type-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board).1", "target": "nl.tudelft.jpacman.board.Board", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).0-type-nl.tudelft.jpacman.level.LevelFactory", "source": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).0", "target": "nl.tudelft.jpacman.level.LevelFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).1-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).1", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map).0-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacKeyListener(java.util.Map).0", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.MOVE_INTERVAL-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.MOVE_INTERVAL", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel.serialVersionUID-type-long", "source": "nl.tudelft.jpacman.ui.ButtonPanel.serialVersionUID", "target": "long", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.keyMappings-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.keyMappings", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.level.Pellet", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_ANIMATION_FRAMES-type-int", "source": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_ANIMATION_FRAMES", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.pointCalculator-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.level.LevelFactory.pointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).1-type-nl.tudelft.jpacman.board.BoardFactory", "source": "nl.tudelft.jpacman.level.MapParser(nl.tudelft.jpacman.level.LevelFactory,nl.tudelft.jpacman.board.BoardFactory).1", "target": "nl.tudelft.jpacman.board.BoardFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.deltaY-type-int", "source": "nl.tudelft.jpacman.board.Direction.deltaY", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).2-type-boolean", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).2", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).0-type-int", "source": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.direction-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.direction", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.sprites-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.board.BoardFactory.sprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION-type-java.lang.String", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.pointCalculator-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.game.Game.pointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.inProgress-type-boolean", "source": "nl.tudelft.jpacman.game.Game.inProgress", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask(java.util.concurrent.ScheduledExecutorService,nl.tudelft.jpacman.npc.Ghost).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.sprites-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.npc.Ghost.sprites", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).2-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).2", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.parent-type-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.parent", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.pointCalculator-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.pointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).2-type-int", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).2-type-int", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1-type-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "target": "nl.tudelft.jpacman.level.Pellet", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).1-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).1", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).5-type-int", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).5", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.WEST-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Direction.WEST", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.game-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.ui.BoardPanel.game", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).3-type-boolean", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).3", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).4-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).4", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).1-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.addButton(java.lang.String,nl.tudelft.jpacman.ui.Action).1", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.animating-type-boolean", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.animating", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.INTERVAL_VARIATION-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.INTERVAL_VARIATION", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.background-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground.background", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1-type-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).1", "target": "nl.tudelft.jpacman.level.Pellet", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction(int,int).0-type-int", "source": "nl.tudelft.jpacman.board.Direction(int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.moveInterval-type-int", "source": "nl.tudelft.jpacman.npc.Ghost.moveInterval", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.sprites-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.sprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setAlive(boolean).0-type-boolean", "source": "nl.tudelft.jpacman.level.Player.setAlive(boolean).0", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.boardCreator-type-nl.tudelft.jpacman.board.BoardFactory", "source": "nl.tudelft.jpacman.level.MapParser.boardCreator", "target": "nl.tudelft.jpacman.board.BoardFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.sprites-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.level.LevelFactory.sprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0-type-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.intervalVariation-type-int", "source": "nl.tudelft.jpacman.npc.Ghost.intervalVariation", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.board-type-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.level.Level.board", "target": "nl.tudelft.jpacman.board.Board", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.pacManUI-type-nl.tudelft.jpacman.ui.PacManUI", "source": "nl.tudelft.jpacman.Launcher.pacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String).0-type-java.lang.String", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.spriteMap-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.SpriteStore.spriteMap", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).1-type-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).1", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2-type-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.square-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.square", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).4-type-int", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).4", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0-type-nl.tudelft.jpacman.level.Level$LevelObserver", "source": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver).0", "target": "nl.tudelft.jpacman.level.Level$LevelObserver", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).3-type-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).3", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1-type-java.lang.String", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites).0-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.level.PlayerFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).2-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).2", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.defaultButtons-type-boolean", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.defaultButtons", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor).0-type-nl.tudelft.jpacman.npc.ghost.GhostColor", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor).0", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.INKY-type-int", "source": "nl.tudelft.jpacman.level.LevelFactory.INKY", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator).0-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap(nl.tudelft.jpacman.points.PointCalculator).0", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).0-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.INTERVAL_VARIATION-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.INTERVAL_VARIATION", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).1", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).0-type-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension).0", "target": "nl.tudelft.jpacman.board.Board", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.MOVE_INTERVAL-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.MOVE_INTERVAL", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean).0-type-boolean", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean).0", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List).0-type-java.lang.String", "source": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).0-type-java.lang.String", "source": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String,java.lang.Throwable).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game).0-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game).0", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.scorePanel-type-nl.tudelft.jpacman.ui.ScorePanel", "source": "nl.tudelft.jpacman.ui.PacManUI.scorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.npcs-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.Level.npcs", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.NORTH-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Direction.NORTH", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).1-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.inProgress-type-boolean", "source": "nl.tudelft.jpacman.level.Level.inProgress", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites).0-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.board.BoardFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.ghostFact-type-nl.tudelft.jpacman.npc.ghost.GhostFactory", "source": "nl.tudelft.jpacman.level.LevelFactory.ghostFact", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.deathSprite-type-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.level.Player.deathSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).0-type-java.lang.String", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).2-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).2", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).2-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit).2", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.collisions-type-nl.tudelft.jpacman.level.CollisionMap", "source": "nl.tudelft.jpacman.level.Level.collisions", "target": "nl.tudelft.jpacman.level.CollisionMap", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).2-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).2", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.buttons-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.buttons", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).1-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction).1", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.spriteMap-type-java.lang.String", "source": "nl.tudelft.jpacman.sprite.SpriteStore.spriteMap", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).0-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).0", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).4-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).4", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).5-type-char", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).5", "target": "char", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.alive-type-boolean", "source": "nl.tudelft.jpacman.level.Player.alive", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.sprites-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.level.Player.sprites", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.serialVersionUID-type-long", "source": "nl.tudelft.jpacman.ui.BoardPanel.serialVersionUID", "target": "long", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).1-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).1", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).0-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int).0-type-int", "source": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.playerFactory-type-nl.tudelft.jpacman.level.PlayerFactory", "source": "nl.tudelft.jpacman.game.GameFactory.playerFactory", "target": "nl.tudelft.jpacman.level.PlayerFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION-type-java.lang.String", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).3-type-int", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.buttons-type-java.lang.String", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.buttons", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).4-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).4", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.END_OF_LOOP-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.END_OF_LOOP", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.looping-type-boolean", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.looping", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.killer-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.Player.killer", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][]).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][]).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground.isAccessibleTo(nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.sprites-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.Ghost.sprites", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).0-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.MOVE_INTERVAL-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.MOVE_INTERVAL", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).2-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).2", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game).0-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game).0", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE-type-int", "source": "nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collisions-type-nl.tudelft.jpacman.level.CollisionMap", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collisions", "target": "nl.tudelft.jpacman.level.CollisionMap", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][]).0-type-char", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][]).0", "target": "char", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).0-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.PINK-type-nl.tudelft.jpacman.npc.ghost.GhostColor", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor.PINK", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.FRAME_INTERVAL-type-int", "source": "nl.tudelft.jpacman.ui.PacManUI.FRAME_INTERVAL", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction.SOUTH-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Direction.SOUTH", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).0-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0-type-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.withScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).0", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).0-type-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).0", "target": "nl.tudelft.jpacman.board.Board", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.square-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Unit.square", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).1-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.main(java.lang.String[]).0-type-java.lang.String", "source": "nl.tudelft.jpacman.Launcher.main(java.lang.String[]).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY-type-int", "source": "nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).3-type-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).3", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.levelCreator-type-nl.tudelft.jpacman.level.LevelFactory", "source": "nl.tudelft.jpacman.level.MapParser.levelCreator", "target": "nl.tudelft.jpacman.level.LevelFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.SQUARES_AHEAD-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Inky.SQUARES_AHEAD", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.current-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.current", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites).0-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory(nl.tudelft.jpacman.sprite.PacManSprites).0", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).1-type-nl.tudelft.jpacman.npc.ghost.GhostFactory", "source": "nl.tudelft.jpacman.level.LevelFactory(nl.tudelft.jpacman.sprite.PacManSprites,nl.tudelft.jpacman.npc.ghost.GhostFactory,nl.tudelft.jpacman.points.PointCalculator).1", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost).1", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator).0-type-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.level.PlayerCollisions(nl.tudelft.jpacman.points.PointCalculator).0", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startSquares-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.Level.startSquares", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).4-type-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).4", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).5-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List).5", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.CLYDE-type-int", "source": "nl.tudelft.jpacman.level.LevelFactory.CLYDE", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0-type-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler(nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).0", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String).0-type-java.lang.String", "source": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.INTERVAL_VARIATION-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.INTERVAL_VARIATION", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2-type-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler).2", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.GHOST_ANIMATION_FRAMES-type-int", "source": "nl.tudelft.jpacman.sprite.PacManSprites.GHOST_ANIMATION_FRAMES", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.EmptySprite.draw(java.awt.Graphics,int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.scoreFormatter-type-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui.ScorePanel.scoreFormatter", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).1-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square).1", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor.CYAN-type-nl.tudelft.jpacman.npc.ghost.GhostColor", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor.CYAN", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.INTERVAL_VARIATION-type-int", "source": "nl.tudelft.jpacman.npc.ghost.Inky.INTERVAL_VARIATION", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).1-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit).1", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.neighbours-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Square.neighbours", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.scoreLabels-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.ui.ScorePanel.scoreLabels", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.neighbours-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Square.neighbours", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int).1-type-int", "source": "nl.tudelft.jpacman.board.Board.squareAt(int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).2-type-boolean", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean).2", "target": "boolean", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String).0-type-java.lang.String", "source": "nl.tudelft.jpacman.PacmanConfigurationException(java.lang.String).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory).0-type-nl.tudelft.jpacman.level.PlayerFactory", "source": "nl.tudelft.jpacman.game.GameFactory(nl.tudelft.jpacman.level.PlayerFactory).0", "target": "nl.tudelft.jpacman.level.PlayerFactory", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node(nl.tudelft.jpacman.board.Direction,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.npc.ghost.Navigation$Node).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.DELAY-type-long", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.DELAY", "target": "long", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).1-type-int", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game).0-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game).0", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).0-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).0", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.serialVersionUID-type-long", "source": "nl.tudelft.jpacman.ui.PacManUI.serialVersionUID", "target": "long", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame.player-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.game.SinglePlayerGame.player", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0-type-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction).0", "target": "nl.tudelft.jpacman.level.Player", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String).0-type-java.lang.String", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).0-type-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List).0", "target": "nl.tudelft.jpacman.board.Board", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder).0-type-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder).0", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.scoreFormatter-type-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.scoreFormatter", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall.background-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall.background", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationDelay-type-int", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationDelay", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).1-type-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction).1", "target": "nl.tudelft.jpacman.board.Direction", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).1-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).3-type-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square).3", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1-type-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit).1", "target": "nl.tudelft.jpacman.board.Unit", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).3-type-nl.tudelft.jpacman.level.CollisionMap", "source": "nl.tudelft.jpacman.level.Level(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List,nl.tudelft.jpacman.level.CollisionMap).3", "target": "nl.tudelft.jpacman.level.CollisionMap", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.observers-type-nl.tudelft.jpacman.level.Level$LevelObserver", "source": "nl.tudelft.jpacman.level.Level.observers", "target": "nl.tudelft.jpacman.level.Level$LevelObserver", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0-type-java.lang.String", "source": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame).0", "target": "java.lang.String", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.sprites-type-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.level.PlayerFactory.sprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).1-type-int", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean).1", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).0-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int).0", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).3-type-int", "source": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int).3", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1-type-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter).1", "target": "nl.tudelft.jpacman.ui.Action", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type argument", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite).0-type-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite).0", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).4-type-int", "source": "nl.tudelft.jpacman.sprite.ImageSprite.draw(java.awt.Graphics,int,int,int,int).4", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.BLINKY-type-int", "source": "nl.tudelft.jpacman.level.LevelFactory.BLINKY", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.score-type-int", "source": "nl.tudelft.jpacman.level.Player.score", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startSquareIndex-type-int", "source": "nl.tudelft.jpacman.level.Level.startSquareIndex", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.game-type-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.Launcher.game", "target": "nl.tudelft.jpacman.game.Game", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.ghostIndex-type-int", "source": "nl.tudelft.jpacman.level.LevelFactory.ghostIndex", "target": "int", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][]).0-type-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][]).0", "target": "nl.tudelft.jpacman.board.Square", "label": "type", "properties": {"weight": 1, "kind": "array type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.serialVersionUID-type-long", "source": "nl.tudelft.jpacman.ui.ScorePanel.serialVersionUID", "target": "long", "label": "type", "properties": {"weight": 1, "kind": "type", "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)-invokes-nl.tudelft.jpacman.board.Unit()", "source": "nl.tudelft.jpacman.level.Pellet(int,nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.board.Unit()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)-invokes-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "source": "nl.tudelft.jpacman.npc.ghost.Clyde(java.util.Map)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-invokes-nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.Game(nl.tudelft.jpacman.points.PointCalculator)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelFactory()-invokes-nl.tudelft.jpacman.Launcher.getGhostFactory()", "source": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "target": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.updateObservers()-invokes-nl.tudelft.jpacman.level.Level.remainingPellets()", "source": "nl.tudelft.jpacman.level.Level.updateObservers()", "target": "nl.tudelft.jpacman.level.Level.remainingPellets()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.leaveSquare()-invokes-nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "target": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-invokes-nl.tudelft.jpacman.level.Player.setAlive(boolean)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-invokes-nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.withDefaultButtons()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 4, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getDirection()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)-invokes-nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-invokes-nl.tudelft.jpacman.board.Direction.getDeltaY()", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Direction.getDeltaY()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)-invokes-nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.newImage(int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)-invokes-nl.tudelft.jpacman.level.Level.getBoard()", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.level.Level.getBoard()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()-invokes-nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "source": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "target": "nl.tudelft.jpacman.level.PlayerFactory.getSprites()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)-invokes-nl.tudelft.jpacman.board.Board.getHeight()", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "target": "nl.tudelft.jpacman.board.Board.getHeight()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)-invokes-nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-invokes-nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)-invokes-nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "target": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)-invokes-nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setAlive(boolean)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "source": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.stop()-invokes-nl.tudelft.jpacman.level.Level.stopNPCs()", "source": "nl.tudelft.jpacman.level.Level.stop()", "target": "nl.tudelft.jpacman.level.Level.stopNPCs()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-invokes-nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.put(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-invokes-nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Square.link(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)-invokes-nl.tudelft.jpacman.game.Game.getLevel()", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.game.Game.getLevel()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])-invokes-nl.tudelft.jpacman.board.Board.invariant()", "source": "nl.tudelft.jpacman.board.Board(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Board.invariant()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getSprite()-invokes-nl.tudelft.jpacman.board.Unit.getDirection()", "source": "nl.tudelft.jpacman.level.Player.getSprite()", "target": "nl.tudelft.jpacman.board.Unit.getDirection()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Square.getOccupants()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.getOccupants()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-invokes-nl.tudelft.jpacman.level.LevelFactory.createGhost()", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-invokes-nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-invokes-nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "source": "nl.tudelft.jpacman.game.SinglePlayerGame(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.points.PointCalculator.pacmanMoved(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-invokes-nl.tudelft.jpacman.board.BoardFactory.createWall()", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeGame()-invokes-nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "source": "nl.tudelft.jpacman.Launcher.makeGame()", "target": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.level.Level.updateObservers()", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.level.Level.updateObservers()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.Launcher.getGame()", "source": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.Launcher.getGame()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()-invokes-nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.squareAt(int,int)-invokes-nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "source": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "target": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-invokes-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "source": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeLevel()-invokes-nl.tudelft.jpacman.Launcher.getMapParser()", "source": "nl.tudelft.jpacman.Launcher.makeLevel()", "target": "nl.tudelft.jpacman.Launcher.getMapParser()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-invokes-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()-invokes-nl.tudelft.jpacman.board.Direction.opposite()", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "target": "nl.tudelft.jpacman.board.Direction.opposite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()-invokes-nl.tudelft.jpacman.level.Player.isAlive()", "source": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "target": "nl.tudelft.jpacman.level.Player.isAlive()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-invokes-nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.stop()-invokes-nl.tudelft.jpacman.game.Game.isInProgress()", "source": "nl.tudelft.jpacman.game.Game.stop()", "target": "nl.tudelft.jpacman.game.Game.isInProgress()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 3, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)-invokes-nl.tudelft.jpacman.game.Game.getLevel()", "source": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "target": "nl.tudelft.jpacman.game.Game.getLevel()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.getSprite()-invokes-nl.tudelft.jpacman.level.Player.isAlive()", "source": "nl.tudelft.jpacman.level.Player.getSprite()", "target": "nl.tudelft.jpacman.level.Player.isAlive()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.board.Square.invariant(nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.levelWon()-invokes-nl.tudelft.jpacman.game.Game.stop()", "source": "nl.tudelft.jpacman.game.Game.levelWon()", "target": "nl.tudelft.jpacman.game.Game.stop()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.getPath()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player.setAlive(boolean)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "source": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Unit.invariant()", "source": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Unit.invariant()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)-invokes-nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)-invokes-nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "source": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addKey(java.lang.Integer,nl.tudelft.jpacman.ui.Action)", "label": "invokes", "properties": {"weight": 4, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)-invokes-nl.tudelft.jpacman.board.Square()", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground(nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.board.Square()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-invokes-nl.tudelft.jpacman.board.BoardFactory.createGround()", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "label": "invokes", "properties": {"weight": 3, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-invokes-nl.tudelft.jpacman.board.Unit.getSprite()", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.board.Unit.getSprite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-invokes-nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()-invokes-nl.tudelft.jpacman.game.Game.getLevel()", "source": "nl.tudelft.jpacman.game.Game.start()", "target": "nl.tudelft.jpacman.game.Game.getLevel()", "label": "invokes", "properties": {"weight": 4, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-invokes-nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.ScorePanel.setScoreFormatter(nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()-invokes-nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "target": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()-invokes-nl.tudelft.jpacman.npc.Ghost.getInterval()", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "target": "nl.tudelft.jpacman.npc.Ghost.getInterval()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()-invokes-nl.tudelft.jpacman.sprite.Sprite.getWidth()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.getWidth()", "target": "nl.tudelft.jpacman.sprite.Sprite.getWidth()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.remove(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)-invokes-nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSprite(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)-invokes-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost(java.util.Map)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.stop()-invokes-nl.tudelft.jpacman.level.Level.stop()", "source": "nl.tudelft.jpacman.game.Game.stop()", "target": "nl.tudelft.jpacman.level.Level.stop()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()-invokes-nl.tudelft.jpacman.level.Level.getBoard()", "source": "nl.tudelft.jpacman.level.Level.remainingPellets()", "target": "nl.tudelft.jpacman.level.Level.getBoard()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-invokes-nl.tudelft.jpacman.board.Board.squareAt(int,int)", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeGame()-invokes-nl.tudelft.jpacman.Launcher.getGameFactory()", "source": "nl.tudelft.jpacman.Launcher.makeGame()", "target": "nl.tudelft.jpacman.Launcher.getGameFactory()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.randomMove()-invokes-nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "target": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeLevel()-invokes-nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "source": "nl.tudelft.jpacman.Launcher.makeLevel()", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)-invokes-nl.tudelft.jpacman.board.Board.getWidth()", "source": "nl.tudelft.jpacman.board.Board.withinBorders(int,int)", "target": "nl.tudelft.jpacman.board.Board.getWidth()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-invokes-nl.tudelft.jpacman.level.Player.setAlive(boolean)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.level.Player.setAlive(boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)-invokes-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "source": "nl.tudelft.jpacman.npc.ghost.Inky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.restart()-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.restart()", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-invokes-nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-invokes-nl.tudelft.jpacman.sprite.Sprite.getWidth()", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.Sprite.getWidth()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)-invokes-nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.Launcher.addSinglePlayerKeys(nl.tudelft.jpacman.ui.PacManUiBuilder)", "target": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 4, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.stop()-invokes-nl.tudelft.jpacman.level.Level.isInProgress()", "source": "nl.tudelft.jpacman.level.Level.stop()", "target": "nl.tudelft.jpacman.level.Level.isInProgress()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.updateObservers()-invokes-nl.tudelft.jpacman.level.Level$LevelObserver.levelLost()", "source": "nl.tudelft.jpacman.level.Level.updateObservers()", "target": "nl.tudelft.jpacman.level.Level$LevelObserver.levelLost()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.level.Level.isInProgress()", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.level.Level.isInProgress()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])-invokes-nl.tudelft.jpacman.Launcher.launch()", "source": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "target": "nl.tudelft.jpacman.Launcher.launch()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createGround()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "source": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGroundSprite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createPellet()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "source": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-invokes-nl.tudelft.jpacman.ui.PacManUI.start()", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "nl.tudelft.jpacman.ui.PacManUI.start()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Unit.setDirection(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)-invokes-nl.tudelft.jpacman.level.Level.getBoard()", "source": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "target": "nl.tudelft.jpacman.level.Level.getBoard()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeGame()-invokes-nl.tudelft.jpacman.Launcher.loadPointCalculator()", "source": "nl.tudelft.jpacman.Launcher.makeGame()", "target": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.game.Game.getLevel()", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.game.Game.getLevel()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.pelletColliding(nl.tudelft.jpacman.level.Pellet,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-invokes-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()-invokes-nl.tudelft.jpacman.level.Level.start()", "source": "nl.tudelft.jpacman.game.Game.start()", "target": "nl.tudelft.jpacman.level.Level.start()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Clyde.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-invokes-nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.points.PointCalculator.collidedWithAGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-invokes-nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeLevel()-invokes-nl.tudelft.jpacman.Launcher.getLevelMap()", "source": "nl.tudelft.jpacman.Launcher.makeLevel()", "target": "nl.tudelft.jpacman.Launcher.getLevelMap()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-invokes-nl.tudelft.jpacman.level.Pellet.getValue()", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.level.Pellet.getValue()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-invokes-nl.tudelft.jpacman.level.LevelFactory.createPellet()", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)-invokes-nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])-invokes-nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "target": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)-invokes-nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "target": "nl.tudelft.jpacman.level.MapParser.parseMap(java.io.InputStream)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-invokes-nl.tudelft.jpacman.Launcher.getGame()", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "nl.tudelft.jpacman.Launcher.getGame()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)-invokes-nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.level.Level.registerPlayer(nl.tudelft.jpacman.level.Player)", "target": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-invokes-nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-invokes-nl.tudelft.jpacman.board.Unit.leaveSquare()", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.getSquare()-invokes-nl.tudelft.jpacman.board.Unit.invariant()", "source": "nl.tudelft.jpacman.board.Unit.getSquare()", "target": "nl.tudelft.jpacman.board.Unit.invariant()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite.withinImage(int,int)", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()-invokes-nl.tudelft.jpacman.game.Game.isInProgress()", "source": "nl.tudelft.jpacman.game.Game.start()", "target": "nl.tudelft.jpacman.game.Game.isInProgress()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)-invokes-nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "source": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-invokes-nl.tudelft.jpacman.board.Board.getWidth()", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Board.getWidth()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-invokes-nl.tudelft.jpacman.board.Direction.getDeltaX()", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Direction.getDeltaX()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)-invokes-nl.tudelft.jpacman.board.Board.getHeight()", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.board.Board.getHeight()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.start()-invokes-nl.tudelft.jpacman.level.Level.isInProgress()", "source": "nl.tudelft.jpacman.level.Level.start()", "target": "nl.tudelft.jpacman.level.Level.isInProgress()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.refresh()-invokes-nl.tudelft.jpacman.level.Player.isAlive()", "source": "nl.tudelft.jpacman.ui.ScorePanel.refresh()", "target": "nl.tudelft.jpacman.level.Player.isAlive()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.currentSprite()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startNPCs()-invokes-nl.tudelft.jpacman.npc.Ghost.getInterval()", "source": "nl.tudelft.jpacman.level.Level.startNPCs()", "target": "nl.tudelft.jpacman.npc.Ghost.getInterval()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getMapParser()-invokes-nl.tudelft.jpacman.Launcher.getLevelFactory()", "source": "nl.tudelft.jpacman.Launcher.getMapParser()", "target": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGhostFactory()-invokes-nl.tudelft.jpacman.Launcher.getSpriteStore()", "source": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "target": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.game.Game.isInProgress()", "source": "nl.tudelft.jpacman.game.Game.move(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.game.Game.isInProgress()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-invokes-nl.tudelft.jpacman.level.Player.addPoints(int)", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.level.Player.addPoints(int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)-invokes-nl.tudelft.jpacman.board.Board.squareAt(int,int)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "target": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelFactory()-invokes-nl.tudelft.jpacman.Launcher.getSpriteStore()", "source": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "target": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-invokes-nl.tudelft.jpacman.board.Board.getHeight()", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "nl.tudelft.jpacman.board.Board.getHeight()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite(nl.tudelft.jpacman.sprite.Sprite[],int,boolean,boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-invokes-nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.level.Player.setKiller(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-invokes-nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.addHandler(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.levelLost()-invokes-nl.tudelft.jpacman.game.Game.stop()", "source": "nl.tudelft.jpacman.game.Game.levelLost()", "target": "nl.tudelft.jpacman.game.Game.stop()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)-invokes-nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStopButton(nl.tudelft.jpacman.game.Game)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-invokes-nl.tudelft.jpacman.game.Game.getPlayers()", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.game.Game.getPlayers()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)-invokes-nl.tudelft.jpacman.board.Board.getWidth()", "source": "nl.tudelft.jpacman.ui.BoardPanel(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.board.Board.getWidth()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-invokes-nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.board.Unit.occupy(nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler.handleCollision(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)-invokes-nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.addStartButton(nl.tudelft.jpacman.game.Game)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-invokes-nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.invariant()-invokes-nl.tudelft.jpacman.board.Square.getOccupants()", "source": "nl.tudelft.jpacman.board.Unit.invariant()", "target": "nl.tudelft.jpacman.board.Square.getOccupants()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)-invokes-nl.tudelft.jpacman.ui.Action.doAction()", "source": "nl.tudelft.jpacman.ui.ButtonPanel(java.util.Map,javax.swing.JFrame)", "target": "nl.tudelft.jpacman.ui.Action.doAction()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.getSprite()-invokes-nl.tudelft.jpacman.board.Unit.getDirection()", "source": "nl.tudelft.jpacman.npc.Ghost.getSprite()", "target": "nl.tudelft.jpacman.board.Unit.getDirection()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.stop()-invokes-nl.tudelft.jpacman.game.Game.getLevel()", "source": "nl.tudelft.jpacman.game.Game.stop()", "target": "nl.tudelft.jpacman.game.Game.getLevel()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.updateObservers()-invokes-nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "source": "nl.tudelft.jpacman.level.Level.updateObservers()", "target": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)-invokes-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "source": "nl.tudelft.jpacman.npc.ghost.Blinky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPacmanSprites()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.getPelletSprite()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.start()-invokes-nl.tudelft.jpacman.level.Level.startNPCs()", "source": "nl.tudelft.jpacman.level.Level.start()", "target": "nl.tudelft.jpacman.level.Level.startNPCs()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel.refresh()-invokes-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "source": "nl.tudelft.jpacman.ui.ScorePanel.refresh()", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter.format(nl.tudelft.jpacman.level.Player)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerColliding(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)-invokes-nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.getMostSpecificClass(java.util.Map,java.lang.Class)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.getInheritance(java.lang.Class)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-invokes-nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-invokes-nl.tudelft.jpacman.board.Board.getHeight()", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Board.getHeight()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)-invokes-nl.tudelft.jpacman.board.Board.getWidth()", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "target": "nl.tudelft.jpacman.board.Board.getWidth()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI.nextFrame()-invokes-nl.tudelft.jpacman.ui.ScorePanel.refresh()", "source": "nl.tudelft.jpacman.ui.PacManUI.nextFrame()", "target": "nl.tudelft.jpacman.ui.ScorePanel.refresh()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()-invokes-nl.tudelft.jpacman.board.Board.getHeight()", "source": "nl.tudelft.jpacman.level.Level.remainingPellets()", "target": "nl.tudelft.jpacman.board.Board.getHeight()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getMapParser()-invokes-nl.tudelft.jpacman.Launcher.getBoardFactory()", "source": "nl.tudelft.jpacman.Launcher.getMapParser()", "target": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)-invokes-nl.tudelft.jpacman.game.Game.getPlayers()", "source": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.game.Game.getPlayers()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.updateObservers()-invokes-nl.tudelft.jpacman.level.Level$LevelObserver.levelWon()", "source": "nl.tudelft.jpacman.level.Level.updateObservers()", "target": "nl.tudelft.jpacman.level.Level$LevelObserver.levelWon()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.randomMove()-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()-invokes-nl.tudelft.jpacman.sprite.Sprite.getHeight()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.getHeight()", "target": "nl.tudelft.jpacman.sprite.Sprite.getHeight()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getBoardFactory()-invokes-nl.tudelft.jpacman.Launcher.getSpriteStore()", "source": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "target": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()-invokes-nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "source": "nl.tudelft.jpacman.game.Game.start()", "target": "nl.tudelft.jpacman.level.Level.addObserver(nl.tudelft.jpacman.level.Level$LevelObserver)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-invokes-nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Square.isAccessibleTo(nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.loadPointCalculator()-invokes-nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "source": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader.load()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)-invokes-nl.tudelft.jpacman.board.BoardFactory.createGround()", "source": "nl.tudelft.jpacman.level.MapParser.makeGhostSquare(java.util.List,nl.tudelft.jpacman.npc.Ghost)", "target": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()-invokes-nl.tudelft.jpacman.npc.Ghost.nextMove()", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "target": "nl.tudelft.jpacman.npc.Ghost.nextMove()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])-invokes-nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "target": "nl.tudelft.jpacman.level.MapParser.makeGrid(char[][],int,int,nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()-invokes-nl.tudelft.jpacman.level.Level.remainingPellets()", "source": "nl.tudelft.jpacman.game.Game.start()", "target": "nl.tudelft.jpacman.level.Level.remainingPellets()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-invokes-nl.tudelft.jpacman.Launcher.makeGame()", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "nl.tudelft.jpacman.Launcher.makeGame()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.start()-invokes-nl.tudelft.jpacman.level.Level.updateObservers()", "source": "nl.tudelft.jpacman.level.Level.start()", "target": "nl.tudelft.jpacman.level.Level.updateObservers()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.nextMove()-invokes-nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "source": "nl.tudelft.jpacman.npc.Ghost.nextMove()", "target": "nl.tudelft.jpacman.npc.Ghost.nextAiMove()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)-invokes-nl.tudelft.jpacman.board.Unit.leaveSquare()", "source": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "target": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.draw(java.awt.Graphics,int,int,int,int)", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnit(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-invokes-nl.tudelft.jpacman.sprite.Sprite.getHeight()", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.Sprite.getHeight()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.board.Square.getOccupants()", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Square.getOccupants()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createWall()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "source": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getWallSprite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.level.CollisionMap.collide(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Unit)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game.start()-invokes-nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "source": "nl.tudelft.jpacman.game.Game.start()", "target": "nl.tudelft.jpacman.level.Level.isAnyPlayerAlive()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.findNearest(java.lang.Class,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.setAnimating(boolean)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)-invokes-nl.tudelft.jpacman.board.Unit()", "source": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "target": "nl.tudelft.jpacman.board.Unit()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()-invokes-nl.tudelft.jpacman.board.Board.squareAt(int,int)", "source": "nl.tudelft.jpacman.level.Level.remainingPellets()", "target": "nl.tudelft.jpacman.board.Board.squareAt(int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)-invokes-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.npc.ghost.Inky.followPath(java.util.List,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getPlayerFactory()-invokes-nl.tudelft.jpacman.Launcher.getSpriteStore()", "source": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "target": "nl.tudelft.jpacman.Launcher.getSpriteStore()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()-invokes-nl.tudelft.jpacman.board.Board.getWidth()", "source": "nl.tudelft.jpacman.level.Level.remainingPellets()", "target": "nl.tudelft.jpacman.board.Board.getWidth()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Inky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.board.Unit.hasSquare()", "source": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.board.Unit.hasSquare()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.remainingPellets()-invokes-nl.tudelft.jpacman.board.Square.getOccupants()", "source": "nl.tudelft.jpacman.level.Level.remainingPellets()", "target": "nl.tudelft.jpacman.board.Square.getOccupants()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)-invokes-nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "source": "nl.tudelft.jpacman.sprite.PacManSprites.directionSprite(java.lang.String,int)", "target": "nl.tudelft.jpacman.sprite.Sprite.split(int,int,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)-invokes-nl.tudelft.jpacman.ui.Action.doAction()", "source": "nl.tudelft.jpacman.ui.PacKeyListener.keyPressed(java.awt.event.KeyEvent)", "target": "nl.tudelft.jpacman.ui.Action.doAction()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.draw(java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "source": "nl.tudelft.jpacman.level.PlayerCollisions.ghostColliding(nl.tudelft.jpacman.npc.Ghost,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.level.PlayerCollisions.playerVersusGhost(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.npc.Ghost)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelFactory()-invokes-nl.tudelft.jpacman.Launcher.loadPointCalculator()", "source": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "target": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-invokes-nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "source": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getPacManDeathAnimation()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)-invokes-nl.tudelft.jpacman.board.Board.getHeight()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "target": "nl.tudelft.jpacman.board.Board.getHeight()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)-invokes-nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.update()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)-invokes-nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "source": "nl.tudelft.jpacman.Launcher.moveTowardsDirection(nl.tudelft.jpacman.board.Direction)", "target": "nl.tudelft.jpacman.Launcher.getSinglePlayer(nl.tudelft.jpacman.game.Game)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)-invokes-nl.tudelft.jpacman.board.Unit.getDirection()", "source": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "target": "nl.tudelft.jpacman.board.Unit.getDirection()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])-invokes-nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(char[][])", "target": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)-invokes-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.board.Unit.squaresAheadOf(int)", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()-invokes-nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask.run()", "target": "nl.tudelft.jpacman.level.Level.move(nl.tudelft.jpacman.board.Unit,nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-invokes-nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.points.PointCalculator.consumedAPellet(nl.tudelft.jpacman.level.Player,nl.tudelft.jpacman.level.Pellet)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGameFactory()-invokes-nl.tudelft.jpacman.Launcher.getPlayerFactory()", "source": "nl.tudelft.jpacman.Launcher.getGameFactory()", "target": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites()-invokes-nl.tudelft.jpacman.sprite.SpriteStore()", "source": "nl.tudelft.jpacman.sprite.PacManSprites()", "target": "nl.tudelft.jpacman.sprite.SpriteStore()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)-invokes-nl.tudelft.jpacman.board.Square()", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall(nl.tudelft.jpacman.sprite.Sprite)", "target": "nl.tudelft.jpacman.board.Square()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit.leaveSquare()-invokes-nl.tudelft.jpacman.board.Unit.invariant()", "source": "nl.tudelft.jpacman.board.Unit.leaveSquare()", "target": "nl.tudelft.jpacman.board.Unit.invariant()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)-invokes-nl.tudelft.jpacman.board.Board.getWidth()", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.findUnitInBoard(java.lang.Class,nl.tudelft.jpacman.board.Board)", "target": "nl.tudelft.jpacman.board.Board.getWidth()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()-invokes-nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "target": "nl.tudelft.jpacman.sprite.PacManSprites.getGhostSprite(nl.tudelft.jpacman.npc.ghost.GhostColor)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-invokes-nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)-invokes-nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "source": "nl.tudelft.jpacman.ui.BoardPanel.paint(java.awt.Graphics)", "target": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Board,java.awt.Graphics,java.awt.Dimension)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Blinky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 3, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)-invokes-nl.tudelft.jpacman.board.Unit()", "source": "nl.tudelft.jpacman.level.Player(java.util.Map,nl.tudelft.jpacman.sprite.AnimatedSprite)", "target": "nl.tudelft.jpacman.board.Unit()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()-invokes-nl.tudelft.jpacman.board.Unit.getSquare()", "source": "nl.tudelft.jpacman.npc.ghost.Pinky.nextAiMove()", "target": "nl.tudelft.jpacman.board.Unit.getSquare()", "label": "invokes", "properties": {"weight": 2, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-invokes-nl.tudelft.jpacman.board.Square.getSprite()", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.board.Square.getSprite()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeGame()-invokes-nl.tudelft.jpacman.Launcher.makeLevel()", "source": "nl.tudelft.jpacman.Launcher.makeGame()", "target": "nl.tudelft.jpacman.Launcher.makeLevel()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()-invokes-nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader.loadClassFromFile()", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader.getCalculatorClassName()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)-invokes-nl.tudelft.jpacman.board.Square.getOccupants()", "source": "nl.tudelft.jpacman.ui.BoardPanel.render(nl.tudelft.jpacman.board.Square,java.awt.Graphics,int,int,int,int)", "target": "nl.tudelft.jpacman.board.Square.getOccupants()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost.randomMove()-invokes-nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "source": "nl.tudelft.jpacman.npc.Ghost.randomMove()", "target": "nl.tudelft.jpacman.board.Square.getSquareAt(nl.tudelft.jpacman.board.Direction)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)-invokes-nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "source": "nl.tudelft.jpacman.npc.ghost.Pinky(java.util.Map)", "target": "nl.tudelft.jpacman.npc.Ghost(java.util.Map,int,int)", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-invokes-nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "label": "invokes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft-contains-nl.tudelft.jpacman", "source": "nl.tudelft", "target": "nl.tudelft.jpacman", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-contains-nl.tudelft.jpacman.level.Level$NpcMoveTask", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite-contains-nl.tudelft.jpacman.sprite.EmptySprite", "source": "nl.tudelft.jpacman.sprite", "target": "nl.tudelft.jpacman.sprite.EmptySprite", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.Pinky", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.Pinky", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.Inky", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.Inky", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.PacKeyListener", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.PacKeyListener", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-contains-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.board.Square", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc-contains-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite-contains-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.sprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.GhostFactory", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-contains-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-contains-nl.tudelft.jpacman.level.Level$LevelObserver", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level$LevelObserver", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points-contains-nl.tudelft.jpacman.points.PointCalculatorLoader", "source": "nl.tudelft.jpacman.points", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game-contains-nl.tudelft.jpacman.game.GameFactory", "source": "nl.tudelft.jpacman.game", "target": "nl.tudelft.jpacman.game.GameFactory", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-contains-nl.tudelft.jpacman.board.BoardFactory", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.board.BoardFactory", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.sprite", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.sprite", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.Pellet", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-contains-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.game", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.game", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game-contains-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.game", "target": "nl.tudelft.jpacman.game.Game", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-contains-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.board.Board", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.Launcher", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.Launcher", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.board", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.board", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.BoardPanel", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.BoardPanel", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.Clyde", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.Clyde", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.Blinky", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.Blinky", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.Player", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl-contains-nl.tudelft", "source": "nl", "target": "nl.tudelft", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.Level$NpcMoveTask", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.points", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.points", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-contains-nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points-contains-nl.tudelft.jpacman.points.DefaultPointCalculator", "source": "nl.tudelft.jpacman.points", "target": "nl.tudelft.jpacman.points.DefaultPointCalculator", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory-contains-nl.tudelft.jpacman.board.BoardFactory$Ground", "source": "nl.tudelft.jpacman.board.BoardFactory", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.level", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.level", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.Level$LevelObserver", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.Level$LevelObserver", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.PlayerFactory", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.PlayerFactory", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-contains-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.ScorePanel", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.ScorePanel", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.PlayerCollisions", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.PlayerCollisions", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-contains-nl.tudelft.jpacman.board.BoardFactory$Ground", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.npc", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.npc", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation-contains-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-contains-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.board.Unit", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman-contains-nl.tudelft.jpacman.ui", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.ui", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc-contains-nl.tudelft.jpacman.npc.ghost", "source": "nl.tudelft.jpacman.npc", "target": "nl.tudelft.jpacman.npc.ghost", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-contains-nl.tudelft.jpacman.board.BoardFactory$Wall", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.ButtonPanel", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.ButtonPanel", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points-contains-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.points", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite-contains-nl.tudelft.jpacman.sprite.SpriteStore", "source": "nl.tudelft.jpacman.sprite", "target": "nl.tudelft.jpacman.sprite.SpriteStore", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.MapParser", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.MapParser", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.CollisionInteractionMap", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.GhostColor", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.Navigation", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.Navigation", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.LevelFactory", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.LevelFactory", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-contains-nl.tudelft.jpacman.board.Direction", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.board.Direction", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.CollisionMap", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.CollisionMap", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game-contains-nl.tudelft.jpacman.game.SinglePlayerGame", "source": "nl.tudelft.jpacman.game", "target": "nl.tudelft.jpacman.game.SinglePlayerGame", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite-contains-nl.tudelft.jpacman.sprite.ImageSprite", "source": "nl.tudelft.jpacman.sprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite-contains-nl.tudelft.jpacman.sprite.PacManSprites", "source": "nl.tudelft.jpacman.sprite", "target": "nl.tudelft.jpacman.sprite.PacManSprites", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-contains-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.Action", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.Action", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite-contains-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.Level", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory-contains-nl.tudelft.jpacman.board.BoardFactory$Wall", "source": "nl.tudelft.jpacman.board.BoardFactory", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level-contains-nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui-contains-nl.tudelft.jpacman.ui.PacManUI", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.ui.PacManUI", "label": "contains", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasVariable-nl.tudelft.jpacman.sprite.AnimatedSprite.current", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.current", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.ghostIndex", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.ghostIndex", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask-hasVariable-nl.tudelft.jpacman.level.Level$NpcMoveTask.npc", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask.npc", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.startSquareIndex", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.startSquareIndex", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI-hasVariable-nl.tudelft.jpacman.ui.PacManUI.boardPanel", "source": "nl.tudelft.jpacman.ui.PacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI.boardPanel", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasVariable-nl.tudelft.jpacman.sprite.AnimatedSprite.animationDelay", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationDelay", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasVariable-nl.tudelft.jpacman.board.Direction.EAST", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.EAST", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-hasVariable-nl.tudelft.jpacman.ui.ScorePanel.scoreLabels", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel.scoreLabels", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.moveLock", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.moveLock", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Board-hasVariable-nl.tudelft.jpacman.board.Board.board", "source": "nl.tudelft.jpacman.board.Board", "target": "nl.tudelft.jpacman.board.Board.board", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-hasVariable-nl.tudelft.jpacman.level.CollisionInteractionMap.handlers", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap.handlers", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory-hasVariable-nl.tudelft.jpacman.game.GameFactory.playerFactory", "source": "nl.tudelft.jpacman.game.GameFactory", "target": "nl.tudelft.jpacman.game.GameFactory.playerFactory", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.npcs", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.npcs", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasVariable-nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.DIRECTIONS", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasVariable-nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.START_CAPTION", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasVariable-nl.tudelft.jpacman.level.Player.alive", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.alive", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap-hasVariable-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collisions", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.collisions", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory-hasVariable-nl.tudelft.jpacman.board.BoardFactory.sprites", "source": "nl.tudelft.jpacman.board.BoardFactory", "target": "nl.tudelft.jpacman.board.BoardFactory.sprites", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasVariable-nl.tudelft.jpacman.board.Direction.SOUTH", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.SOUTH", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasVariable-nl.tudelft.jpacman.game.Game.progressLock", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.progressLock", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasVariable-nl.tudelft.jpacman.board.Square.neighbours", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.neighbours", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky-hasVariable-nl.tudelft.jpacman.npc.ghost.Pinky.INTERVAL_VARIATION", "source": "nl.tudelft.jpacman.npc.ghost.Pinky", "target": "nl.tudelft.jpacman.npc.ghost.Pinky.INTERVAL_VARIATION", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky-hasVariable-nl.tudelft.jpacman.npc.ghost.Pinky.SQUARES_AHEAD", "source": "nl.tudelft.jpacman.npc.ghost.Pinky", "target": "nl.tudelft.jpacman.npc.ghost.Pinky.SQUARES_AHEAD", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasVariable-nl.tudelft.jpacman.ui.PacManUiBuilder.buttons", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.buttons", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap-hasVariable-nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.pointCalculator", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "target": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.pointCalculator", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasVariable-nl.tudelft.jpacman.Launcher.levelMap", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.levelMap", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level$NpcMoveTask-hasVariable-nl.tudelft.jpacman.level.Level$NpcMoveTask.service", "source": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask.service", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde-hasVariable-nl.tudelft.jpacman.npc.ghost.Clyde.MOVE_INTERVAL", "source": "nl.tudelft.jpacman.npc.ghost.Clyde", "target": "nl.tudelft.jpacman.npc.ghost.Clyde.MOVE_INTERVAL", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasVariable-nl.tudelft.jpacman.Launcher.game", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.game", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasVariable-nl.tudelft.jpacman.Launcher.DEFAULT_MAP", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.DEFAULT_MAP", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor-hasVariable-nl.tudelft.jpacman.npc.ghost.GhostColor.ORANGE", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor.ORANGE", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasVariable-nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_ANIMATION_FRAMES", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_ANIMATION_FRAMES", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasVariable-nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.ANIMATION_DELAY", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasVariable-nl.tudelft.jpacman.board.Unit.direction", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.direction", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ButtonPanel-hasVariable-nl.tudelft.jpacman.ui.ButtonPanel.serialVersionUID", "source": "nl.tudelft.jpacman.ui.ButtonPanel", "target": "nl.tudelft.jpacman.ui.ButtonPanel.serialVersionUID", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasVariable-nl.tudelft.jpacman.ui.PacManUiBuilder.keyMappings", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.keyMappings", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasVariable-nl.tudelft.jpacman.ui.BoardPanel.game", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel.game", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasVariable-nl.tudelft.jpacman.level.MapParser.boardCreator", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.boardCreator", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.PINKY", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.PINKY", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor-hasVariable-nl.tudelft.jpacman.npc.ghost.GhostColor.RED", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor.RED", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde-hasVariable-nl.tudelft.jpacman.npc.ghost.Clyde.SHYNESS", "source": "nl.tudelft.jpacman.npc.ghost.Clyde", "target": "nl.tudelft.jpacman.npc.ghost.Clyde.SHYNESS", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.GHOSTS", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.GHOSTS", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasVariable-nl.tudelft.jpacman.sprite.AnimatedSprite.END_OF_LOOP", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.END_OF_LOOP", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet-hasVariable-nl.tudelft.jpacman.level.Pellet.image", "source": "nl.tudelft.jpacman.level.Pellet", "target": "nl.tudelft.jpacman.level.Pellet.image", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.players", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.players", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasVariable-nl.tudelft.jpacman.npc.Ghost.sprites", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.sprites", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasVariable-nl.tudelft.jpacman.ui.PacManUiBuilder.scoreFormatter", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.scoreFormatter", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall-hasVariable-nl.tudelft.jpacman.board.BoardFactory$Wall.background", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall.background", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.ghostFact", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.ghostFact", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI-hasVariable-nl.tudelft.jpacman.ui.PacManUI.serialVersionUID", "source": "nl.tudelft.jpacman.ui.PacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI.serialVersionUID", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky-hasVariable-nl.tudelft.jpacman.npc.ghost.Inky.SQUARES_AHEAD", "source": "nl.tudelft.jpacman.npc.ghost.Inky", "target": "nl.tudelft.jpacman.npc.ghost.Inky.SQUARES_AHEAD", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasVariable-nl.tudelft.jpacman.ui.PacManUiBuilder.defaultButtons", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.defaultButtons", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasVariable-nl.tudelft.jpacman.sprite.AnimatedSprite.animationFrames", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.animationFrames", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasVariable-nl.tudelft.jpacman.npc.ghost.Navigation$Node.parent", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.parent", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasVariable-nl.tudelft.jpacman.game.Game.inProgress", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.inProgress", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost-hasVariable-nl.tudelft.jpacman.level.LevelFactory$RandomGhost.DELAY", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost.DELAY", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame-hasVariable-nl.tudelft.jpacman.game.SinglePlayerGame.player", "source": "nl.tudelft.jpacman.game.SinglePlayerGame", "target": "nl.tudelft.jpacman.game.SinglePlayerGame.player", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame-hasVariable-nl.tudelft.jpacman.game.SinglePlayerGame.level", "source": "nl.tudelft.jpacman.game.SinglePlayerGame", "target": "nl.tudelft.jpacman.game.SinglePlayerGame.level", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.inProgress", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.inProgress", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasVariable-nl.tudelft.jpacman.sprite.AnimatedSprite.looping", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.looping", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.PELLET_VALUE", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.PELLET_VALUE", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasVariable-nl.tudelft.jpacman.level.Player.score", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.score", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasVariable-nl.tudelft.jpacman.board.Direction.deltaY", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.deltaY", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde-hasVariable-nl.tudelft.jpacman.npc.ghost.Clyde.INTERVAL_VARIATION", "source": "nl.tudelft.jpacman.npc.ghost.Clyde", "target": "nl.tudelft.jpacman.npc.ghost.Clyde.INTERVAL_VARIATION", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-hasVariable-nl.tudelft.jpacman.ui.ScorePanel.scoreFormatter", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel.scoreFormatter", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory-hasVariable-nl.tudelft.jpacman.level.PlayerFactory.sprites", "source": "nl.tudelft.jpacman.level.PlayerFactory", "target": "nl.tudelft.jpacman.level.PlayerFactory.sprites", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky-hasVariable-nl.tudelft.jpacman.npc.ghost.Blinky.INTERVAL_VARIATION", "source": "nl.tudelft.jpacman.npc.ghost.Blinky", "target": "nl.tudelft.jpacman.npc.ghost.Blinky.INTERVAL_VARIATION", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasVariable-nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel.SQUARE_SIZE", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasVariable-nl.tudelft.jpacman.npc.Ghost.intervalVariation", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.intervalVariation", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Square-hasVariable-nl.tudelft.jpacman.board.Square.occupants", "source": "nl.tudelft.jpacman.board.Square", "target": "nl.tudelft.jpacman.board.Square.occupants", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky-hasVariable-nl.tudelft.jpacman.npc.ghost.Blinky.MOVE_INTERVAL", "source": "nl.tudelft.jpacman.npc.ghost.Blinky", "target": "nl.tudelft.jpacman.npc.ghost.Blinky.MOVE_INTERVAL", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasVariable-nl.tudelft.jpacman.Launcher.pacManUI", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.pacManUI", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-hasVariable-nl.tudelft.jpacman.sprite.ImageSprite.image", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.ImageSprite.image", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground-hasVariable-nl.tudelft.jpacman.board.BoardFactory$Ground.background", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground.background", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler-hasVariable-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler.handler", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-hasVariable-nl.tudelft.jpacman.game.Game.pointCalculator", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.game.Game.pointCalculator", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI-hasVariable-nl.tudelft.jpacman.ui.PacManUI.scorePanel", "source": "nl.tudelft.jpacman.ui.PacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI.scorePanel", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasVariable-nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_DEATH_FRAMES", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.PACMAN_DEATH_FRAMES", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore-hasVariable-nl.tudelft.jpacman.sprite.SpriteStore.spriteMap", "source": "nl.tudelft.jpacman.sprite.SpriteStore", "target": "nl.tudelft.jpacman.sprite.SpriteStore.spriteMap", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-hasVariable-nl.tudelft.jpacman.level.PlayerCollisions.pointCalculator", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.PlayerCollisions.pointCalculator", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasVariable-nl.tudelft.jpacman.sprite.PacManSprites.GHOST_ANIMATION_FRAMES", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.GHOST_ANIMATION_FRAMES", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.startStopLock", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.startStopLock", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-hasVariable-nl.tudelft.jpacman.npc.Ghost.moveInterval", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.npc.Ghost.moveInterval", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.board", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.board", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.PointCalculatorLoader-hasVariable-nl.tudelft.jpacman.points.PointCalculatorLoader.clazz", "source": "nl.tudelft.jpacman.points.PointCalculatorLoader", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader.clazz", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.BLINKY", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.BLINKY", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacKeyListener-hasVariable-nl.tudelft.jpacman.ui.PacKeyListener.mappings", "source": "nl.tudelft.jpacman.ui.PacKeyListener", "target": "nl.tudelft.jpacman.ui.PacKeyListener.mappings", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasVariable-nl.tudelft.jpacman.npc.ghost.Navigation$Node.square", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.square", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher-hasVariable-nl.tudelft.jpacman.Launcher.SPRITE_STORE", "source": "nl.tudelft.jpacman.Launcher", "target": "nl.tudelft.jpacman.Launcher.SPRITE_STORE", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasVariable-nl.tudelft.jpacman.board.Direction.deltaX", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.deltaX", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory-hasVariable-nl.tudelft.jpacman.npc.ghost.GhostFactory.sprites", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory.sprites", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder-hasVariable-nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder.STOP_CAPTION", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI-hasVariable-nl.tudelft.jpacman.ui.PacManUI.FRAME_INTERVAL", "source": "nl.tudelft.jpacman.ui.PacManUI", "target": "nl.tudelft.jpacman.ui.PacManUI.FRAME_INTERVAL", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasVariable-nl.tudelft.jpacman.sprite.AnimatedSprite.lastUpdate", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.lastUpdate", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasVariable-nl.tudelft.jpacman.board.Direction.NORTH", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.NORTH", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-hasVariable-nl.tudelft.jpacman.ui.ScorePanel.DEFAULT_SCORE_FORMATTER", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel.DEFAULT_SCORE_FORMATTER", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation$Node-hasVariable-nl.tudelft.jpacman.npc.ghost.Navigation$Node.direction", "source": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node.direction", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky-hasVariable-nl.tudelft.jpacman.npc.ghost.Pinky.MOVE_INTERVAL", "source": "nl.tudelft.jpacman.npc.ghost.Pinky", "target": "nl.tudelft.jpacman.npc.ghost.Pinky.MOVE_INTERVAL", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Unit-hasVariable-nl.tudelft.jpacman.board.Unit.square", "source": "nl.tudelft.jpacman.board.Unit", "target": "nl.tudelft.jpacman.board.Unit.square", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.startSquares", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.startSquares", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet-hasVariable-nl.tudelft.jpacman.level.Pellet.value", "source": "nl.tudelft.jpacman.level.Pellet", "target": "nl.tudelft.jpacman.level.Pellet.value", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor-hasVariable-nl.tudelft.jpacman.npc.ghost.GhostColor.PINK", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor.PINK", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.collisions", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.collisions", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.INKY", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.INKY", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.sprites", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.sprites", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasVariable-nl.tudelft.jpacman.ui.BoardPanel.BACKGROUND_COLOR", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel.BACKGROUND_COLOR", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.BoardPanel-hasVariable-nl.tudelft.jpacman.ui.BoardPanel.serialVersionUID", "source": "nl.tudelft.jpacman.ui.BoardPanel", "target": "nl.tudelft.jpacman.ui.BoardPanel.serialVersionUID", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level-hasVariable-nl.tudelft.jpacman.level.Level.observers", "source": "nl.tudelft.jpacman.level.Level", "target": "nl.tudelft.jpacman.level.Level.observers", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser-hasVariable-nl.tudelft.jpacman.level.MapParser.levelCreator", "source": "nl.tudelft.jpacman.level.MapParser", "target": "nl.tudelft.jpacman.level.MapParser.levelCreator", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.pointCalculator", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.pointCalculator", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasVariable-nl.tudelft.jpacman.level.Player.sprites", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.sprites", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostColor-hasVariable-nl.tudelft.jpacman.npc.ghost.GhostColor.CYAN", "source": "nl.tudelft.jpacman.npc.ghost.GhostColor", "target": "nl.tudelft.jpacman.npc.ghost.GhostColor.CYAN", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasVariable-nl.tudelft.jpacman.level.Player.killer", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.killer", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.ScorePanel-hasVariable-nl.tudelft.jpacman.ui.ScorePanel.serialVersionUID", "source": "nl.tudelft.jpacman.ui.ScorePanel", "target": "nl.tudelft.jpacman.ui.ScorePanel.serialVersionUID", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-hasVariable-nl.tudelft.jpacman.sprite.AnimatedSprite.animating", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite.animating", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky-hasVariable-nl.tudelft.jpacman.npc.ghost.Inky.MOVE_INTERVAL", "source": "nl.tudelft.jpacman.npc.ghost.Inky", "target": "nl.tudelft.jpacman.npc.ghost.Inky.MOVE_INTERVAL", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-hasVariable-nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.PacManSprites.SPRITE_SIZE", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky-hasVariable-nl.tudelft.jpacman.npc.ghost.Inky.INTERVAL_VARIATION", "source": "nl.tudelft.jpacman.npc.ghost.Inky", "target": "nl.tudelft.jpacman.npc.ghost.Inky.INTERVAL_VARIATION", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory-hasVariable-nl.tudelft.jpacman.level.LevelFactory.CLYDE", "source": "nl.tudelft.jpacman.level.LevelFactory", "target": "nl.tudelft.jpacman.level.LevelFactory.CLYDE", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.Direction-hasVariable-nl.tudelft.jpacman.board.Direction.WEST", "source": "nl.tudelft.jpacman.board.Direction", "target": "nl.tudelft.jpacman.board.Direction.WEST", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-hasVariable-nl.tudelft.jpacman.level.Player.deathSprite", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.level.Player.deathSprite", "label": "hasVariable", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Pellet-specializes-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.Pellet", "target": "nl.tudelft.jpacman.board.Unit", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.SinglePlayerGame-specializes-nl.tudelft.jpacman.game.Game", "source": "nl.tudelft.jpacman.game.SinglePlayerGame", "target": "nl.tudelft.jpacman.game.Game", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Inky-specializes-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.Inky", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Wall-specializes-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.BoardFactory$Wall", "target": "nl.tudelft.jpacman.board.Square", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.Game-specializes-nl.tudelft.jpacman.level.Level$LevelObserver", "source": "nl.tudelft.jpacman.game.Game", "target": "nl.tudelft.jpacman.level.Level$LevelObserver", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites-specializes-nl.tudelft.jpacman.sprite.SpriteStore", "source": "nl.tudelft.jpacman.sprite.PacManSprites", "target": "nl.tudelft.jpacman.sprite.SpriteStore", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Pinky-specializes-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.Pinky", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost-specializes-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Player-specializes-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.level.Player", "target": "nl.tudelft.jpacman.board.Unit", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerCollisions-specializes-nl.tudelft.jpacman.level.CollisionMap", "source": "nl.tudelft.jpacman.level.PlayerCollisions", "target": "nl.tudelft.jpacman.level.CollisionMap", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory$Ground-specializes-nl.tudelft.jpacman.board.Square", "source": "nl.tudelft.jpacman.board.BoardFactory$Ground", "target": "nl.tudelft.jpacman.board.Square", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler-specializes-nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite-specializes-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.ImageSprite", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite-specializes-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.EmptySprite", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap-specializes-nl.tudelft.jpacman.level.CollisionMap", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionMap", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.AnimatedSprite-specializes-nl.tudelft.jpacman.sprite.Sprite", "source": "nl.tudelft.jpacman.sprite.AnimatedSprite", "target": "nl.tudelft.jpacman.sprite.Sprite", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Blinky-specializes-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.Blinky", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.points.DefaultPointCalculator-specializes-nl.tudelft.jpacman.points.PointCalculator", "source": "nl.tudelft.jpacman.points.DefaultPointCalculator", "target": "nl.tudelft.jpacman.points.PointCalculator", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.Ghost-specializes-nl.tudelft.jpacman.board.Unit", "source": "nl.tudelft.jpacman.npc.Ghost", "target": "nl.tudelft.jpacman.board.Unit", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Clyde-specializes-nl.tudelft.jpacman.npc.Ghost", "source": "nl.tudelft.jpacman.npc.ghost.Clyde", "target": "nl.tudelft.jpacman.npc.Ghost", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap-specializes-nl.tudelft.jpacman.level.CollisionMap", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap", "target": "nl.tudelft.jpacman.level.CollisionMap", "label": "specializes", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)-instantiates-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman.level.MapParser.parseMap(java.lang.String)", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)-instantiates-nl.tudelft.jpacman.level.Level", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.Level", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.makeLevel()-instantiates-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman.Launcher.makeLevel()", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()-instantiates-nl.tudelft.jpacman.npc.ghost.Pinky", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createPinky()", "target": "nl.tudelft.jpacman.npc.ghost.Pinky", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.launch()-instantiates-nl.tudelft.jpacman.ui.PacManUiBuilder", "source": "nl.tudelft.jpacman.Launcher.launch()", "target": "nl.tudelft.jpacman.ui.PacManUiBuilder", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)-instantiates-nl.tudelft.jpacman.game.SinglePlayerGame", "source": "nl.tudelft.jpacman.game.GameFactory.createSinglePlayerGame(nl.tudelft.jpacman.level.Level,nl.tudelft.jpacman.points.PointCalculator)", "target": "nl.tudelft.jpacman.game.SinglePlayerGame", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)-instantiates-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.shortestPath(nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Square,nl.tudelft.jpacman.board.Unit)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGhostFactory()-instantiates-nl.tudelft.jpacman.npc.ghost.GhostFactory", "source": "nl.tudelft.jpacman.Launcher.getGhostFactory()", "target": "nl.tudelft.jpacman.npc.ghost.GhostFactory", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createGhost()-instantiates-nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "source": "nl.tudelft.jpacman.level.LevelFactory.createGhost()", "target": "nl.tudelft.jpacman.level.LevelFactory$RandomGhost", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.Level.startNPCs()-instantiates-nl.tudelft.jpacman.level.Level$NpcMoveTask", "source": "nl.tudelft.jpacman.level.Level.startNPCs()", "target": "nl.tudelft.jpacman.level.Level$NpcMoveTask", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()-instantiates-nl.tudelft.jpacman.level.Player", "source": "nl.tudelft.jpacman.level.PlayerFactory.createPacMan()", "target": "nl.tudelft.jpacman.level.Player", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)-instantiates-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman.sprite.PacManSprites.loadSprite(java.lang.String)", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-instantiates-nl.tudelft.jpacman.ui.BoardPanel", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.BoardPanel", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()-instantiates-nl.tudelft.jpacman.level.CollisionInteractionMap", "source": "nl.tudelft.jpacman.level.DefaultPlayerInteractionMap.defaultCollisions()", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-instantiates-nl.tudelft.jpacman.sprite.EmptySprite", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)-instantiates-nl.tudelft.jpacman.sprite.ImageSprite", "source": "nl.tudelft.jpacman.sprite.SpriteStore.loadSpriteFromResource(java.lang.String)", "target": "nl.tudelft.jpacman.sprite.ImageSprite", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getLevelFactory()-instantiates-nl.tudelft.jpacman.level.LevelFactory", "source": "nl.tudelft.jpacman.Launcher.getLevelFactory()", "target": "nl.tudelft.jpacman.level.LevelFactory", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()-instantiates-nl.tudelft.jpacman.npc.ghost.Blinky", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createBlinky()", "target": "nl.tudelft.jpacman.npc.ghost.Blinky", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createWall()-instantiates-nl.tudelft.jpacman.board.BoardFactory$Wall", "source": "nl.tudelft.jpacman.board.BoardFactory.createWall()", "target": "nl.tudelft.jpacman.board.BoardFactory$Wall", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getMapParser()-instantiates-nl.tudelft.jpacman.level.MapParser", "source": "nl.tudelft.jpacman.Launcher.getMapParser()", "target": "nl.tudelft.jpacman.level.MapParser", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createGround()-instantiates-nl.tudelft.jpacman.board.BoardFactory$Ground", "source": "nl.tudelft.jpacman.board.BoardFactory.createGround()", "target": "nl.tudelft.jpacman.board.BoardFactory$Ground", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-instantiates-nl.tudelft.jpacman.ui.ButtonPanel", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.ButtonPanel", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createPellet()-instantiates-nl.tudelft.jpacman.level.Pellet", "source": "nl.tudelft.jpacman.level.LevelFactory.createPellet()", "target": "nl.tudelft.jpacman.level.Pellet", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)-instantiates-nl.tudelft.jpacman.sprite.EmptySprite", "source": "nl.tudelft.jpacman.sprite.EmptySprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.EmptySprite", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)-instantiates-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman.level.MapParser.addSquare(nl.tudelft.jpacman.board.Square[][],java.util.List,java.util.List,int,int,char)", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-instantiates-nl.tudelft.jpacman.ui.ScorePanel", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.ScorePanel", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)-instantiates-nl.tudelft.jpacman.npc.ghost.Navigation$Node", "source": "nl.tudelft.jpacman.npc.ghost.Navigation.addNewTargets(nl.tudelft.jpacman.board.Unit,java.util.List,java.util.Set,nl.tudelft.jpacman.npc.ghost.Navigation$Node,nl.tudelft.jpacman.board.Square)", "target": "nl.tudelft.jpacman.npc.ghost.Navigation$Node", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getGameFactory()-instantiates-nl.tudelft.jpacman.game.GameFactory", "source": "nl.tudelft.jpacman.Launcher.getGameFactory()", "target": "nl.tudelft.jpacman.game.GameFactory", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])-instantiates-nl.tudelft.jpacman.board.Board", "source": "nl.tudelft.jpacman.board.BoardFactory.createBoard(nl.tudelft.jpacman.board.Square[][])", "target": "nl.tudelft.jpacman.board.Board", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()-instantiates-nl.tudelft.jpacman.npc.ghost.Inky", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createInky()", "target": "nl.tudelft.jpacman.npc.ghost.Inky", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)-instantiates-nl.tudelft.jpacman.PacmanConfigurationException", "source": "nl.tudelft.jpacman.level.MapParser.checkMapFormat(java.util.List)", "target": "nl.tudelft.jpacman.PacmanConfigurationException", "label": "instantiates", "properties": {"weight": 4, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])-instantiates-nl.tudelft.jpacman.Launcher", "source": "nl.tudelft.jpacman.Launcher.main(java.lang.String[])", "target": "nl.tudelft.jpacman.Launcher", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getPlayerFactory()-instantiates-nl.tudelft.jpacman.level.PlayerFactory", "source": "nl.tudelft.jpacman.Launcher.getPlayerFactory()", "target": "nl.tudelft.jpacman.level.PlayerFactory", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()-instantiates-nl.tudelft.jpacman.npc.ghost.Clyde", "source": "nl.tudelft.jpacman.npc.ghost.GhostFactory.createClyde()", "target": "nl.tudelft.jpacman.npc.ghost.Clyde", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)-instantiates-nl.tudelft.jpacman.level.PlayerCollisions", "source": "nl.tudelft.jpacman.level.LevelFactory.createLevel(nl.tudelft.jpacman.board.Board,java.util.List,java.util.List)", "target": "nl.tudelft.jpacman.level.PlayerCollisions", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)-instantiates-nl.tudelft.jpacman.ui.PacManUI", "source": "nl.tudelft.jpacman.ui.PacManUiBuilder.build(nl.tudelft.jpacman.game.Game)", "target": "nl.tudelft.jpacman.ui.PacManUI", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.loadPointCalculator()-instantiates-nl.tudelft.jpacman.points.PointCalculatorLoader", "source": "nl.tudelft.jpacman.Launcher.loadPointCalculator()", "target": "nl.tudelft.jpacman.points.PointCalculatorLoader", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.Launcher.getBoardFactory()-instantiates-nl.tudelft.jpacman.board.BoardFactory", "source": "nl.tudelft.jpacman.Launcher.getBoardFactory()", "target": "nl.tudelft.jpacman.board.BoardFactory", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)-instantiates-nl.tudelft.jpacman.ui.PacKeyListener", "source": "nl.tudelft.jpacman.ui.PacManUI(nl.tudelft.jpacman.game.Game,java.util.Map,java.util.Map,nl.tudelft.jpacman.ui.ScorePanel$ScoreFormatter)", "target": "nl.tudelft.jpacman.ui.PacKeyListener", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)-instantiates-nl.tudelft.jpacman.sprite.AnimatedSprite", "source": "nl.tudelft.jpacman.sprite.SpriteStore.createAnimatedSprite(nl.tudelft.jpacman.sprite.Sprite,int,int,boolean)", "target": "nl.tudelft.jpacman.sprite.AnimatedSprite", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)-instantiates-nl.tudelft.jpacman.sprite.ImageSprite", "source": "nl.tudelft.jpacman.sprite.ImageSprite.split(int,int,int,int)", "target": "nl.tudelft.jpacman.sprite.ImageSprite", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)-instantiates-nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "source": "nl.tudelft.jpacman.level.CollisionInteractionMap.onCollision(java.lang.Class,java.lang.Class,boolean,nl.tudelft.jpacman.level.CollisionInteractionMap$CollisionHandler)", "target": "nl.tudelft.jpacman.level.CollisionInteractionMap$InverseCollisionHandler", "label": "instantiates", "properties": {"weight": 1, "metaSrc": "source code"}}}, {"data": {"id": "nl.tudelft.jpacman.board-dependsOn-nl.tudelft.jpacman.sprite", "source": "nl.tudelft.jpacman.board", "target": "nl.tudelft.jpacman.sprite", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.board package and the nl.tudelft.jpacman.sprite package are designed to work together to create a functional Pacman game. The board package manages the game grid, including squares and walls, while the sprite package provides visual representations of these elements, such as sprites for walls, pellets, and Pac-Man characters. The two packages interact through the BoardFactory class in the board package, which uses methods from the SpriteStore class in the sprite package to load and create sprites for the game grid."}}}, {"data": {"id": "nl.tudelft.jpacman.level-dependsOn-nl.tudelft.jpacman.sprite", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.sprite", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.level package manages game levels and interactions between game units, while the nl.tudelft.jpacman.sprite package provides sprite management for various game elements such as walls, pellets, and characters. The level package uses sprites from the sprite package to render and animate these elements in the game, facilitating the visual representation of the game world and its entities."}}}, {"data": {"id": "nl.tudelft.jpacman.ui-dependsOn-nl.tudelft.jpacman.sprite", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.sprite", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.ui package and the nl.tudelft.jpacman.sprite package are designed to work together to create a functional Pacman game. The ui package manages the user interface, including rendering the game board and handling user input, while the sprite package provides the visual elements of the game, such as sprites for walls, pellets, and Pac-Man characters. The two packages interact through the BoardPanel class in the ui package, which uses methods from the Sprite class in the sprite package to render the game board and its contents."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-dependsOn-nl.tudelft.jpacman.sprite", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.sprite", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.npc.ghost package relies on the nl.tudelft.jpacman.sprite package for managing and providing game sprites, including animated sprites for ghosts. The GhostFactory class uses methods from PacManSprites to create instances of different ghost characters based on their color and sprite configurations, facilitating the creation of visually distinct and interactive ghost entities in the Pac-Man game."}}}, {"data": {"id": "nl.tudelft.jpacman.game-dependsOn-nl.tudelft.jpacman.points", "source": "nl.tudelft.jpacman.game", "target": "nl.tudelft.jpacman.points", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.game package and the nl.tudelft.jpacman.points package are designed to work together to manage game state and player points in a Pacman implementation. The Game class in the game package interacts with the PointCalculator interface in the points package to calculate and update player scores based on their actions, such as moving and consuming pellets or colliding with ghosts. This interaction ensures that the game's scoring system is accurately reflected in the game state."}}}, {"data": {"id": "nl.tudelft.jpacman.game-dependsOn-nl.tudelft.jpacman.level", "source": "nl.tudelft.jpacman.game", "target": "nl.tudelft.jpacman.level", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.game package manages game state and provides methods for interacting with the game board and players, while the nl.tudelft.jpacman.level package handles game levels, player interactions, and collision handling. The GameFactory class in the game package creates and manages game instances, including initializing players, levels, and point calculators to orchestrate a single-player Pac-Man game. The Level class in the level package is responsible for managing the state and behavior of a game level, including player interactions, pellet collection, and game progression."}}}, {"data": {"id": "nl.tudelft.jpacman.ui-dependsOn-nl.tudelft.jpacman.game", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.game", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.ui package provides user interface components for managing and rendering the Pacman game, while the nl.tudelft.jpacman.game package manages the game state and logic. The ui package depends on the game package to access game-related data such as levels, players, and scores, enabling it to render the game board and handle user input effectively."}}}, {"data": {"id": "nl.tudelft.jpacman-dependsOn-nl.tudelft.jpacman.game", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.game", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman package provides game-related operations and configurations, while the nl.tudelft.jpacman.game package manages the game state, including player interactions and level management. The Launcher class in the jpacman package uses GameFactory to create and manage single-player games, which interact with the Game class for game logic and player movement."}}}, {"data": {"id": "nl.tudelft.jpacman.level-dependsOn-nl.tudelft.jpacman.board", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.board", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.level package provides the game logic and state management for Pac-Man, while the nl.tudelft.jpacman.board package defines the physical structure and movement rules of the game board. They are tightly coupled as the level relies on the board to manage its grid and units, ensuring that the game's mechanics are consistent with its visual representation."}}}, {"data": {"id": "nl.tudelft.jpacman.ui-dependsOn-nl.tudelft.jpacman.board", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.board", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.ui package and the nl.tudelft.jpacman.board package are tightly coupled, with the ui package providing user interface components that rely on the board package for game logic and rendering. The board package manages the game's grid structure and entities, while the ui package handles visual representation and user interaction, ensuring a seamless integration between the two packages to create an interactive Pacman game."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-dependsOn-nl.tudelft.jpacman.board", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.board", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.npc.ghost package and the nl.tudelft.jpacman.board package are designed to work together to create a game environment where ghosts navigate and interact with the board, which includes obstacles, walls, and other entities that affect their movement and behavior in the game."}}}, {"data": {"id": "nl.tudelft.jpacman.npc-dependsOn-nl.tudelft.jpacman.board", "source": "nl.tudelft.jpacman.npc", "target": "nl.tudelft.jpacman.board", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.npc package provides navigation and pathfinding for ghosts in the Pac-Man game, while the nl.tudelft.jpacman.board package manages game board components such as squares and walls, ensuring a playable grid is created. The two packages are interdependent, with the npc package using methods from the board package to determine ghost movement and access square information, while the board package uses methods from the npc package to manage ghost behavior and appearance."}}}, {"data": {"id": "nl.tudelft.jpacman.level-dependsOn-nl.tudelft.jpacman.points", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.points", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.level package and the nl.tudelft.jpacman.points package are designed to work together to manage game logic and scoring in a Pac-Man game. The level package handles player interactions, pellet collection, and game progression, while the points package manages how these actions affect the player's score through point calculations."}}}, {"data": {"id": "nl.tudelft.jpacman.points-dependsOn-nl.tudelft.jpacman.level", "source": "nl.tudelft.jpacman.points", "target": "nl.tudelft.jpacman.level", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.points package and the nl.tudelft.jpacman.level package are designed to work together to manage player points and game levels in a Pac-Man game. The `DefaultPointCalculator` class in the points package calculates and updates player scores based on pellet consumption and collisions with ghosts, while the `Level` class in the level package manages game entities such as players, pellets, and ghosts, updating their states and interactions accordingly."}}}, {"data": {"id": "nl.tudelft.jpacman-dependsOn-nl.tudelft.jpacman.points", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.points", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman package manages game-related operations and uses the nl.tudelft.jpacman.points package for calculating player points based on various actions, such as consuming pellets and colliding with ghosts. The PointCalculatorLoader class in the points package dynamically loads point calculators from a file or uses a default if not found, which is then used by the Launcher class to manage game-related operations."}}}, {"data": {"id": "nl.tudelft.jpacman.ui-dependsOn-nl.tudelft.jpacman.level", "source": "nl.tudelft.jpacman.ui", "target": "nl.tudelft.jpacman.level", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.ui package and the nl.tudelft.jpacman.level package are designed to work together to create a functional Pac-Man game. The ui package manages the user interface, including rendering the game board, handling user input, and displaying scores, while the level package handles the game logic, such as managing levels, player interactions, and collision detection. They interact through shared interfaces and classes that allow the ui to display and update the game state based on the information provided by the level package."}}}, {"data": {"id": "nl.tudelft.jpacman.level-dependsOn-nl.tudelft.jpacman.npc.ghost", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.npc.ghost", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.level package manages game levels and player interactions, while the nl.tudelft.jpacman.npc.ghost package handles navigation and pathfinding for ghosts in the Pac-Man game. The level package uses ghost factory methods to create different types of ghosts based on their color and sprite configurations, which are then used by the ghost package to manage their behavior and movement."}}}, {"data": {"id": "nl.tudelft.jpacman.level-dependsOn-nl.tudelft.jpacman.npc", "source": "nl.tudelft.jpacman.level", "target": "nl.tudelft.jpacman.npc", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.level package manages game levels and player interactions, while the nl.tudelft.jpacman.npc package handles navigation and pathfinding for ghosts in the Pac-Man game. The level package uses NPC classes from the npc package to manage ghost movement and behavior, ensuring that the game's NPCs operate within the constraints of the game board and interact with other entities as defined by the collision map."}}}, {"data": {"id": "nl.tudelft.jpacman-dependsOn-nl.tudelft.jpacman.level", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.level", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman package manages game-related operations, including parsing maps and creating levels, while the nl.tudelft.jpacman.level package handles game levels, player interactions, and collision handling. The `Launcher` class in the first package uses the `MapParser` to parse map files into game levels for Pac-Man, demonstrating a dependency where the former depends on the latter for parsing functionality."}}}, {"data": {"id": "nl.tudelft.jpacman-dependsOn-nl.tudelft.jpacman.ui", "source": "nl.tudelft.jpacman", "target": "nl.tudelft.jpacman.ui", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman package manages game-related operations, while the nl.tudelft.jpacman.ui package handles user interface components and interactions for a Pacman game. The two packages are interdependent as they work together to create and manage the visual representation of the game board, handle player input, and display scores."}}}, {"data": {"id": "nl.tudelft.jpacman.npc.ghost-dependsOn-nl.tudelft.jpacman.npc", "source": "nl.tudelft.jpacman.npc.ghost", "target": "nl.tudelft.jpacman.npc", "label": "dependsOn", "properties": {"description": "The nl.tudelft.jpacman.npc.ghost package provides specific implementations for various ghost characters in the Pac-Man game, while the nl.tudelft.jpacman.npc package acts as a service provider that manages and initializes these ghosts using common functionalities defined in the Ghost class. This design allows for easy extension and modification of ghost behavior without altering the core logic of the game."}}}]}}